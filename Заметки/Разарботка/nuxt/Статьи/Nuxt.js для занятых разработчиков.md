::: v-pre
https://www.codemag.com/Article/2105101/Nuxt.js-for-Busy-Developers

Nuxt.js — это фреймворк для веб-разработки, основанный на фреймворке Vue.js. Это не новый фреймворк, и он мало что добавляет к кодовой базе Vue.js. Скорее, это упрощает разработку Vue.js с точки зрения настройки приложения и его различных компонентов, таких как маршрутизация и хранилище, а также следования рекомендациям по структурированию приложения Vue.js. Что еще более важно, он создает высокооптимизированный пакет вашего приложения.

Кроме того, Nuxt.js упрощает рендеринг на стороне сервера. Если вы разработчик Vue.js, вы уже знаете, что Vue.js предлагает рендеринг на стороне сервера. Руководство по рендерингу на стороне сервера находится на расстоянии одного клика прямо здесь ( [https://ssr.vuejs.org/](https://ssr.vuejs.org/) ). Nuxt.js использует возможности рендеринга на стороне сервера Vue.js и позволяет вам быстро создать приложение для рендеринга на стороне сервера.

Что уникально в Nuxt.js, так это соблюдение соглашения по стратегии конфигурации. В Nuxt.js вам не нужно писать много файлов конфигурации. Вместо этого вы организуете структуру папок таким образом, чтобы Nuxt.js мог ее понять, и соответственно построить окончательный пакет приложения. Например, в Nuxt.js вы не пишете файл конфигурации для маршрутов, доступных в приложении. Вместо этого вы создаете компоненты Vue.js внутри папки **/page/** , и, следовательно, Nuxt.js создает один маршрут для каждого компонента Vue.js в этой папке.

В этой статье предполагается, что у вас есть достаточный опыт работы и использования Vue.js. Если вы этого не сделаете или вам нужно быстро освежить знания, я рекомендую ознакомиться с этим ресурсом: Руководство для начинающих по Vue.js ( [https://welearncode.com/beginners-guide-vue/](https://welearncode.com/beginners-guide-vue/) ).

## Использование преимущества Nuxt.js

Сила Nuxt.js заключается в том, что вы можете разрабатывать различные веб-приложения. В настоящее время вы можете создавать следующие приложения:

-   Рендеринг на стороне сервера (SSR)
-   Одностраничные приложения (SPA)
-   Генерация статического сайта (SSG - пре-рендеринг)

### Рендеринг на стороне сервера (SSR)

Приложения для рендеринга на стороне сервера также известны как универсальные приложения или «изоморфные» приложения. Это приложение Vue.js, которое обрабатывается на стороне сервера до того, как оно будет отображено и представлено пользователям. Он загружается быстрее и более производительный. В итоге:

-   Предварительный рендеринг на сервере происходит исключительно на сервере Node.js.
-   Подготовьте HTML перед загрузкой
-   SEO-дружественный

**Рисунок 1** демонстрирует концепцию приложений SSR.

![Рисунок 1: Приложения SSR](https://codemag.com/Article/Image/2105101/figure1.png)  
**Рисунок 1:** Приложения SSR

### Одностраничные приложения (SPA)

SPA — это стандартное приложение Vue.js. Содержимое приложения, состоящее из файлов JS и CSS, загружается только один раз. Таким образом, переход с одной страницы на другую — это просто изменение компонента на стороне клиента. Вот почему это супер-быстро!

**Рисунок 2** демонстрирует концепцию приложений SPA.

![Рисунок 2: Приложения SPA](https://codemag.com/Article/Image/2105101/figure2.png)  
**Рисунок 2:** Приложения SPA

Клиентская часть или браузер запрашивает основной HTML-файл приложения с сервера. Затем он запрашивает файлы JavaScript (JS) и CSS, а также любой другой связанный контент. Сервер отвечает html-файлом, пустым и без данных. Кроме того, он обслуживает файлы JS и CSS по запросу. Это похоже на обычный HTTP-запрос.

К этому времени основной компонент Vue.js отрисовывается и отображается в браузере. Приложение может отправлять дополнительные запросы на сервер для получения данных, необходимых на странице.

Когда вы переходите на другие страницы, приложение отправляет дополнительные запросы на сервер для получения дополнительных данных.

Это здорово и все такое, но у СПА есть некоторые недостатки. Одним из основных недостатков SPA является SEO. Исходный html-файл, который клиентская сторона получает от сервера, — это просто пустая страница! Клиент отправляет дополнительные запросы на сервер для получения данных, чтобы отобразить их.

### Генерация статического сайта (SSG — предварительный рендеринг)

Генерация статических сайтов (SG) — это третий вариант, доступный вам при работе с Nuxt.js. Вы можете выполнить предварительную визуализацию всех страниц веб-приложения во время сборки. Тогда все приложение представляет собой не что иное, как простые статические HTML-файлы, которые вы можете обслуживать только из сети доставки контента (CDN)! Это, безусловно, самый дешевый, быстрый, безопасный и высокопроизводительный вариант, который у вас есть. Такие приложения, как блоги, приложения Jamstack ( [https://jamstack.org/](https://jamstack.org/) ) или другие статические приложения лучше всего подходят для SSG.

## Сила Nuxt.js

Несмотря на то, что вы можете создавать SPA с Nuxt.js, вся мощь этой платформы заключается в ее универсальном режиме или SSR для создания универсальных приложений.

> Nuxt.js лучше всего использовать для создания универсальных или изоморфных приложений.

Nuxt.js существует из-за недостатков традиционного SPA и рендеринга многостраничных приложений (MPA) на стороне сервера. По своей сути, это гибридное решение для обеих сторон.

С одной стороны, Nust.js предварительно обрабатывает первый запрос на стороне сервера и действует как MPA. С другой стороны, когда вы переходите с одной страницы на другую, он ведет себя как любой другой SPA. Вот почему он известен как универсальный или изоморфный.

## Как связаны Vue.js и Nuxt.js?

Nuxt.js построен на основе платформы Vue.js. Тем не менее, он оснащен дополнительными функциями, такими как:

-   Асинхронные перехватчики данных: используются для получения данных как на стороне сервера, так и на стороне клиента.
-   Промежуточное ПО: существует два типа промежуточного ПО:
    -   Промежуточное ПО маршрутизации, которое можно запустить перед отрисовкой страницы или группы страниц в рамках одного макета.
    -   Промежуточное ПО Node.js на стороне сервера, которое работает только на сервере.
-   Макеты: шаблон, который применяется и группирует страницы, интерфейс, обеспечивающий единый внешний вид. Вы можете иметь несколько макетов в одном приложении.
-   Модули: функция JavaScript верхнего уровня, которая выполняется при запуске Nuxt.js. Он добавляет определенные функции в приложение. Например, основной модуль @nuxtjs/axios ( [https://axios.nuxtjs.org/](https://axios.nuxtjs.org/) ) управляется командой Nuxt.js и обеспечивает безопасную и простую интеграцию с Axios ( [https://www.axios.com/)](https://www.axios.com/) . ) внутри вашего приложения.

Кроме того, Nuxt.js поставляется с набором предустановленных модулей и библиотек Vue.js, таких как:

-   Vue Framework ( [https://vuejs.org/](https://vuejs.org/) )
-   Маршрутизатор Vue ( [https://router.vuejs.org/](https://router.vuejs.org/) )
-   Вьюекс ( [https://vuex.vuejs.org/](https://vuex.vuejs.org/) )
-   Рендерер сервера Vue ( [https://ssr.vuejs.org/](https://ssr.vuejs.org/) )
-   VueMeta ( [https://vue-meta.nuxtjs.org/](https://vue-meta.nuxtjs.org/) )

Наконец, Nuxt.js использует Webpack ( [https://webpack.js.org/](https://webpack.js.org/) ) и Babel ( [https://babeljs.io/](https://babeljs.io/) ) для компиляции и связывания вашего исходного кода со следующими загрузчиками Webpack:

-   Загрузчик Vue ( [https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/) )
-   Загрузчик Babel ( [https://webpack.js.org/loaders/babel-loader/](https://webpack.js.org/loaders/babel-loader/) )

> Nuxt.js объединяет мощные модули Vue.js в одном приложении и предлагает вам аккуратное и структурированное приложение.

## Создайте приложение Nuxt.js

Хватит теории! Давайте запачкаем руки и создадим ваше первое приложение Nuxt.js. Я буду использовать интерфейс командной строки **create-nuxt-app** . Он поддерживается и поддерживается командой Nuxt.js. Исходный код CLI доступен по адресу [https://github.com/nuxt/create-nuxt-app](https://github.com/nuxt/create-nuxt-app) .

Прежде чем начать, убедитесь, что у вас есть все необходимые предварительные условия для создания, сборки и запуска приложений Nuxt.js локально на вашем компьютере.

### Предварительные условия для установки и использования Nuxt.js

Чтобы работать с приложениями Nuxt.js, вам необходимо хорошо знать JavaScript ES6. Вот один из моих любимых уроков; ES6 для начинающих ( [https://codeburst.io/es6-tutorial-for-beginners-5f3c4e7960be](https://codeburst.io/es6-tutorial-for-beginners-5f3c4e7960be) ).

Кроме того, необходимо четкое понимание и различие между разработкой на стороне сервера и на стороне клиента, чтобы понять, как Nuxt.js ведет себя и работает с обоими. Вот хорошее чтение, которое объяснит это: Код на стороне клиента и на стороне сервера: в чем разница? ( [https://www.seguetech.com/client-server-side-code/](https://www.seguetech.com/client-server-side-code/) ).

Что касается аппаратного и программного аспекта, поддерживаемые операционные системы:

-   Windows 10 или выше с PowerShell
-   macOS с терминалом
-   Системы Linux, такие как Ubuntu с терминалом

Предлагаемое кроссплатформенное программное обеспечение:

-   Node.js
-   Менеджер пакетов узлов (npm)

Вам потребуется текстовый редактор, например Visual Studio Code ( [https://code.visualstudio.com/](https://code.visualstudio.com/) ) с расширением Veutur ( [https://marketplace.visualstudio.com/items?itemName=octref.vetur](https://marketplace.visualstudio.com/items?itemName=octref.vetur) ) или WebStorm ( [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/) ).

Наконец, вам нужен терминал, встроенный терминал Visual Studio Code или терминал WebStorm.

Давайте создадим ваше первое приложение Nuxt.js.

### Создайте новое приложение Nuxt.js

Есть два способа создать новый Nuxt.js. Либо вы начинаете с нуля и добавляете все компоненты вручную, либо используете интерфейс командной строки **create-nuxt-app,** предоставленный командой Nuxt.js. Сегодня я не буду париться и начну с нуля. Это противоречило бы цели этой статьи. Вместо этого я буду использовать интерфейс командной строки **create-nuxt-app** . Он создает все необходимые каркасы и дает вам готовое приложение Nuxt.js за считанные секунды.

Начните с выполнения одной из следующих команд:

`// yarnyarn  create nuxt-app <project-name> // npxnpx create-nuxt-app <project-name> // npmnpm init nuxt-app <project-name>`

В процессе создания нового проекта Nuxt.js интерфейс командной строки задает несколько вопросов. Я пройдусь по ним, чтобы создать приложение. **На рис. 3** показана начальная точка команды CLI.

![Рисунок 3: Интерфейс командной строки create-nuxt-app](https://codemag.com/Article/Image/2105101/figure3.png)  
**Рисунок 3:** Интерфейс командной строки create-nuxt-app

> Интерфейс командной строки create-nuxt-app на сегодняшний день является лучшим вариантом для создания нового приложения Nuxt.js.

Ответим на каждый из вопросов:

-   **Название проекта:** Вы можете выбрать любое имя для своего нового проекта. Используйте тире (-) для разделения слов вместо пробелов.
-   **Язык программирования:** у вас есть выбор между TypeScript или JavaScript. Я выбрал JavaScript.
-   **Диспетчер пакетов:** выберите пряжу или npm. Я выбрал нпм.
-   **Платформа пользовательского интерфейса:** у вас есть множество поддерживаемых инфраструктур пользовательского интерфейса на выбор. Nuxt.js автоматически устанавливает любой выбранный вами фреймворк и интегрирует его в приложение. Я выбрал Tailwind CSS.
-   **Модули Nuxt.js:** они предлагаются командой Nuxt.js. Вскоре я рассмотрю эти модули и обсужу их. Я выбрал Аксиос.
-   **Инструменты анализа:** CLI поставляется с готовым набором инструментов анализа. Я выбрал промежуточные файлы ESLint, Prettier и Lint. CLI выполнит настройку всех инструментов за вас.
-   **Платформа тестирования:** вы можете выбрать любую среду тестирования. Я выбрал «Нет», так как не буду тестировать это демонстрационное приложение.
-   **Режим рендеринга:** здесь вы выбираете, хотите ли вы, чтобы ваше приложение отображалось на стороне сервера или на стороне клиента. Давайте рассмотрим это более подробно.
    -   Когда вы выбираете **режим рендеринга на стороне сервера** , это означает, что вы создаете приложение SSR или SSG. С другой стороны, если вы выбираете **режим рендеринга на стороне клиента** , это означает, что вы создаете SPA. Ваш выбор на этом этапе в конечном итоге сохраняется в файле конфигурации Nuxt.js под ключом **ssr** . Этот вариант может быть либо , `true`либо `false`. Вы можете узнать больше о рендеринге Nuxt.js, посетив эту статью: [https://nuxtjs.org/docs/2.x/features/rendering-modes](https://nuxtjs.org/docs/2.x/features/rendering-modes) . На данный момент я выберу Universal (SSR/SSG), так как хочу создать универсальное приложение для этой демонстрации.
-   **Цель развертывания:** вы можете думать о цели развертывания как о среде размещения, в которой вы будете размещать свое приложение. Это может быть как **статический** , так и **серверный** .
    -   Если вы выберете **static** , это означает, что вы собираетесь использовать Nuxt.js в качестве генератора статических сайтов. Статически визуализируйте свое приложение Nuxt.js и получите все преимущества универсального приложения без сервера. Nuxt.js создает статическую версию вашего сайта. Он берет все маршруты, которые вы определяете в приложении, и сохраняет их в виде отдельных html-файлов в папке **/dist/** .
    -   С другой стороны, если вы выбираете **server** , это означает, что для размещения вашего приложения требуется сервер. Nuxt.js использует Node.js в качестве хост-сервера для приложения. При рендеринге на стороне сервера страница визуализируется на сервере до того, как она будет передана браузеру клиента. Обратите внимание, что при выборе режима рендеринга на стороне клиента целью развертывания может быть только сервер.
    -   На данный момент я выберу сервер, хостинг Node.js, так как хочу создать универсальное приложение.
-   **Инструменты разработки:** я выбрал первый вариант — jsconfig.json. Этот файл используется для настройки компиляции JavaScript в вашем приложении.
-   **Непрерывная интеграция:** вы не будете использовать непрерывную интеграцию, поэтому выберите «Нет».
-   **Система контроля версий:** для этого я выберу Git.

Вот и все! Нажмите клавишу Enter, и пусть CLI сделает свое волшебство и создаст новое приложение Nuxt.js.

**На рис. 4** показана заключительная часть процесса установки.

![Рисунок 4: Заключительный этап установки CLI](https://codemag.com/Article/Image/2105101/figure4.png)  
**Рисунок 4:** Заключительный этап установки CLI

Интерфейс командной строки дает вам инструкции о том, как запустить приложение локально, а также как его собрать и сгенерировать пакет.

Давайте попробуем запустить приложение, введя следующие две команды:

`cd code-magazine-nuxt-demo npm run dev`

CLI компилирует как клиентскую, так и серверную часть, прежде чем сгенерировать окончательные файлы для обслуживания.

**На рис. 5** показано, когда интерфейс командной строки завершает создание вашего приложения.

![Рисунок 5: CLI завершает компиляцию и сборку приложения.](https://codemag.com/Article/Image/2105101/figure5.png)  
**Рисунок 5:** CLI завершает компиляцию и сборку приложения.

CLI дает вам достаточно информации о приложении. Преимуществ CLI много, будь то рендеринг на стороне сервера или на стороне клиента, реагирование на любое целевое развертывание, согласование состояния сборки и компиляции или распознавание URL-адреса, по которому вы можете обслуживать приложение локально.

Давайте посетим URL-адрес, который CLI предоставляет нам: http://localhost:3000/. **На рис. 6** показано работающее приложение.

![Рис. 6. Приложение Nuxt.js, работающее в браузере.](https://codemag.com/Article/Image/2105101/figure6.png)  
**Рис. 6.** Приложение Nuxt.js, работающее в браузере.

Давайте откроем приложение внутри VS Code и вместе проверим структуру папок. **На рис. 7** показаны папки и файлы приложения внутри VS Code.

![Рисунок 7: Приложение Nuxt.js внутри VS Code](https://codemag.com/Article/Image/2105101/figure7.png)  
**Рисунок 7:** Приложение Nuxt.js внутри VS Code

CLI создал для вас кучу папок. В следующем разделе я пройдусь по каждому из них, объясню его использование и приведу пример кода того, какой контент может находиться в каждой папке.

## Изучение структуры папок приложений Nuxt.js

Интерфейс командной строки create-nuxt-app создает множество папок внутри приложения Nuxt.js. Некоторые из этих папок являются необязательными, а другие обязательными. В этом разделе я пройдусь по всем сгенерированным папкам и попытаюсь разобраться в них.

> Nuxt.js применяет соглашение, а не стратегию конфигурации. Вам не нужно писать много файлов конфигурации. Вместо этого вы организуете структуру папок так, чтобы Nuxt.js мог ее понять.

### /.следующий/

Каталог **/.nuxt/** также называется каталогом сборки. Он создается динамически, когда вы запускаете приложение локально или когда вы создаете его для производства приложений SSR. Он содержит все файлы, необходимые для запуска приложения. Кроме того, он полностью управляется Nuxt.js, и вам не нужно об этом беспокоиться. Просто знайте, что Nuxt.js компилирует файлы приложения и создает эту папку, готовую к развертыванию на вашем хостинге. Например, Nuxt.js создает экземпляр Vue Store, затем находит все компоненты Vue в папке **/pages/** и создает единый маршрут для каждого компонента. Nuxt.js создает файл маршрутизатора и помещает его в папку **/.nuxt/** .

Вы можете прочитать полную документацию для папки **/.nuxt/** здесь: [https://nuxtjs.org/docs/2.x/directory-structure/nuxt](https://nuxtjs.org/docs/2.x/directory-structure/nuxt) .

### /ресурсы/

Папка **/assets/** используется для хранения ресурсов вашего проекта, таких как изображения, шрифты, файлы Less, файлы Stylus или файлы Sass, которые должны быть скомпилированы Webpack при создании приложения. Если у вас есть какой-либо ресурс, который вы хотите скомпилировать, поместите его в эту папку.

Предположим, вы сохранили изображение логотипа в этой папке с именем logo.svg. Как вы ссылаетесь на него внутри компонента Vue? Вот как это сделать:

`<template> <img src="~/assets/logo.svg" /> </template>`

Вы можете использовать один и тот же метод ссылки на ресурсы внутри папки **/assets/** независимо от того, находитесь ли вы внутри компонента Vue или любого файла CSS.

Вы можете прочитать полную документацию для папки **/assets/** здесь: [https://nuxtjs.org/docs/2.x/directory-structure/assets](https://nuxtjs.org/docs/2.x/directory-structure/assets) .

### /компоненты/

При создании приложения Vue вы обычно разбиваете приложение на представления/страницы и компоненты. Представления или страницы — это основной пользовательский интерфейс, к которому пользователь будет получать доступ через URL-адрес в браузерах. Представления или страницы состоят из более мелких единиц, называемых компонентами. Они являются строительными блоками любого приложения. Вы продвигаете концепции повторного использования и DRY ( [https://en.wikipedia.org/wiki/Don%27t_repeat_yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) ) при использовании компонентов в своем приложении.

В приложении Nuxt.js вы храните все свои компоненты в папке **/components/** . Позже вы узнаете о папке **/pages/** , в которой также могут храниться компоненты Vue. Вот краткое сравнение двух папок:

-   Nuxt.js создает маршруты для компонентов, хранящихся в папке **/pages/** . Тогда они будут напрямую доступны для навигации. Компоненты Vue, хранящиеся в папке **/pages/** , состоят из компонентов, хранящихся в папке **/components/** .
-   Компоненты Vue, хранящиеся в папке **/pages/** , могут использовать `asyncData()`хук для извлечения данных и запускаться в обеих средах: на стороне сервера и на стороне клиента. Компоненты, хранящиеся в папке **/components/,** не могут использовать этот хук. Вы узнаете больше об этом крючке позже.
-   Оба компонента, хранящиеся в папках **/pages/** и **/components/** , могут использовать `fetch()`ловушку для загрузки данных со стороны сервера. Через минуту вы узнаете больше об этом крючке.

Nuxt.js 2.13+ может сканировать и автоматически импортировать все ваши компоненты, не регистрируя их вручную.

Чтобы определить новый компонент в папке **/components/** , просто создайте новый компонент Vue. Здесь нет ничего особенного.

Вы можете прочитать полную документацию для папки **/components/** здесь: [https://nuxtjs.org/docs/2.x/directory-structure/components](https://nuxtjs.org/docs/2.x/directory-structure/components) .

### /макеты/

Папка **/layouts/** содержит макеты приложения. Макет определяет общий внешний вид вашего приложения. У вас может быть одна или несколько страниц макета, в зависимости от требований вашего приложения.

По умолчанию CLI формирует один компонент макета с именем **/layouts/default.vue** . Этот макет по умолчанию всегда используется для страниц, которые не определяют определенный или настраиваемый макет.

Вы можете не только создавать собственные макеты, но и изменять компонент макета по умолчанию в соответствии с вашими потребностями.

Это файл макета по умолчанию, сгенерированный Nuxt.js:

`// layouts/default.vue <template>       <nuxt /> </template>`

Компонент макета — это просто компонент Vue. Обратите внимание на использование компонента `<nuxt />`в разделе шаблона макета. Он является частью среды Nuxt.js и находится внутри файла `/.nuxt/components/nuxt.js`. Что происходит во время выполнения, так это то, что `<nuxt />`компонент заменяется текущей страницей Nuxt.js.

Следовательно, чтобы включить ссылки на различные страницы, доступные в вашем приложении, вы можете указать их, как показано в **листинге 1** .

#### 

Листинг 1: Компонент макета Default.vue

```js
// layouts/default.vue
<template>
    <header> 
    <nuxt-link to="/">Home</nuxt-link> 
    <nuxt-link to="/about">About us</nuxt-link> 
    <nuxt-link to="/contact">Contact us</nuxt-link>
    </header>  
    <nuxt />
</template>
```

Думайте о `<nuxt />`компоненте как о `<router-view />`компоненте в Vue.js. Страница, на которую вы переходите, будет отображаться вместо компонента `<nuxt />`.

Если у вас есть пользовательский файл макета, вы можете настроить страницу для использования этого пользовательского макета следующим образом:

`// pages/about.vue       export default {layout: 'about'}`

Вы можете прочитать полную документацию по макетам Nuxt.js здесь: [https://nuxtjs.org/docs/2.x/directory-structure/layouts](https://nuxtjs.org/docs/2.x/directory-structure/layouts) .

Точно так же этот `<nuxt-link />`компонент также предоставляется фреймворком Nuxt.js. Он напоминает традиционный `<router-link />`компонент Vue.js, но с некоторыми дополнительными преимуществами. Компонент `<nuxt-link />`следует использовать везде, где вы хотите иметь внутренние ссылки в своем приложении.

Компонент `<nuxt-link />`предлагает интеллектуальную предварительную выборку из коробки. Nuxt.js определяет, когда ссылка типа `<nuxt-link />`видна либо в области просмотра, либо при прокрутке, и выполняет предварительную выборку JavaScript для этих страниц, чтобы они были готовы, когда пользователь щелкает ссылку. Nuxt.js достаточно умен, чтобы загружать ресурсы, когда браузер не занят.

Вы можете отключить предварительную выборку для `<nuxt-link />`компонента следующим образом:

`<nuxt-link to="/about" no-prefetch>     About us </nuxt-link>`

Полную документацию по `<nuxt-link />`компоненту читайте здесь: [https://nuxtjs.org/docs/2.x/features/nuxt-components#the-nuxtlink-component](https://nuxtjs.org/docs/2.x/features/nuxt-components#the-nuxtlink-component) .

### /промежуточное ПО/

Папка **/middleware/** содержит все настраиваемое промежуточное ПО, которое вы определяете в своем приложении. Промежуточное ПО Nuxt.js — это функция JavaScript, которая запускается перед рендерингом страницы или группы страниц. Это означает, что промежуточное ПО работает на уровне страницы или макета.

В приложении SSR промежуточное ПО запускается один раз на стороне сервера, а затем после каждой навигации по странице оно запускается один раз на стороне клиента.

Например, вы хотите написать промежуточное ПО для извлечения `user-agent`и сохранения его в `Nuxt.js Context`, вот как это сделать:

`// middleware/userAgent.js       export default function (context) {       context.userAgent = process.server       ? context.req.headers['user-agent'] : navigator.userAgent }`

Nuxt.js предоставляет три логических значения в глобальном `process`объекте, которые помогут вам определить, было ли ваше приложение отрисовано на сервере или полностью на клиенте, а также проверить создание статического сайта.

Функция `middleware`ожидает объект Nuxt.js `Context`в качестве входного параметра.

Это промежуточное ПО проверяет, запущено ли сейчас приложение на сервере, чтобы получить `user-agent`из заголовков запроса. В противном случае он использует `Navigator API`для получения `user-agent`значения. Наконец, он внедряет в объект `user-agent`Nuxt.js.`Context`

Объект Nuxt.js `Context`доступен в некоторых функциях Nuxt.js и содержит весь контекст приложения. Он дает доступ к другим частям приложения из определенных функций. Вот полная документация по Nuxt.js, `Context`которую вы можете просмотреть и прочитать: [https://nuxtjs.org/docs/2.x/concepts/context-helpers](https://nuxtjs.org/docs/2.x/concepts/context-helpers) .

Возвращаясь к промежуточному ПО в Nuxt.js, что определяет порядок, в котором промежуточное ПО вызывается внутри приложения? Порядок зависит от места, где они настроены и установлены:

-   Внутренний `[nuxt.config.js](http://nuxt.config.js/)`файл. Промежуточное ПО, определенное в основном файле конфигурации Nuxt.js, будет запущено первым. Как правило, это промежуточное ПО выполняется для всех страниц приложения.
-   Совпадающие макеты. Промежуточное ПО указывается в компоненте макета и запускается для каждой страницы, использующей этот макет. Например, вы получаете доступ к странице **/about** . Он использует страницу макета default.vue. При доступе к странице **/about** запускается промежуточное ПО, настроенное на уровне макета.
-   Совпадающие страницы. Промежуточное ПО указывается на самой странице. Это имеет наименьший приоритет для запуска.

Как вы определяете промежуточное ПО внутри `[nuxt.config.js](http://nuxt.config.js/)`файла? Вот как это сделать:

`export default {       router: {           middleware: 'userAgent'       } }`

Промежуточное ПО, определенное внутри, `[nuxt.config.js](http://nuxt.config.js/)`называется промежуточным ПО **маршрутизатора** . Он запускается перед каждым переходом на каждую страницу в приложении.

Как определить промежуточное ПО на макете или странице? Вот как это сделать:

`export default {       middleware: ['userAgent'], }`

Наконец, Nuxt.js позволяет вам писать промежуточное программное обеспечение сервера. Обычно они хранятся в папке **/server-middleware/** . Не путайте его с промежуточным программным обеспечением маршрутизатора. Вы определяете промежуточное программное обеспечение сервера, а затем добавляете его в `serverMiddleware`свойство файла `[nuxt.config.js](http://nuxt.config.js/)`. Nuxt.js запускает его только на стороне сервера и до того, как **vue-server-render** сработает и сгенерирует приложение Vue.

Подумайте о `server-middleware`промежуточном программном обеспечении Node.js, которое вы добавляете в приложение Nuxt.js без необходимости использования внешнего сервера. Nuxt.js внутри создает экземпляр соединения ( [https://github.com/senchalabs/connect](https://github.com/senchalabs/connect) ), в который вы можете добавить свое собственное промежуточное ПО.

С ПО промежуточного слоя для серверов нет предела возможностям. Представьте, что ваш Nuxt.js может отправлять электронные письма, использовать регистратор сервера или создавать Express REST API. Используя промежуточное программное обеспечение сервера, вы можете добиться всего этого, не имея внешнего приложения Node.js и многого другого!

Давайте определим регистратор сервера.

Создайте файл **/server-middleware/logger.js** , как показано в **листинге 2** .

#### 

Листинг 2: ПО промежуточного слоя сервера Logger.js

```js
    // server-middleware/logger.js        
export default function (req, res, next) {  
    // req is the Node.js http request object
    console.log(req.url)

    // res is the Node.js http response object

    // next is a function to call to invoke the next middleware
    // Don't forget to call next at the end if your middleware
    //          is not an endpoint!  
    next()
}
```

Регистратор просто регистрирует для консоли URL-адрес текущего запроса. Внутри промежуточного ПО сервера у вас есть доступ к Node.js `Response`и `Request`объектам.

Следующим шагом является регистрация промежуточного программного обеспечения сервера внутри `[nuxt.config.js](http://nuxt.config.js/)`файла следующим образом:

`// [nuxt.config.js](http://nuxt.config.js/) ... serverMiddleware: ['~/server-middleware/logger'] ...`

Вот пример создания CRUD-приложения с использованием Nuxt.js и Express [https://aslamdoctor.com/blog/simple-crud-app-using-express-nuxtjs-using-servermiddleware-part-1-2/239](https://aslamdoctor.com/blog/simple-crud-app-using-express-nuxtjs-using-servermiddleware-part-1-2/239) .

### /страницы/

Папка **/pages/** содержит компоненты Vue.js. Nuxt.js создает новый маршрут для каждого компонента Vue.js, помещенного в эту папку.

Например, предположим, что вы определяете следующие компоненты Vue.js:

`/pages/about.vue /pages/contact.vue`

Nuxt.js создает для вас следующие маршруты:

`http://localhost:3000/about  http://localhost:3000/contact`

Пока мы находимся внутри папки **/pages/** , давайте более подробно изучим маршрутизацию в приложении Nuxt.js.

Как Nuxt.js обрабатывает основные маршруты? Допустим, у вас есть следующая структура внутри папки **/pages/** :

`pages/ --| users/ -----| index.vue -----| foo-bar.vue --| index.vue`

Вы определяете папку с именем `users`. Внутри папки вы добавляете два компонента Vue.js: `index`и `foo-bar`.

Соответственно, Nuxt.js добавляет маршруты, показанные в **листинге 3** .

#### 

Листинг 3: Автогенерация маршрутизатора

```js
router: {  
    routes: [{
        name: 'index', 
        path: '/', 
        component: 'pages/index.vue'  
    },{ 
        name: 'users',  
        path: '/users',
        component: 'pages/users/index.vue' 
    },{
        name: 'users-foo-bar',   
        path: '/users/foo-bar',  
        component: 'pages/users/foo-bar.vue'
    }]
}
```

Как Nuxt.js обрабатывает динамические маршруты? Допустим, у вас есть следующая структура внутри папки **/pages/** :

`pages/ --| _slug/ -----| index.vue --| users/ -----| _id.vue --| index.vue`

Соответственно, Nuxt.js добавляет маршруты, показанные в **листинге 4** .

#### 

Листинг 4: Динамические маршруты автоматического создания маршрутизатора

```js
router: {  
    routes: [{
        name: 'index',
        path: '/',    
        component: 'pages/index.vue'  
    },{ 
        name: 'users-id',  
        path: '/users/:id?',
        component: 'pages/users/_id.vue'  
    },{ 
        name: 'slug',    
        path: '/:slug',  
        component: 'pages/_slug/index.vue'  
    }]
}
```

Динамические маршруты генерируются Nuxt.js при использовании символов подчеркивания.

Как Nuxt.js обрабатывает вложенные маршруты? Допустим, у вас есть следующая структура внутри папки /pages/:

`pages/ --| users/ -----| _id.vue -----| index.vue --| users.vue`

Соответственно, Nuxt.js добавляет маршруты, показанные в **листинге 5** .

#### 

Листинг 5: Вложенные маршруты автоматической генерации маршрутизатора

```js
router: { 
    routes: [{   
        path: '/users',component: 'pages/users.vue',
        children: [{       
            path: '',       
            component: 'pages/users/index.vue',       
            name: 'users'      
           },{
            path: ':id',
            component: 'pages/users/_id.vue', 
            name: 'users-id'
            }
        ]
    }]
}
```

Чтобы иметь вложенные маршруты (дочерние), вы даете одно и то же имя компоненту Vue.js и папке. Начните с создания компонента **/pages/users.vue** следующим образом:

`// pages/users.vue <template>       <div>         <h1>Users</h1>          <nuxt-child/>      </div> </template>`

Nuxt.js предоставляет `<nuxt-child />`компонент. Он играет роль маркера, сообщающего Nuxt.js, где отображать дочерний компонент. В этом случае, когда пользователь посещает маршрут **/users , компонент** **/pages/users/index.vue** отображается вместо `<nuxt-child />`компонента. С другой стороны, когда пользователь посещает маршрут **/users/1 , компонент** **/pages/users/_id.vue** отображается вместо `<nuxt-child />`компонента.

Сразу после этого создайте компонент **/pages/users/index.vue** , как показано в **листинге 6** .

#### 

Листинг 6: Компонент /pages/users/index.vue

```js
// pages/users/index.vue
<template>
    <ul> 
    <li v-for="user in users" v-bind:key="user.id">
        <nuxt-link :to="`users/${user.id}`">
                {{ user.name }} 
        </nuxt-link>  
    </li>
    </ul>
</template>

<script>
import axios from 'axios'

export default {  
    async asyncData () {  
        let { data } = await
        axios.get('https://jsonplaceholder.typicode.com/users')
    return { users: data }  
    }
}
</script>
```

Компонент в **листинге 6** использует `asyncData()`хук для отправки GET-запроса в какой-то поддельный REST API, получая список пользователей. Наконец, он отображает каждого пользователя по имени, используя `<nuxt-link />`компонент, чтобы позволить пользователям переходить в один пользовательский компонент.

Наконец, давайте создадим компонент, который отображает одного пользователя. **В листинге 7** показан код этого компонента. Компонент **/pages/users/_id.vue** , показанный в **листинге 7** , снова взаимодействует с удаленным поддельным REST API для получения сведений о пользователе.

#### 

Листинг 7: Компонент /pages/users/_id.vue

```js
// pages/users/_id.vue
<template> 
    <div v-if="user">
    <h2>{{ user.name }}</h2>  
    <nuxt-link class="button" to="/users">  
        Users 
    </nuxt-link>
    </div>
</template>

<script>
import axios from 'axios'

export default { 
    async asyncData ({ params }) {
        let { data } = await
            axios.get('https://jsonplaceholder.typicode.com/users/' + params.id) 
        return { user: data }  
    }
}
</script>
```

Этот компонент использует `params`объект для получения доступа к параметрам маршрута. Nuxt.js позволяет вам проверять параметры, переданные компоненту, используя `validate()`следующий метод:

`// pages/users/_id.vue       export default {     validate ({ params }) {      return /^\d+$/.test(params.id)     } }`

Здесь вы убедитесь, что `params.id`параметр маршрута является целым числом и ничем другим.

Проверка всегда должна возвращаться `true`, чтобы двигаться вперед. Nuxt.js останавливает маршрут и немедленно выдает страницу с ошибкой 404, если получает `false`логическое значение.

Вы можете прочитать полную документацию в папке /pages/ здесь: [https://nuxtjs.org/docs/2.x/directory-structure/pages](https://nuxtjs.org/docs/2.x/directory-structure/pages) .

### /плагины/

Папка **/plugins/** содержит все подключаемые файлы JavaScript вашего приложения. Nuxt.js запускает ваши плагины до создания корневого экземпляра Vue.

Давайте вместе вспомним, что такое плагины Vue.js. Плагины Vue.js — это глобальные функции JavaScript, инкапсулированные в файлы .js, которые можно установить в ваше приложение с помощью глобальной `Vue.use()`функции.

И Vue.js, и Nuxt.js используют одну и ту же концепцию плагинов. Они оба служат одной и той же цели. В Nuxt.js вы создаете свой плагин, импортируете его в `[nuxt.config.js](http://nuxt.config.js/)`файл, и Nuxt.js запускает этот плагин до создания корневого экземпляра Vue.

Как создать плагин Nuxt.js с нуля? Вы создаете подключаемый модуль Nuxt.js и внедряете его в любой из следующих режимов работы подключаемого модуля Nuxt.js: на стороне клиента, на стороне сервера, в смешанном режиме как на стороне сервера, так и на стороне клиента.

**Экземпляр Vue.js (на стороне клиента)**

`// plugins/<function-name>.js   import Vue from 'vue' Vue.prototype.$<function-name> = () => {       //... }`

**Контекст Nuxt.js (на стороне сервера)**

`// plugins/<function-name>.js export default (context, inject) => {       context.app.$<function-name> = () => {         //...     } }`

**И экземпляр Vue.js, и контекст Nuxt.js (на стороне сервера и на стороне клиента)**

`// plugins/<function-name>.js       export default (context, inject) => {       inject('<function-name>', () => {         //...     }) }`

Давайте создадим подключаемый модуль Nuxt.js для создания одного экземпляра Axios в вашем приложении с определенным базовым URL-адресом. Плагин доступен в контексте Nuxt.js как на стороне сервера, так и на стороне клиента. **В листинге 8** показан код этого подключаемого модуля.

#### 

Листинг 8: Базовый подключаемый модуль

```
// plugins/axios-typicode.js
import axios from 'axios'

const instance = axios.create({baseURL: 'https://jsonplaceholder.typicode.com'})

export default (context, inject) => {inject('axiosTypicode', instance)}
```

Затем вы можете зарегистрировать этот плагин внутри `[nuxt.config.js](http://nuxt.config.js/)`файла следующим образом:

`export default {     plugins: ['~/plugins/axios-typicode.js'] }`

**В листинге 9** показано, как вы можете использовать этот экземпляр Axios на любой странице, вызвав `$axiosTypeicode`.

#### 

Листинг 9: Использование базового подключаемого модуля

```js
export default { 
    mounted() {  
        // on the client-side
        $axiosTypicode.get('/users').then((data) => console.log(data));  
    },

    asyncData({ app, $axiosTypicode }) {    
        // both on the client and server side 
        let { data } = await $axiosTypicode.get('/users');  
    },
}
```

Давайте посмотрим, как вы можете использовать `v-tooltip`плагин Vue.js внутри приложения Nuxt.js.

Начните с установки плагина, выполнив эту команду:

`npm install --save v-tooltip`

Создайте новый файл **/plugins/v-tooltip.js** и вставьте это содержимое:

`// plugins/v-tooltip.js import Vue from 'vue' import VTooltip from 'v-tooltip' Vue.use(VTooltip)`

Затем подключите плагин внутри `[nuxt.config.js](http://nuxt.config.js/)`файла:

`// [nuxt.config.js](http://nuxt.config.js/):       export default {     plugins: ['~/plugins/v-tooltip] }`

Поскольку вы хотите запускать этот подключаемый модуль только на стороне клиента, где вы будете использовать этот подключаемый модуль всплывающей подсказки, добавьте его следующим образом `[nuxt.config.js](http://nuxt.config.js/)`:

`// [nuxt.config.js](http://nuxt.config.js/)   export default {     plugins: [         { src: '~/plugins/v-tooltip, mode: 'client' }     ] }`

Регистрация плагина теперь имеет только режим клиента.

Прежде чем закрыть обсуждение плагинов Nuxt.js, вот ссылка на очень выразительную и содержательную диаграмму плагинов команды Nuxt.js, которую вы всегда можете использовать в качестве справочного материала при создании плагинов. Вы можете получить доступ к изображению здесь: [https://d33wubrfki0l68.cloudfront.net/30bec410ab88bd5ca84fb1a07ed576479a5d2420/cbbe5/docs/2.x/plugins.svg](https://d33wubrfki0l68.cloudfront.net/30bec410ab88bd5ca84fb1a07ed576479a5d2420/cbbe5/docs/2.x/plugins.svg) .

Вы можете прочитать полную документацию по папке /plugins/ и узнать, как создавать плагины, здесь: [https://nuxtjs.org/docs/2.x/directory-structure/plugins](https://nuxtjs.org/docs/2.x/directory-structure/plugins) .

### /статический/

Папка **/static/** используется для хранения всех статических ресурсов, которые вы не хотите компилировать с помощью Webpack, таких как файлы favicon или файлы любого другого типа. Все файлы в этой папке сопоставляются с сервером напрямую, поэтому они доступны напрямую по корневому URL-адресу. Например, /static/logo.png отображается как /logo.png, поэтому вы можете получить к нему доступ следующим образом:

`http://localhost:3000/logo.png`

Вы можете прочитать полную документацию по папке **/static/** здесь: [https://nuxtjs.org/docs/2.x/directory-structure/statics](https://nuxtjs.org/docs/2.x/directory-structure/static) .

### /магазин/

Папка **/store/** содержит файлы хранилища Vuex ( [https://vuex.vuejs.org/](https://vuex.vuejs.org/) ). В Nuxt.js по умолчанию установлен Vuex, поэтому вам не нужно беспокоиться об установке его самостоятельно. По умолчанию Vuex отключен, и чтобы включить его, вы создаете пустой файл /store/index.js.

Чтобы создать корень хранилища, вам нужно передать код из **листинга 10** в файл **/store/index.js** .

#### 

Листинг 10: Настройка Vuex Store

```js
// store/index.js:       
export const state = () => ({state1: null})

export const mutations = { 
    mutation1 (state) { /* code here */ }
}

export const getters = {  
    getter1 (state, getter) { /* code here */ }
}

export const actions = {  
    action1 ({ state, commit }) { /* code here */ }
}
```

В отличие от приложений Vue.js, в Nuxt.js пространство имен включено для всех модулей Vuex. Подробнее о модулях Vuex и пространствах имен можно прочитать здесь: [https://vuex.vuejs.org/guide/modules.html](https://vuex.vuejs.org/guide/modules.html) . Это способствует написанию модульных файлов хранилища Vuex в вашем приложении Nuxt.js.

Вы можете прочитать полную документацию по папке **/store/** здесь: [https://nuxtjs.org/docs/2.x/directory-structure/store](https://nuxtjs.org/docs/2.x/directory-structure/store) .

## Концепции и функции Nuxt.js

В этом разделе я рассмотрю некоторые функции и концепции, которые немного сложнее, потому что, скорее всего, вы столкнетесь с ними при создании приложений с помощью Nuxt.js.

### Получение данных

Все, чему вы научились во Vue.js и использовали для асинхронной загрузки данных внутри компонентов Vue.js, по-прежнему применимо для приложений Nuxt.js. Однако новшеством в этом отношении является функция рендеринга на стороне сервера в универсальных приложениях. Поэтому при создании SSR вам необходимо использовать специфичные для Nuxt.js хуки, которые позволяют Nuxt.js отображать данные на стороне сервера.

Таких крючков два:

-   хук asyncData()
-   хук fetch()

Давайте рассмотрим каждый из этих хуков более подробно.

Вы можете прочитать полную документацию по выборке данных в Nuxt.js здесь: [https://nuxtjs.org/docs/2.x/features/data-fetching](https://nuxtjs.org/docs/2.x/features/data-fetching) .

### хук asyncData()

Хук `asyncData()`доступен только для компонентов Vue.js, определенных в папке **/pages** . Nuxt.js запускает этот хук перед созданием компонента Vue.js. У вас нет доступа к этому объекту внутри этого хука. Это одна из немногих функций в Nuxt.js, которая получает Nuxt.js `Context`в качестве входного параметра.

Хук запускается на стороне сервера один раз и при каждой навигации на стороне клиента. Nuxt.js перенаправляет пользователя на страницу ошибки приложения в случае, если этот хук не выполняется ни на стороне сервера, ни на стороне клиента. Кроме того, этот хук блокирует навигацию, пока не будет разрешен.

Что уникально в этом хуке, так это то, что Nuxt.js объединяет его значение результата с локальным состоянием вашего компонента, которое является свойством `data`компонента. Обычно результат хука имеет приоритет над тем, что определено локально в компоненте и имеет то же имя ключа.

**В листинге 11** показан пример использования `asyncData()`хука.

#### 

Листинг 11: пример хука asyncData()

```js
<template>
    <div>
    <h1>{{ post.title }}</h1> 
    <p>{{ post.description }}</p> 
    </div>
</template>

<script>
    export default {  
        async asyncData({ params, $axios }) { 
            const post = await $axios.$get(`https://api.nuxtjs.dev/posts/${params.id}`)  
        return { post }
        }
    }
</script>
```

Сразу после запуска этого хука локальное состояние компонента теперь содержит свойство, называемое post.

Вы можете прочитать полную документацию по `asyncData()`хуку здесь: [https://nuxtjs.org/docs/2.x/features/data-fetching#async-data](https://nuxtjs.org/docs/2.x/features/data-fetching#async-data) .

### ловушка fetch()

Этот `fetch()`хук был недавно представлен в Nuxt.js 2.12. Nuxt.js вызывает этот хук во время рендеринга на стороне сервера после создания экземпляра компонента и до его рендеринга, а также на стороне клиента после монтирования компонента при переходе между страницами. Он должен возвращать обещание прямо или косвенно (через async/await).

Этот хук имеет более богатый API, чем `asyncData()`хук. Он предоставляет набор свойств, которые пригодятся при создании компонентов и управлении состояниями загрузки или ошибок. Он предоставляет `$fetchState`на уровне компонента следующие свойства:

-   **pending** — это логическая переменная, которая находится в истинном состоянии, пока работает хук. Вы можете использовать его для отображения заполнителя, чтобы сигнализировать пользователям о наличии текущего запроса к серверной части, который еще не разрешен.
-   **error** — это смешанная переменная, которая может содержать либо значение null, либо объект Error, выброшенный хуком `fetch()`. Вы можете использовать эту переменную для отображения значимого сообщения об ошибке для пользователя.
-   **timestamp** — это переменная, которая содержит метку времени последнего `fetch()`запроса. Это полезно при работе с кэшированием и функцией поддержания активности. Я не буду освещать эту тему в этой статье, но вы можете узнать больше об этом здесь: [https://nuxtjs.org/docs/2.x/features/data-fetching#caching](https://nuxtjs.org/docs/2.x/features/data-fetching#caching) .

**В листинге 12** показан пример использования `fetch()`хука:

#### 

Листинг 12: пример хука fetch()

```js
<template>  
    <p v-if="$fetchState.pending">Fetching mountains...  </p>
    <p v-else-if="$fetchState.error">An error occurred :( </p>  
    <div v-else>
        <h1>Nuxt.js Mountains</h1>  
        <ul>
            <li v-for="mountain of mountains"> {{ mountain.title }} </li>
        </ul> 
        <button @click="$fetch">Refresh</button>
    </div>
</template>

<script>
    export default {  
        data() {return {mountains: []} },
        async fetch() {
            this.mountains = await fetch(
                'https://api.nuxtjs.dev/mountains').then(res => res.json()) 
        }
    }
</script>
```

Обратите внимание, как `fetch()`хук имеет доступ к этому объекту. По сути, это установка значения гор, которое локально определяется по локальному состоянию компонента.

Кроме того, вы можете отправлять действия или фиксировать мутации в хранилище Vuex изнутри этого хука.

Еще следует отметить обработчик события нажатия кнопки. Просто звонит `$fetch`. Это ссылка на `fetch()`хук, который Nuxt.js внедряет в компоненты, чтобы вы могли вручную вызывать `fetch()`хук, когда это необходимо.

Вы можете прочитать полную документацию по `fetch()`хуку здесь: [https://nuxtjs.org/docs/2.x/features/data-fetching#the-fetch-hook](https://nuxtjs.org/docs/2.x/features/data-fetching#the-fetch-hook) .

### Страница ошибки

Nuxt.js включает компонент **/.nuxt/components/nuxt-error.vue** . Он отображает этот компонент всякий раз, когда в приложении возникает ошибка (404, 500 и т. д.). Nuxt.js дает вам возможность настроить эту страницу ошибки в соответствии с вашими потребностями и требованиями. Давайте создадим вашу собственную пользовательскую страницу ошибок.

Начните с создания новой страницы макетов, добавив новый компонент Vue.js в **/layouts/error.vue** и вставив содержимое компонента Vue.js, показанное в **листинге 13** .

#### 

Листинг 13: Компонент Error.vue

```js
// layouts/error.vue
<template>  
    <div>    
        <h2 v-if="error.statusCode === 404"> Page not found </h2>
        <h2 v-else>An error occurred</h2>    
        <nuxt-link to="/">Home page</nuxt-link> 
    </div>
</template>

<script>
    export default {props: ['error']}
</script>
```

Вот и все! Nuxt.js использует этот компонент в следующий раз, когда ему нужно отобразить страницу ошибки. Важно отметить, что этот `error.vue`компонент является обычным компонентом Vue.js, а не компонентом макетов. Однако Nuxt.js решил поместить эту пользовательскую страницу ошибки в папку **/layouts/** .

Вы можете прочитать полную документацию по страницам ошибок здесь: [https://nuxtjs.org/docs/2.x/directory-structure/layouts#error-page](https://nuxtjs.org/docs/2.x/directory-structure/layouts#error-page) .

### Файл конфигурации Nuxt.js

Файл `[nuxt.config.js](http://nuxt.config.js/)`существует, чтобы содержать всю вашу пользовательскую конфигурацию. Nuxt.js поставляется с набором конфигураций, и этот файл поможет вам изменить существующие конфигурации и добавить новые. Например, вы можете изменить метатеги, заголовок и ссылки для тега Head главной страницы. Как вы видели ранее, вы также используете этот файл конфигурации для перечисления ваших подключаемых модулей, промежуточного программного обеспечения и других связанных конфигураций, которые непосредственно влияют на ваше приложение.

Давайте отредактируем метатеги главной страницы, заголовок и добавим ссылку на фавикон. **В листинге 14** показан весь блок.

#### 

Листинг 14. Свойство Page Head

```js
export default {  
    head: {  
        title: 'My First Nuxt.js app!',
        meta: [  
            { charset: 'utf-8' },
            { name: 'viewport', content: 'width=device-width, initial-scale=1' },
            { hid: 'description', name: 'description', content: 'My first attempt to learn Nuxt.js!'}
        ],
        link: [    
            { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
        ] 
    }
}
```

Файл `[nuxt.config.js](http://nuxt.config.js/)`имеет свойство Head. Это свойство представляет заголовок HTML страницы в Nuxt.js. Он может содержать любые элементы HTML Head и метатеги. Свойство `head`применяется ко всем страницам в приложении Nuxt.js. Однако вы все еще можете переопределить их на уровне страницы, как вы скоро увидите.

Свойство `head.meta`имеет тип массива объектов. Каждый объект представляет отдельный элемент или метатег. Обратите внимание на пользователя `hid`свойства в одном из объектов внутри `meta`свойства.

`{        hid: 'description',        name: 'description',        content: 'My first attempt to learn Nuxt.js!'  }`

Это очень важно иметь на этом уровне внутри `[nuxt.config.js](http://nuxt.config.js/)`файла. Позже вы увидите, как можно переопределить описание метатега изнутри самой страницы Nuxt.js. Использование этого свойства позволяет переопределить это описание на уровне страницы. В противном случае у вас будет два повторяющихся элемента метатега описания на сгенерированной HTML-странице.

Другой конфигурацией, которую вы можете установить в `[nuxt.config.js](http://nuxt.config.js/)`файле, является `CSS`свойство. Это очень удобно, особенно когда вы начинаете свой путь с Nuxt.js.

`export default {       css: [            '~/assets/css/main.css',              '~/assets/css/animations.scss'      ] }`

Свойство `CSS`представляет собой массив путей к файлам CSS. Файлы, которые вы указываете на этом уровне, глобально включаются на все страницы вашего приложения.

Есть много других параметров конфигурации, которые вы можете добавить в `[nuxt.config.js](http://nuxt.config.js/)`файл. Вы можете прочитать полную документацию в `[nuxt.config.js](http://nuxt.config.js/)`файле здесь: [https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config](https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config) .

### Модули

Когда вы формируете новое приложение Nuxt.js с помощью CLI, оно не создает для вас папку **/modules/ .** Скорее всего, потому что создание модулей в Nuxt.js считается продвинутым шагом и редко используется без необходимости.

Модуль, определенный в Nuxt.js, — это функция JavaScript верхнего уровня, которая выполняется при запуске Nuxt.js. Nuxt.js вызывает каждый модуль по порядку и ждет завершения выполнения всех модулей, прежде чем продолжить вызов экземпляра Vue, подключаемых модулей Vue и создания контекста.

Зачем вам модули? С помощью модулей вы можете переопределять шаблоны, настраивать загрузчики Webpack, добавлять библиотеки CSS, программно добавлять подключаемые модули и выполнять другие задачи, необходимые для вашего приложения.

Модуль Nuxt.js — это единица упаковки, предлагаемая Nuxt.js. Скажем, например, у вас есть подключаемый модуль, которым вы хотите поделиться в виде пакета NPM. Вы создаете новый модуль, который загружает и внедряет плагин в приложение Nuxt.js. Затем вы создаете пакет NPM для этого модуля и делитесь им с сообществом Nuxt.js.

Как написать базовый модуль? Давайте создадим простой модуль, который получает доступ к некоторой конфигурации, сохраненной внутри, `[nuxt.config.js](http://nuxt.config.js/)`и записывает данные на экран.

Создайте новый файл в **/modules/basicModule.js** со следующим содержимым:

`// modules/basicModule.js       export default function (moduleOptions) {       console.log(moduleOptions)       console.log(this.options['basic']) }`

Внутри `[nuxt.config.js](http://nuxt.config.js/)`файла зарегистрируйте этот новый модуль следующим образом:

`// [nuxt.config.js](http://nuxt.config.js/)      export default {       modules: [          ['~/modules/basicModule', {}         /* module options */],       ] }`

Затем добавьте в `[nuxt.config.js](http://nuxt.config.js/)`раздел новой конфигурации следующее:

`// [nuxt.config.js](http://nuxt.config.js/)    export default {     basic: { // custom configuration options             option1: false,          option2: true,     } }`

Это действительно так! Когда приложение запускается, модуль регистрирует содержимое свойства `basic`, как показано на **рис. 8** .

![Рисунок 8: Запуск модуля](https://codemag.com/Article/Image/2105101/figure8.png)  
**Рисунок 8:** Запуск модуля

Внутри модуля это относится к экземпляру ModuleContainer ( [https://nuxtjs.org/docs/2.x/internals-glossary/internals-module-container](https://nuxtjs.org/docs/2.x/internals-glossary/internals-module-container) ).

Чтобы получить доступ к `[nuxt.config.js](http://nuxt.config.js/)`содержимому файла внутри модуля, вы используете `this.options()`функцию. В этом случае модуль обращается к `basic`свойству. Модуль остается простым, и идея состоит в том, чтобы показать, как построить каркас модуля и успешно его запустить.

Давайте рассмотрим более продвинутый модуль. Этот подключаемый модуль считывает данные конфигурации из `[nuxt.config.js](http://nuxt.config.js/)`файла, настраивает подключаемый модуль на основе данных конфигурации и, наконец, программно регистрирует подключаемый модуль.

Создайте новый файл **/modules/advancedModule.js** и вставьте в него содержимое **листинга 15** .

#### 

Листинг 15: Расширенный подключаемый модуль

```js
//modules/advancedModule.js       
const { resolve } = require('path')

export default function (moduleOptions) {
    // Add plugin. 
    this.addPlugin({ 
        src: resolve(__dirname, 'plugin.js'), 
        fileName: 'basicConfig.js', 
        this.options['basic']
    })
}
```

Модуль начинается с вызова `this.addPlugin()`функции, определенной в `ModuleContainer`классе. Эта функция принимает файл шаблона плагина в качестве первого параметра. Второй параметр указывает имя создаваемого подключаемого модуля. И, наконец, третий параметр для любых опций, которые вы хотите передать этому шаблону плагина.

Создайте новый файл шаблона подключаемого модуля **/modules/plugin.js** с содержимым, показанным в **листинге 16** .

#### 

Листинг 16: Файл шаблона плагина Lodash

```js
var options = []

<% if (options.option1 === true) { %> options.push('option 1') <% } %>

<% if (options.option2 === true) { %> options.push('option 2') <% } %>

const basicConfig = function () {return options}

export default ({ app }, inject) => {inject(basicConfig, basicConfig)}
```

В шаблоне используются шаблоны Lodash ( [http://nicholasjohnson.com/javascript/javascript-for-programmers/exercises/lodash-templates/](http://nicholasjohnson.com/javascript/javascript-for-programmers/exercises/lodash-templates/) ).

Внутри файла шаблона на основе параметров, переданных через `addPlugin()`функцию, вы можете вставлять новые элементы в локально определенную переменную массива параметров.

Затем определите `basicConfig()`функцию с телом функции, которое возвращает локальную переменную массива опций. Наконец, определите функцию подключаемого модуля, которая, в свою очередь, внедряет функцию `basicConfig()`как в серверные, так и в клиентские каналы приложения Nuxt.js. Функция `addPlugin()`внутри создает новый файл подключаемого модуля на основе указанного шаблона и помещает подключаемый модуль в контекст Nuxt.js.

Давайте включим файл модуля в `[nuxt.config.js](http://nuxt.config.js/)`файл, а также раздел базовой конфигурации. **В листинге 17** показан весь исходный код.

#### 

Листинг 17. Регистрация расширенного модуля

```js
// nuxt.config.js        
export default { 
   modules: [
       ['~/modules/advancedModule', { /* module options */ }  ],
   ],
   basic: { option1: false, option2: true, }
}
```

Запустите приложение и перейдите на домашнюю страницу. Вы увидите данные, напечатанные на консоли.

Вы можете создавать более интересные вещи с модулями Nuxt.js. Это был просто пример того, как все работает вместе, чтобы создать функцию в вашем приложении, которой потенциально можно поделиться с остальным сообществом через модуль.

Прежде чем закрыть обсуждение модулей Nuxt.js, вот очень выразительная и содержательная схема модулей Nuxt.js, которую вы всегда можете использовать в качестве справочного материала при создании модулей. Вы можете получить доступ к изображению здесь: [https://nuxtjs.org/docs/2.x/modules.svg](https://nuxtjs.org/docs/2.x/modules.svg) .

### SEO

Возвращаясь к началу статьи, вы узнали, что Nuxt.js оптимизирован для SEO. Это одно из основных преимуществ перед приложениями Vue.js. Для этого создайте приложение SSR с Nuxt.js в сочетании с настраиваемыми метатегами и элементами HTML Head.

Nuxt.js позволяет настраивать заголовок HTML глобально на `[nuxt.config.js](http://nuxt.config.js/)`уровне файла или страницы. Вы уже видели первое и как глобально настроить HTML Head. Теперь давайте посмотрим, как можно настроить метатеги для конкретной страницы.

Откройте компонент **/pages/index.vue** и добавьте `Head`свойство, как показано в **листинге 18** :

#### 

Листинг 18. Свойство заголовка уровня страницы

```js
// pages/index.vue        
export default {  
    head () {
        return {  
            title: 'Hello World!',  
            meta: [  
                {
                    hid: 'description',
                    name: 'description',
                    content: 'My Nuxt portfolio'         
                }
            ]
        }
    }
}
```

Страница меняет заголовок и метатег описания. Обратите внимание на использование этого `hid`свойства, чтобы описание, установленное на этой странице, переопределяло глобальное описание, определенное на `[nuxt.config.js](http://nuxt.config.js/)`уровне файла.

Вот и все!

Вы можете прочитать полную документацию по `Head`свойству здесь: [https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-head](https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-head) .

## Заключение

Фреймворк Nuxt.js молодой и свежий! Команда, стоящая за этой структурой, проделывает большую работу, предлагая богатую и подробную документацию. В этой статье я коснулся поверхности Nuxt.js и дал вам краткое руководство по большинству функций и концепций, необходимых для начала создания приложений с помощью Nuxt.js.

Еще одна интересная тема в Nuxt.js — модуль контента. Это делает приложение Nuxt.js более похожим на Headless CMS! С помощью этого модуля вы можете создавать собственный контент в файлах Markdown, JSON, YAML, XML и CSV. Вы храните свой контент в папке **/content** и используете его внутри компонентов Vue с помощью API, подобного MongoDB.

Кроме того, у Nuxt.js есть активное сообщество, поддерживающее его потрясающими модулями, плагинами и библиотеками. Вам не нужно изобретать велосипед или строить все с нуля!

Вы можете посетить их по адресу:

-   Потрясающие модули Nuxt.js: [https://github.com/nuxt-community/awesome-nuxt#official](https://github.com/nuxt-community/awesome-nuxt#official)
:::
