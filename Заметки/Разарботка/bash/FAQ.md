## напиши 10 разных способов отправки http пакета в bash

Конечно! Вот 10 разных способов отправки HTTP-запросов в Bash:

1. Используя утилиту curl:

```
curl -X GET http://example.com
```

2. Используя утилиту wget:

```
wget http://example.com
```

3. Используя утилиту httpie:

```
http GET http://example.com
```

4. Используя утилиту netcat:

```
echo -e "GET / HTTP/1.1\nHost: example.com\n\n" | nc example.com 80
```

5. Используя утилиту telnet:

```
telnet example.com 80
GET / HTTP/1.1
Host: example.com
```

6. Используя утилиту socat:

```
echo "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" | socat - TCP4:example.com:80
```

7. Используя утилиту openssl:

```
openssl s_client -quiet -connect example.com:443 <<EOF
GET / HTTP/1.1
Host: example.com

EOF
```

8. Используя утилиту nmap:

```
nmap --script http-methods -p 80 example.com
```

9. Используя утилиту lynx:

```
lynx -dump http://example.com
```

10. Используя утилиту links:

```
links -dump http://example.com
```

## напиши как отправить http пакет через sockets в bash

Конечно, вот пример кода на Bash для отправки HTTP-запроса через сокеты:

```bash
#!/bin/bash

# Устанавливаем переменные
host="example.com"
port=80
request="GET / HTTP/1.1\r\nHost: example.com\r\n\r\n"

# Создаем сокет и отправляем запрос
exec 3<>/dev/tcp/$host/$port
echo -e $request >&3

# Читаем ответ от сервера
while read line; do
  echo $line
done <&3

# Закрываем сокет
exec 3>&-
```

В этом примере мы используем встроенную возможность Bash для работы с сокетами. Сначала мы устанавливаем переменные для хоста, порта и запроса. Затем мы создаем сокет и отправляем запрос на сервер. После этого мы читаем ответ от сервера и закрываем сокет.

Важно отметить, что этот пример отправляет только GET-запросы. Если вам нужно отправить POST-запросы или запросы с другими методами, вам понадобится изменить соответствующую строку запроса.

Также обратите внимание, что этот пример не обрабатывает ошибки и не проверяет ответ сервера на наличие ошибок. Поэтому, если вы используете этот код в своих проектах, обязательно добавьте обработку ошибок и проверку ответа сервера.

## напиши как в bash обрабатываются ошибки

В Bash обработка ошибок может быть выполнена с помощью команды `trap`, которая позволяет определить действия, которые должны быть выполнены при возникновении определенного сигнала или ошибки.

Пример:

```bash
#!/bin/bash

# Обработка ошибок
set -e

# Обработчик ошибок
function error_handler() {
  echo "Произошла ошибка на строке $1"
  exit 1
}

# Установка обработчика ошибок
trap 'error_handler $LINENO' ERR

# Выполнение команд
echo "Начало скрипта"

# Здесь может произойти ошибка
cat /file/that/does/not/exist

echo "Конец скрипта"
```

В этом примере мы используем команду `set -e`, которая заставляет скрипт прерваться, если произошла ошибка. Затем мы определяем функцию `error_handler`, которая будет вызвана в случае ошибки. Мы также используем команду `trap`, чтобы связать обработчик ошибок с событием ошибки.

Если в скрипте произойдет ошибка, обработчик ошибок будет вызван, и скрипт завершится с кодом ошибки 1. В обработчике ошибок мы можем выполнять любые действия, которые необходимы для обработки ошибки, например, отправлять сообщения об ошибке или записывать ошибки в файл.

Это только один из способов обработки ошибок в Bash. Существуют и другие методы, например, использование конструкции `if` для проверки наличия ошибок после выполнения каждой команды.

## напиши примеры перехватов (TERM, KILL и т.д.)в bash

В Bash существует несколько сигналов, которые могут быть перехвачены. Некоторые из них включают в себя:

- `SIGHUP`: сигнал, отправляемый приложению при завершении сеанса SSH.
- `SIGINT`: сигнал, отправляемый приложению при нажатии комбинации клавиш `Ctrl+C`.
- `SIGTERM`: сигнал, отправляемый приложению при вызове команды `kill`.
- `SIGKILL`: сигнал, отправляемый приложению для немедленного завершения.

Вот примеры того, как можно обработать эти сигналы в Bash:

```bash
#!/bin/bash

# Обработка сигнала SIGHUP
trap "echo 'Получен сигнал SIGHUP'" SIGHUP

# Обработка сигнала SIGINT
trap "echo 'Получен сигнал SIGINT'" SIGINT

# Обработка сигнала SIGTERM
trap "echo 'Получен сигнал SIGTERM'" SIGTERM

# Обработка сигнала SIGKILL (невозможно обработать)
trap "echo 'Невозможно обработать сигнал SIGKILL'" SIGKILL

# Бесконечный цикл
while :
do
  sleep 1
done
```

Этот скрипт перехватывает сигналы SIGHUP, SIGINT и SIGTERM, но не может обработать сигнал SIGKILL, так как он немедленно завершает процесс без возможности его обработки.

## Как посчитать количество строк кода php

```bash
$ ( find ./module/ -name '*.php' -print0 | xargs -0 cat ) | wc -l
309127
```

