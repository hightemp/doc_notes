https://www.thecodedmessage.com/posts/oop-2-polymorphism/

2023-02-07 :: Джимми Хартцелл

# [программирование](https://www.thecodedmessage.com/tags/programming/)   # [Rust](https://www.thecodedmessage.com/tags/rust/)   # [ООП](https://www.thecodedmessage.com/tags/oop/)   # [За пределами ООП](https://www.thecodedmessage.com/tags/beyond-oop/)   # [компьютеры](https://www.thecodedmessage.com/tags/computers/) 

В этом посте я продолжаю [серию статей](https://www.thecodedmessage.com/tags/beyond-oop/) о том, чем Rust отличается от традиционной парадигмы объектно-ориентированного программирования, обсуждая второй из трех традиционных столпов ООП: полиморфизм.

Полиморфизм — особенно важная тема в объектно-ориентированном программировании, пожалуй, самый важный из трех его столпов. Можно было бы (и было написано) несколько книг о том, что такое полиморфизм, как его реализовали в различных языках программирования (как в мире ООП, так и за его пределами — да, полиморфизм существует вне ООП), как его эффективно использовать и когда. не использовать его. Можно написать книги о том, как использовать только его версию на Rust.

К сожалению, это всего лишь сообщение в блоге, поэтому я не могу описать полиморфизм настолько подробно и разнообразно, насколько хотелось бы. Вместо этого я сосредоточусь конкретно на том, чем Rust отличается от концепции ООП. Я начну с описания того, как это работает в ООП, а затем расскажу, как достичь тех же целей в Rust.

---

В ООП полиморфизм — это все. Он пытается взять все процессы принятия решений (или как можно больше решений) и объединить их в общий узкий механизм: полиморфизм времени выполнения. Но, к сожалению, это не просто полиморфизм времени выполнения, а специфическая, узкая форма полиморфизма времени выполнения, ограниченная философией ООП и деталями того, как обычно работают реализации:

-   **Это требует косвенности:** каждый объект обычно должен храниться в куче, чтобы работал полиморфизм времени выполнения, поскольку разные «типы времени выполнения» имеют разные размеры. Это поощряет использование псевдонимов изменяемых объектов. Не только это, но и для фактического вызова метода он должен пройти через три уровня косвенности: разыменование ссылки на объект, затем разыменование указателя класса или указателя «vtable», а затем выполнение косвенного вызова функции.
-   **Это исключает оптимизацию:** помимо внутренней стоимости косвенного вызова функции, тот факт, что вызов является косвенным, означает, что встраивание невозможно. Часто полиморфные методы малы или даже тривиальны, например, возвращают константу, устанавливают поле или переупорядочивают параметры и вызывают другой метод, поэтому встраивание было бы полезно. Встраивание также важно, чтобы позволить оптимизации пересекать границу встраивания.
-   **Он полиморфен только по одному параметру:** специальный параметр получателя, называемый `self`или `this`, является единственным параметром, с помощью которого обычно возможен полиморфизм во время выполнения. Полиморфизм по другим параметрам можно моделировать вспомогательными методами в этих типах, что неудобно, а полиморфизм возвращаемого типа невозможен.
-   **Каждое значение независимо полиморфно:** в полиморфизме времени выполнения часто нет способа сказать, что все элементы коллекции относятся к некоторому типу `T`, реализующему один и тот же интерфейс, или сказать, что два параметра функции имеют один и тот же тип. но что это за тип, следует определять во время выполнения.
-   **Он связан с другими функциями ООП:** в C++ полиморфизм времени выполнения тесно связан с наследованием. Во многих языках программирования ООП он доступен только для типов классов, которые, как я уже говорил в [предыдущем посте,](https://www.thecodedmessage.com/posts/oop-1-encapsulation/) представляют собой ограниченную форму модулей.

Я мог бы написать целую запись в блоге о каждом из этих ограничений — возможно, когда-нибудь я это сделаю.

Но, несмотря на все эти ограничения, он считается предпочтительным способом принятия решений в языках ООП, а также особенно интуитивно понятным и доступным. Программистов учат обращаться к этому инструменту всякий раз, когда это возможно, независимо от того, является ли он лучшим инструментом для принятия решения, даже если в настоящее время нет необходимости в том, чтобы он принимал решение во время выполнения. Некоторые языки программирования, такие как Smalltalk, даже сворачивали логику «если-то» и зацикливались на одной странной специфической структуре принятия решений, реализуя их с помощью полиморфных методов, которые по-разному реализовывались бы в классах и (и, следовательно, `ifTrue:ifFalse`в `True`объектах `False`и ) `true`. `false`).

_Чтобы было ясно, наличие механизма полиморфизма среды выполнения на основе vtable само по себе_ неплохо — в Rust он даже есть (похож, но не совсем идентичен ООП-версии, описанной выше). Но версия Rust используется в относительно редких случаях, когда этот механизм лучше всего подходит из всей палитры механизмов. В ООП возвышение этой строго ограниченной и неэффективной формы принятия решений над всеми остальными, а также философское утверждение о том, что ее использование является лучшим и наиболее интуитивным способом выражения потока программы и бизнес-логики, является проблемой.

Оказывается, программирование становится намного более эргономичным, когда вы выбираете инструмент, наиболее подходящий для конкретной ситуации, а полиморфизм времени выполнения ООП лишь изредка оказывается реальным инструментом для работы, которую его часто просят выполнять.

Итак, давайте рассмотрим 4 альтернативы в Rust, которые можно использовать, когда ООП использует полиморфизм во время выполнения.

# Альтернатива №0: `enum`[](https://www.thecodedmessage.com/posts/oop-2-polymorphism/#alternative-0-enum)

Существуют не только другие формы полиморфизма, которые имеют строго меньше ограничений (например, классы типов Haskell) или другой набор компромиссов (например, черты Rust, в значительной степени основанные на классах типов Haskell), но и другие системы принятия решений в Rust и Haskell, а именно алгебраические типы данных (ADT) или типы сумм, которые также берут на себя многие приложения полиморфизма в стиле ООП.

В Rust они известны как `enum`s. `enum`s во многих языках программирования представляют собой списки констант, которые должны храниться в типах целочисленного размера, иногда реализованных безопасным способом (например, в Java), иногда нет (например, в C), иногда с любой доступной опцией (например, в C++ с отличием между `enum`и `enum class`).

Rust `enum`поддерживает этот знакомый вариант использования с безопасностью типов:

```rust
pub enum Visibility {
    Visible,
    Invisible,
}
```

Копировать

Но они также поддерживают дополнительные поля, связанные с каждой опцией, создавая то, что в теории типов известно как «тип суммы», но среди программистов на C или C++ он более известен как «объединение с тегами» — разница в том, что в Rust компилятор знает и применяет тег. Вот несколько примеров некоторых `enum`объявлений:

```rust
pub enum UserId {
    Username(String),
    Anonymous(IpAddress),
    // ^^ This isn't supposed to be a real network type,
    // just an example.
}

let user1 = User::Username("foo".to_string());
let user2 = User::Anonymous(parse_ip("127.0.0.1")?);

pub enum HostIdentifier {
    Dns(DomainName),
    Ipv4Addr(Ipv4Addr),
    Ipv6Addr(Ipv6Addr),
}

pub enum Location {
    Nowhere,
    Address(Address),
    Coordinates {
        lat: f64,
        long: f64,
    }
}

let loc1 = Location::Nowhere;
let loc2 = Location::Coordinates {
    lat: 80.0,
    long: 40.0,
};
```

Копировать

Вы спросите, какое отношение эти объединения с тегами имеют к полиморфизму? Что ж, большинство ООП-языков не имеют хорошего синтаксиса для этих типов сумм, но у них есть мощные механизмы полиморфизма во время выполнения, поэтому вы увидите полиморфизм во время выполнения, используемый в ситуациях, когда Rust на самом деле был бы таким же хорошим `enum`. -suited (и я поспорю, лучше подходит): когда есть несколько вариантов хранения значения, но эти варианты содержат разные детали.

Например, вот один из способов представления `UserId`типа в Java с использованием наследования и полиморфизма во время выполнения — как я бы сделал это, когда был студентом (помещая каждый класс в отдельный файл):

```java
class UserId {
}

class Username extends UserId {
    private String username;
    public Username(String username) {
        this.username = username;
    }

    // ... getters, setters, etc.
}

class AnonymousUser extends UserId {
    private Ipv4Address ipAddress;
    
    // ... constructor, getters, setters, etc.
}

UserId user1 = new Username("foo");
UserId user2 = new AnonymousUser(new Ipv4Address("127.0.0.1"));
```

Копировать

Важно то, что так же, как и в `enum`примере, мы можем помещать `user1` и `user2`в переменные одного типа, и можем передавать их в одни и те же функции, и в целом выполнять над ними одни и те же операции.

Теперь эти классы в стиле ООП выглядят сверхлегкими до глупости, но это в основном потому, что мы не добавили в эту ситуацию никакого реального операционного кода — только данные и структуру, а также немного определений переменных и шаблонов. Давайте посмотрим, что произойдет, если мы действительно сделаем что-нибудь с идентификаторами пользователей.

Например, мы можем захотеть определить, является ли он администратором. Предположим, что в нашей гипотетике анонимные пользователи никогда не являются администраторами, а пользователи с именами пользователей являются администраторами только в том случае, если имя пользователя начинается со строки `admin_`.

Доктринально одобренный объектно-ориентированный способ сделать это — добавить метод, например `isAdministrator`. Чтобы этот метод работал, мы должны добавить его ко всем трем классам, базовому классу и двум дочерним классам:

```java
class UserId {
    // ...
    public abstract bool isAdministrator();
}

class Username extends UserId {
    // ...
    public bool isAdministrator() {
        return username.startsWith("admin_");
    }
}

class AnonymousUser extends UserId {
    // ...
    public bool isAdminstrator() {
        return false;
    }
}
```

Копировать

Итак, чтобы добавить эту простую операцию, эту простую возможность к этому типу в Java, мы должны перейти к трем классам, которые будут храниться в трех файлах. Каждый из них содержит метод, который делает что-то простое, но нигде не видна вся логика того, кто является администратором, а кто нет — что-то, что кто-то, естественно, может спросить.

Rust использовал бы `match`для такой операции, поместив всю информацию о ней в одном месте:

```rust
fn is_administrator(user: &UserId) -> bool {
    match user {
        UserId::Username(name) => name.starts_with("admin_"),
        UserId::AnonymousUser(_) => false,
    }
}
```

Копировать

Это дает более сложную индивидуальную функцию, но в ней явно присутствует вся логика. Явная логика, а не неявная в иерархии наследования, противоречит принципу ООП, согласно которому методы должны быть простыми, а для неявного выражения логики должен использоваться полиморфизм. Но это ничего не гарантирует, просто заметает это под ковер: оказывается, сокрытие сложности делает ее труднее, а не легче.

Давайте рассмотрим еще один пример. У нас был этот `UserId`код некоторое время, и вам поручили написать новый веб-интерфейс для этой системы. Вам нужен какой-то способ отображения информации о пользователе в HTML, либо ссылка на профиль пользователя (в случае именованного пользователя), либо строка с IP-адресом, выделенная красным цветом (в случае анонимного пользователя). Итак, вы решаете добавить новую операцию для этого небольшого семейства типов, `toHTML`которая выводит специализированный тип DOM вашего нового внешнего интерфейса. (Возможно, Java скомпилирована в WebAssembly, я не уверен. Детали не имеют значения.)

Вы отправляете запрос на вытягивание сопровождающему `UserId`иерархии классов глубоко в основной библиотеке серверной части. А потом отвергают.

На самом деле у них есть довольно веские причины, как вы неохотно признаете. Они говорят, что это абсурдное разделение интересов. Кроме того, компания не может использовать эту базовую библиотеку для обработки типов из вашего внешнего интерфейса.

Итак, вы вздыхаете и пишете эквивалент `match`выражения на Rust, но на Java (простите мою нелепую гипотетическую HTML-библиотеку):

```java
Html userIdToHtml(UserId userId) {
    if (userId instanceof Username) {
        Username username = (Username)userId;
        String usernameString = username.getUsername();
        Url url = ProfileHandler.getProfileForUsername(usernameString);
        return Link.createTextLink(url, username.getUsername());
    } else if (userId instanceof AnonymousUser) {
        AnonymousUser anonymousUser = (AnonymousUser)userId;
        return Span.createColoredText(anonymousUser.getIp().formatString(), "red");
    } else {
        throw new RuntimeException("IDK, man");
    }
}
```

Копировать

И этот код ваш босс отвергает при проверке кода, говоря, что вы использовали `instanceof`анти-шаблон, но позже они неохотно принимают его после того, как вы заставляете их спорить с сопровождающим основной библиотеки, который не примет ваш другой патч.

Но посмотрите, какой уродливый этот `instanceof`код! Неудивительно, что Java-программисты считают его антишаблоном! Но в этой ситуации это самое разумное, действительно единственное возможное, кроме реализации шаблона наблюдателя или шаблона посетителя или чего-то еще, что просто равнозначно инфраструктуре для подделки с инверсией управления `instanceof`.

Реализовать операции путем добавления метода к каждому подклассу имеет смысл, когда набор операций ограничен (или близок к нему) и количество подклассов класса может вырасти непредвиденным образом. Но так же часто количество операций будет расти непредвиденным образом, а количество подклассов ограничено (или близко к этому).

Для последней ситуации, которая встречается чаще, чем могут себе представить сторонники ООП, Rust `enum`и типы сумм в целом идеально подходят. Как только вы привыкнете к ним, вы обнаружите, что используете их все время.

Я скажу для протокола, что это не так уж плохо во всех объектно-ориентированных языках программирования. В некоторых случаях вы можете писать произвольные комбинации классов и методов в любом порядке, поэтому при желании вы можете написать все три реализации в одном месте. Smalltalk традиционно позволяет вам перемещаться по кодовой базе в специальном браузере, где вы можете увидеть либо список методов, реализованных классом, либо список классов, которые принимают данное «сообщение», как его называет Smalltalk, так что вы можете получить свой пирог и ешь тоже.

# Альтернатива № 1: [](https://www.thecodedmessage.com/posts/oop-2-polymorphism/#alternative-1-closures)

Иногда ООП-интерфейс или полиморфное решение включают только одну фактическую операцию. В такой ситуации вместо этого можно просто использовать замыкание.

Я не хочу тратить на это слишком много времени, потому что большинство ООП-программистов уже знают об этом с тех пор, как их ООП-языки догнали функциональные языки и получили синтаксис для лямбда-выражений — Java в Java 8, C++ в C. ++11. Таким образом, глупые интерфейсы с одним методом, такие как Java [`Comparator`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html) , к счастью, в основном остались в прошлом.

Кроме того, замыкания в Rust технически включают трейты, поэтому реализуются с использованием того же механизма, что и следующие две альтернативы, так что можно также утверждать, что на самом деле это не отдельная опция в Rust. Однако, на мой взгляд, лямбда-выражения, замыкания и трейты `FnMut`// достаточно специфичны с эстетической и ситуационной точки `FnOnce`зрения `Fn`, поэтому заслуживают немного времени.

И поэтому я уделю немного времени, чтобы просто сказать следующее: если вы обнаружите, что пишете трейт (или интерфейс Java, или класс C++) только с одним методом, подумайте, не следует ли вам вместо этого использовать какое-то замыкание. или лямбда-типа. Только вы можете предотвратить чрезмерную инженерию.

# Альтернатива № 2: Полиморфизм с признаками [](https://www.thecodedmessage.com/posts/oop-2-polymorphism/#alternative-2-polymorphism-with-traits)

Точно так же, как в Rust есть версия инкапсуляции, более гибкая и мощная, чем ООП-понятие классов, как я обсуждал в предыдущем [посте](https://www.thecodedmessage.com/posts/oop-1-encapsulation) , Rust имеет более мощную версию полиморфизма, чем ООП-позиты: черты.

Трейты похожи на интерфейсы из Java (или полностью абстрактный суперкласс в C++), но без большинства ограничений, которые я обсуждал в начале статьи. У них нет ни семантических ограничений, ни ограничений производительности. Семантика и принципы трейтов сильно вдохновлены классами типов Haskell, а синтаксис и реализация — шаблонами C++. Программисты на C++ могут думать о них как о шаблонах с концепциями (за исключением того, что они сделаны правильно, встроены в язык программирования с самого начала и им не приходится иметь дело со всем кодом, который его не использует).

Давайте начнем с семантики: что вы можете сделать с чертами, которые вы не можете сделать с чистым ООП, даже если вы бросите на него всю косвенность в мире? Что ж, в терминах чистого ООП вы не сможете написать интерфейс, подобный Rust `Eq`и `Ord`, учитывая здесь очень упрощенные определения (настоящие определения [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html)и [`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html)расширения других классов, которые допускают частичную эквивалентность и упорядочение между различными типами, но, как и эти упрощенные определения, Версия стандартной библиотеки Rust не является частичной `Eq`и `Ord`охватывает эквивалентность и порядок между значениями одного и того же типа):

```rust
trait Eq {
    fn eq(self, other: &Self) -> bool;
}

pub enum Ordering {
    Less,
    Equal,
    Greater,
}

trait Ord: Eq {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

Копировать

Видишь, что происходит? Как и в интерфейсе в стиле ООП, методы принимают тип «приемника», параметр `self`типа `Self`, то есть любого конкретного типа, реализующего трейт (технически здесь ссылка на `Self`или `&Self`). Но в отличие от интерфейса в стиле ООП, они также принимают еще один аргумент `&Self`типа. Для реализации `Eq`и `Ord`тип `T`предоставляет функцию, которая принимает две ссылки на `T`. Это означает буквально: две ссылки на `T`, а не одна ссылка `T` и одна ссылка на `T`или какой-либо подкласс (такой вещи не существует в Rust), не одна ссылка `T`и одна ссылка на любое другое значение, которое реализует`Eq`, а две добросовестные негетерогенные ссылки на один и тот же конкретный тип, которые функция затем может сравнить на равенство (или порядок).

Это важно, потому что мы хотим использовать это для реализации таких методов, как `sort`:

```rust
impl Vec<T> {
    pub fn sort(&mut self) where T: Ord {
        // ...
    }
}
```

Копировать

Полиморфизм в стиле ООП идеально подходит для разнородных контейнеров, где каждый элемент имеет свой тип среды выполнения и собственную реализацию интерфейсов. Но сортировка так не работает. Вы не можете сортировать коллекцию как `[3, "Hello", true]`; нет разумного порядка для всех типов.

Вместо этого `sort`работает с однородными контейнерами. Все элементы должны совпадать по типу, чтобы их можно было сравнивать друг с другом. Им не обязательно иметь разные реализации операций.

Тем не менее, `sort`остается полиморфным. Алгоритм сортировки одинаков для целых чисел или строк, но сравнение целых чисел — это совершенно другая операция, чем сравнение строк. Алгоритму сортировки нужен способ вызова операции над его элементами — операции сравнения — по-разному для разных типов, но при этом с одной и той же общей структурой кода.

Это можно сделать, внедрив функцию сравнения, но многие типы имеют встроенный порядок по умолчанию и `sort`должны соответствовать ему по умолчанию. Таким образом, полиморфизм — но не ООП-дружественная разновидность.

Посмотрите, как Java пытается определить `sort`:

```java
static <T extends Comparable<? super T>> 
void sort(List<T> list)
```

Копировать

Не существует простого признака, который может требовать `T`сравнения с другими `T`s, чтобы `T`быть упорядоченным. Вместо этого, что касается языка программирования, идея, `T`сравнимая сама с собой, а не с каким-либо другим случайным типом, артикулируется только как акциденция к этому методу. Ничто не мешает кому-то реализовать `Comparable` интерфейс непоследовательным образом, например, `Integer`реализовать `Comparable<String>`.

Кроме того, когда он на самом деле ищет реализацию `Comparable`, он решает, какую реализацию использовать, на основе первого аргумента любого сравнения, а не на основе типа. Обычно все они будут одного типа, но теоретически этот список может быть разнородным, пока все объекты «расширяются» `T`, и они могут реализовываться `Comparable`по-разному. Компьютер должен проделать дополнительную работу, чтобы воспользоваться этой возможностью, хотя это, безусловно, было бы ошибкой.

Поскольку мы сейчас уходим от области семантики в область производительности, давайте подробно обсудим реализации этого.

Метод Java `sort`, как мы упоминали, требует, чтобы каждый элемент в коллекции был полным типом объекта, что означает, что вместо хранения значений непосредственно в массиве значения хранятся в куче, а ссылки хранятся в массиве. В этом нет необходимости при подходе, основанном на признаках — значения могут находиться непосредственно в массиве.

Это означает, что разные массивы будут иметь разные размеры элементов, поэтому это также должно обрабатываться трейтом. И это так: размер значений также параметризуется через `Sized`трейт. Размер должен быть согласованным между всеми элементами массива, но это допустимо, потому что мы можем указать, что все элементы на самом деле имеют один и тот же тип — в отличие от Java, который только указывает, что они относятся к типу или `List<T>`некоторому `T`подтипу `T`.

Метод Rust `sort`мог быть реализован путем передачи информации о размере (из `Sized`типажа) и функции упорядочения (из `Ord`типажа) во время выполнения в виде целочисленного значения и указателя на функцию. Вот как классы типов работают в Haskell, что послужило источником вдохновения для трейтов Rust. Это все равно будет более эффективным, чем Java, поскольку будет одна функция упорядочивания, а не отдельный косвенный поиск для каждой левой стороны сравнения, что позволит косвенному предсказанию ветвления работать в процессоре.

Но Rust идет еще дальше и вместо этого реализует свои черты через мономорфизацию. Это похоже на создание экземпляра шаблона C++, но семантически лучше ограничено. Предпосылка состоит в том, что хотя `sort` семантически это только один метод, в выводимом скомпилированном коде `sort`выводится другая версия для каждого типа `T`, с которым он вызывается.

Шаблоны C++ создают печально известные плохие сообщения об ошибках, и их трудно понять, потому что они по сути являются макросами и неуклюжими. Даже Rust не может создавать отличные сообщения об ошибках с помощью своей системы макросов. Но кроме того, их написание требует опыта и означает, что программист отказывается от многих преимуществ системы типов — шаблоны часто называют, на мой взгляд, правильно, формой утиного набора во время компиляции. По этим причинам программирование шаблонов на C++ часто считается более продвинутым (читается как более сложным и менее удобным, чем более мощным), чем полиморфизм в стиле ООП.

В Rust, однако, трейты обеспечивают организованный и более согласованный способ доступа к аналогичным технологиям, получая преимущества производительности шаблонов, но при этом сохраняя структуру твердой системы типов.

# Альтернатива № 3: Динамические объекты признаков [](https://www.thecodedmessage.com/posts/oop-2-polymorphism/#alternative-3-dynamic-trait-objects)

Однако иногда требуется полный полиморфизм во время выполнения. У вас есть сценарий, противоположный сценарию с `enum`: у вас есть закрытый набор операций, которые можно выполнять над значением, но то, что эти операции на самом деле делают, будет динамически изменяться таким образом, что его нельзя ограничить заранее.

В таких ситуациях Rust поможет вам с `dyn`ключевым словом. Однако, пожалуйста, не злоупотребляйте им. Почти во всех ситуациях, когда я думал, что это может быть уместно, статический полиморфизм в сочетании с другими элементами дизайна работал лучше.

Законные варианты использования, `dyn`как правило, возникают в ситуациях, связанных с инверсией управления, когда библиотека фреймворка берет на себя основной цикл, а клиентский код указывает, как обрабатывать различные события. В сетевом программировании библиотека фреймворка говорит, как жонглировать всеми сокетами и регистрировать их в операционной системе, но приложение должно сказать, что на самом деле делать с данными. В программировании с графическим интерфейсом код фреймворка может сказать, какой виджет был нажат, но происходит совсем другое, если этот виджет является кнопкой, текстовым полем или пользовательским виджетом, который вы придумали для этого конкретного приложения.

Теперь для этого вам не обязательно нужен полиморфизм во время выполнения. Вместо этого вы можете использовать замыкания (или даже необработанные указатели на функции), создавая `struct`замыкания (или указатели на функции), если требуется несколько операций, что в основном означает выполнение того, что `dyn`делает трудный путь вручную. Например, я полностью рассчитывал `tokio`использовать функцию полиморфизма во время выполнения Rust внутри, чтобы справиться с этой инверсией управления при планировании задач. Вместо этого, по моему мнению, из соображений производительности, `tokio` реализуется `dyn`вручную, даже вызывая его `struct`из указателей на функции [`Vtable`](https://github.com/tokio-rs/tokio/blob/a7945b469d634cf205094d8a1661720358622cc0/tokio/src/runtime/task/raw.rs#L13-L43).

Но `dyn`работает ли все это на вас, на вашу черту. Единственное требование состоит в том, чтобы ваш трейт был объектно-безопасным, и список [требований](https://doc.rust-lang.org/reference/items/traits.html#object-safety) может показаться знакомым, особенно когда речь идет о требованиях к ассоциированной функции (например, методу), которая должна быть «диспетчерской»:

> -   Не иметь никаких параметров типа (хотя параметры времени жизни разрешены),
> -   Будьте методом, который не используется, `Self`кроме как в типе приемника.
> -   Иметь приемник одного из следующих типов:
>     -   `&Self`(т.е. `&self`)
>     -   `&mut Self`(т.е. `&mut self`)
>     -   `Box<Self>`
>     -   `Rc<Self>`
>     -   `Arc<Self>`
>     -   `Pin<P>`где `P`один из типов выше
> -   Не имеет `Self: Sized`границы where (тип получателя `Self`(т.е. `self`) подразумевает это).

Другими словами, он может быть полиморфным ровно по одному параметру, и этот параметр должен быть указан по ссылке — более или менее точные требования к методам для поддержки полиморфизма во время выполнения в ООП.

Это, конечно, потому, что `dyn`для реализации полиморфизма во время выполнения используется почти тот же механизм, что и в ООП: «vtable». `Box<dyn Foo>` действительно содержит два указателя, а не один: один на рассматриваемый объект и указатель на «vtable», автоматически сгенерированную структуру указателей на функции для этого типа. Требование одного параметра связано с тем, что это параметр, чья виртуальная таблица используется для поиска конкретной реализации метода для вызова, а требование косвенности заключается в том, что конкретный тип может иметь разные размеры, причем размер известен только во время выполнения. .

Чтобы было ясно, это ограничения одной конкретной стратегии реализации полиморфизма во время выполнения. Существуют альтернативные стратегии, которые полностью отделяют виртуальную таблицу от отдельных значений типа, как в Haskell.

Есть еще несколько преимуществ версии Rust полиморфизма времени выполнения с трейтами по сравнению с интерфейсами в стиле ООП.

С точки зрения производительности, это делается вместе с типом, а не внутри него. Обычные значения не хранят виртуальную таблицу, распределяя ее стоимость по всей программе, а ссылаются на виртуальные таблицы только при `dyn`создании указателя. Если вы никогда не создаете `dyn` указатель на значение данного типа, виртуальную таблицу этого типа даже не нужно создавать. Конечно, у вас нет 8 байт лишнего мусора в каждом распределении для всех указателей vtable! Это также означает, что на один уровень косвенности меньше.

С точки зрения семантики также хорошо, что это всего лишь один из многих вариантов, и что это не самый предпочтительный вариант, к которому вас пытается подтолкнуть весь язык программирования. Часто, даже обычно, статический полиморфизм, перечисления или даже просто старые добрые замыкания более точно представляют проблему и должны использоваться вместо них.

Наконец, тот факт, что динамический и статический полиморфизм в Rust используют трейты, упрощает переход с одной системы на другую. Если вы обнаружите, что используете `dyn`черту, вам не нужно использовать ее везде, где используется эта черта. Вместо этого вы можете использовать механизмы статического полиморфизма (такие как параметры типа и `impl Trait`), свободно смешивая и сопоставляя одни и те же черты.

В отличие от C++, вам не нужно изучать два совершенно разных набора синтаксиса для понятий и родительских классов и совершенно разную семантику. На самом деле, в Rust динамический полиморфизм — это всего лишь частный случай статического полиморфизма, и единственное отличие состоит в том, что на самом деле отличается.

# Новостная рассылка

Узнайте по электронной почте, когда я делаю новые сообщения!