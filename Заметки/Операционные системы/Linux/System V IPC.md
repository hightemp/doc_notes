https://parallel.uran.ru/book/export/html/505

# System V IPC

Интерфейс межпроцессного взаимодействия _System V IPC_ позволяет манипулировать классическими набором объектов, таких как: очередь сообщений, семафор и разделяемая память.

Объекты _System V IPC_ идентифицируется 32-битным ключом _IPC_, играющего роль, аналогичную имени файла. При создании объекта IPC ему присваивается уникальный 32-битный идентификатор _IPC_, аналогичный inode файла. Идентификаторы _IPC_ назначаются ядром, ключи _IPC_ произвольно выбираются программистами.

У каждого объект _IPC_ есть атрибуты "пользователь-владелец", "группа-владельца", "пользователь-создатель", "группа-создателя", а так же права на чтение и запись для владельца, группы-владельца и остальных, аналогичные файловым. Например: _rw- r-- ---_.

Впервые _System V IPC_ появился во внутренних версиях _Unix_, использовавшихся в компании _Bell Laboratories_, но массовое распространение получил вместе с самой продаваемой версией _Unix_ - _System V_, что и отражено в названии.

_System V IPC_ имеет некоторые недостатки, в частности, плохую масштабируемость, в связи с тем, что создаваемые объекты не привязаны к процессам, и потому могут оставаться в памяти до перезагрузки ОС .

В последующем, _System V IPC_ с небольшими изменениями вошёл в стандарт _POSIX_. Логика работы с объектами сохранилась, однако была проведена некоторая унификация вызовов _System V IPC_ с вызовами файловой системы. Соответственно, поменялись имена функций.

### Примеры отличий _System V IPC_ и _POSIX_

В _System V IPC_ для именования объекта создаётся особый 32-битный ключ, часто формируемый из _inode_ существующего файла и целого числа, в _POSIX_ имена объектов имитируют имена файловой системы в формате _/object_name_.

Набор функций для работы с разделяемой памятью из _shmget()_, _shmat()_, _shmdt()_, _shmctl()_ превратился в _shm_open()_, _mmap()_, _shm_unlink()_/

_shmget()_ возвращает идентификатор _IPC_, а _shm_open()_ возвращает файловый дескриптор.

_shmat()_, _shmdt()_ работают только с разделяемой памятью, а _mmap()_ одинаково успешно работает как с объектом "разделяемая память", так и с файлами, отображаемыми в память.

Размер сегмента разделяемой памяти _System V IPC_ неизменен, а в _POSIX_ может изменяться вызовом * ftruncate() * с последующим обновлением отображения в память процесса вызовами _munmap()_ и _mmap()_ .

Наличие сообщений в очередях _POSIX_ может мониториться через _callback_, который устанавливается вызовом _mq_notify()_.

# Классический API System V IPC

## Пространство имён

Объекты _System V IPC_ идентифицируется 32-битным ключом _IPC_, играющего роль, аналогичную имени файла. При создании объекта _IPC_ ему присваивается уникальный 32-битный идентификатор _IPC_, аналогичный _inode_ файла. Идентификаторы _IPC_ назначаются ядром, ключи _IPC_ произвольно выбираются программистами.

Особое значение ключа _IPC_PRIVATE_ адресует объект, доступный только данному процессу и его потомкам. Данное значение позволяет избежать случайного доступа к посторонним объектам из-за конфликта ключей.

В случае совпадения идентификаторов несколько программ будут пытаться получить доступ к одному и тому же объекту. Не существует механизма, гарантирующего выбор уникального ключа _IPC_, поэтому была создана специальная функция _ftok()_, генерирующая ключ на основе уникального имени файла в файловой системе (точнее номера его _Inode_) и дополнительного байта (номера проекта). При выборе файла, для формирования ключа, необходимо обеспечить достаточную длительность его жизни. Если файл удалён, то новые процессы не смогут сгенерировать ключи доступа к объектам _IPC_ на основе данного файла. Удаление файла и создание нового с тем же именем так же нарушит доступ к объектам _IPC_ поскольку новый файл будет иметь отличный номер _Inode_.

```
   #include <sys/types.h>
   #include <sys/ipc.h>

   key_t ftok("/home/bob/key_base", 'Z');
```

Реализация _ftok()_ в _glibc_

```
  if (__xstat64 (_STAT_VER, pathname, &st) < 0)
    return (key_t) -1;
  key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)
         | ((proj_id & 0xff) << 24));
  return key;
```

## Создание и удаление объектов

Объекты _IPC_ создаются функциями _msgget()_, _semget()_, _shmget()_.

При создании используются флаги

-   _IPC_CREAT_ - Создать объект если он не существовал
-   _IPC_EXCL_ - Совместно с _IPC_CREAT_ - вернуть ошибку если объект существует

и права доступа. Права доступа аналогичны файлам (mode - rw-rw-rw-)

Управление объектами SysV IPC (в том числе их уничтожение) производится c помощью функций _msgctl()_, _semctl()_, _shmctl()_. Параметр _cmd_ этих функций может принимать значения:

-   IPC_RMID - удалить объект
-   IPC_SET - изменить свойства объекта
-   IPC_STAT - получить свойства объекта

## Флаги операций

Во всех операциях с объектами может быть указан дополнительный флаг

-   IPC_NOWAIT - возвратить ошибку если операция не может быть выполнена немедленно

## Очередь сообщений

При создании очереди она ассоциируется с буфером размером _MSGMNB_ (16384 байт в _Linux_).

Сообщение состоит из заголовка фиксированной длины и текста переменной длины. Размер текста не должен превышать _MSGMAX_ (8192 байта в _Linux_).

Каждое сообщение поступает в очередь, где хранится до тех пор, пока кто-нибудь не прочитает его. После прочтения сообщение удаляется из очереди сообщений. Следовательно, только один процесс может получить конкретное сообщение.

Сообщение может быть помечено целочисленным значением (типом сообщения), которое позволяет процессу избирательно извлекать сообщения из очереди. Правила чтения по типам:

-   если _msgp_ равен нулю, то используется первое сообщение из очереди;
-   если _msgp_ больше нуля, то из очереди берется первое сообщение типа _msgp_ (если только в параметре _msgflg_ не выставлен флаг _MSG_EXCEPT_. В этом случае из очереди берется первое сообщение, тип которого не равен _msgp_).
-   если _msgp_ меньше нуля, то из очереди берется первое сообщение со значением, меньшим, чем абсолютное значение _msgp_.
    
    #include <sys/types.h> #include <sys/ipc.h> #include <sys/msg.h>
    
    int msgget(key_t key, int msgflg); int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
    
    struct msgbuf { long mtype; /* message type, must be > 0 _/ char mtext[1]; /_ message data */ };
    
    int msgctl(int msqid, int cmd, struct msqid_ds *buf);
    

## Семафоры

Каждый семафор IPC представляет собой набор из одного или нескольких целочисленных счётчиков. Таким образом один семафор может защищать несколько объектов. Обычно, нулевое значение счётчика означает, что объект свободен, положительное - занят, но можно договориться о других значениях. Механизм семафоров ничего не знает про их использование, а только обеспечивает атомарные операции изменения значений.

Существуют ограничения как на количество семафоров (по умолчанию 128), так и на количество счётчиков внутри одного семафора (по умолчанию 250). Эти данные в _Linux_ доступны в _/proc/sys/kernel/sem_.

При завершении процесса все операции, которые он проводил над семафорами сбрасываются, что позволяет избежать неприятностей в случае краха процесса, изменившего значения счётчиков.

Операции над семафорами в вызове _semop()_:

-   Если величина _sembuf[n].semop_ положительна, то текущее значение счётчика _n_ увеличивается на эту величину.
-   Если значение _sembuf[n].semop_ равно нулю, процесс ожидает, пока счётчик _n_ не обнулится.
-   Если величина _sembuf[n].semop_ отрицательна, процесс ожидает, пока значение счётчика _n_ не станет большим или равным абсолютной величине _sembuf.semop_. Затем абсолютная величина _sembuf[n].semop_ вычитается из значения счётчика _n_.
    
    #include <sys/types.h> #include <sys/ipc.h> #include <sys/sem.h>
    
    int semget(key_t key, int nsems, int semflg); int semop(int semid, struct sembuf *sops, unsigned nsops);
    
    struct sembuf { unsigned short sem_num; /* semaphore number _/ short sem_op; /_ semaphore operation _/ short sem_flg; /_ operation flags */ }
    
    int semctl(int semid, int semnum, int cmd, ...);
    

## Общая память

Вызов _shmget()_ резервирует участок физической памяти (фала подкачки)

Вызов _shmat()_ (_attach_) отображает зарезервированный участок физической памяти в виртуальное адресное пространство процесса.

Вызов _shmdt()_ (_detach_) разрывает связь между зарезервированным участок физической памяти и виртуальным адресным пространством процесса.

```
   #include <sys/ipc.h>
   #include <sys/shm.h>

   int shmget(key_t key, size_t size, int shmflg);
   void *shmat(int shmid, const void *shmaddr, int shmflg);
   int shmdt(const void *shmaddr);
   int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

# Утилиты командной строки

Просмотр информации о подсистеме _System V IPC_

```
lsipc
```

Создание объекта

```
# Допустимые опции
# -Q - создание очереди
# -M size - создание разделяемой памяти
# -S number - создание семафора
ipcmk -Q  
```

Просмотр объектов

```
ipcs
```

Удаление объектов

```
ipcrm --shmem-id 9601039
ipcrm --all
```