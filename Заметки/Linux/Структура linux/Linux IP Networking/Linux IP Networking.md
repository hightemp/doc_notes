https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html

# **Linux IP Networking  
Руководство по реализации и модификации стека протоколов Linux**

### _Гленн Херрин_

**ТР 00-04**

[Департамент компьютерных наук](http://www.cs.unh.edu/)  
[Университета Нью-Гэмпшира](http://www.unh.edu/)  
[](https://www.cs.unh.edu/cnrg/people/gherrin/www.unh.edu)

### _31 мая 2000 г._

**Абстрактный**

Этот документ представляет собой руководство по пониманию того, как ядро ​​Linux (в частности, версия 2.2.14) реализует сетевые протоколы, ориентированные в первую очередь на Интернет-протокол (IP). Он предназначен как полный справочник для экспериментаторов с обзорами, пошаговыми руководствами, объяснениями исходного кода и примерами. Первая часть содержит углубленное изучение кода, структур данных и функциональных возможностей, связанных с сетью. Есть главы об инициализации, соединениях и сокетах, а также о приеме, передаче и пересылке пакетов. Вторая часть содержит подробные инструкции по модификации исходного кода ядра и установке новых модулей. Есть главы по установке ядра, модулей, файловой системы _proc_ и полный пример.

# Содержание

[1 Введение](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp1)  
    [1.1 Предыстория](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.1)  
    [1.2 Условные обозначения в документе](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.2)  
    [1.3 Пример сети](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.3)  
    [1.4 Авторские права, лицензия и отказ от ответственности](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.4)  
    [1.5 Благодарности](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.5)  
[2 Обзор трафика сообщений](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp2)  
    [2.1 Путь сетевого трафика](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.1)  
    [2.2 Стек протоколов](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.2)  
    [2.3 Структура пакета 2.4](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.3)  
    [Интернет-маршрутизация](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.4)  
[3 Инициализация сети](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp3)  
    [3.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.1)  
    [3.2 Запуск](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2)  
        [3.2.1 Сценарий сетевой инициализации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.1)  
        [3.2.2  _ifconfig_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.2)  
         [3.2.3  _route_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.3)  
         [3.2.4 Программы динамической маршрутизации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.4)  
    [3.3 Примеры](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3)  
        [3.3.1 Домашний компьютер](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.1)  
        [3.3.2 Главный компьютер в локальной сети](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.2)  
        [3.3.3 Компьютер сетевой маршрутизации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.3)  
    [3.4 Функции Linux и сетевых программ](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4)  
        [3.4.1  _ifconfig_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.1)  
         [3.4.2  _route_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.2)  
[4 Соединения](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp4)  
    [4.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.1)  
    [4.2 Структуры сокетов](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.2)  
    [4.3 Сокеты и маршрутизация](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.3)  
    [4.4 Процессы соединения](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4)  
        [4.4.1 Установление соединений](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.1)  
        [4.4.2 Прохождение вызовов сокетов](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.2)  
        [4.4.3 Прохождение вызовов Connect](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.3)  
        [4.4 .4 Закрытие соединений](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.4)  
        [4.4.5 Закрытие обхода](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.5)  
    [4.5 Функции Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.5)  
[5 Отправка сообщений](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp5)  
    [5.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.1)  
    [5.2 Отправка обхода](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2)  
        [5.2.1 Запись в сокет](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.1)  
        [5.2.2 Создание пакета с помощью UDP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.2)  
        [5.2.3 Создание пакета с помощью TCP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.3)  
        [5.2.4 Упаковка пакета в IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.4)  
        [5.2.5 Передача пакета](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.5)  
    [5.3 Функции Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.3)  
[6 Получение сообщений](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp6)  
    [6.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.1)  
    [6.2 Пошаговое руководство по приему](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2)  
        [6.2.1 Чтение из сокета (часть I)](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.1)  
        [6.2.2 Получение пакета](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.2)  
        [6.2.3 Запуск сети «нижняя половина»](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.3)  
        [6.2.4 Развертка пакета в IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.4)  
        [6.2.5 Прием пакета в UDP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.5)  
        [6.2.6 Прием пакета в TCP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.6)  
        [6.2.7 Чтение из сокета (Часть II)](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.7)  
    [6.3 Функции Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.3)  
[7 Переадресация IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp7)  
    [7.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.1)  
    [7.2 Пошаговое руководство по пересылке IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2)  
        [7.2.1 Получение пакета](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.1)  
        [7.2.2 Запуск сети "Нижняя половина"](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.2)  
        [7.2.3 Проверка пакета в IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.3)  
        [7.2.4 Пересылка пакета в IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.4)  
        [7.2.5 Передача пакета](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.5)  
    [7.3 Функции Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.3)  
[8 Базовая маршрутизация по Интернет-протоколу](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp8)  
    [8.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.1)  
    [8.2 Таблицы маршрутизации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2)  
        [8.2.1 Таблица соседей](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.1)  
        [8.2.2 Информационная база пересылки](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.2)  
        [8.2.3 Кэш маршрутизации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.3)  
        [8.2.4 Обновление информации о маршрутизации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.4)  
    [8.3 Функции Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.3)  
[9 Динамическая маршрутизация с помощью _routed_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp9)  
     [9.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.1)  
    [9.2 Как работает _routed_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2)  
         [9.2 .1 Структуры данных](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.1)  
        [9.2.2 Инициализация](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.2)  
        [9.2.3 Обычные операции](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.3)  
    [9.3  _Маршрутизируемые_ функции](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.3)  
[10 Редактирование исходного кода Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp10)  
    [10.1 Дерево исходного кода Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.1)  
    [10.2 Использование тегов EMACS](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2)  
        [10.2.1 Ссылки с помощью тегов](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.1)  
        [10.2.2 Создание файлов TAGS](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.2)  
    [10.3 Использование тегов vi](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.3)  
    [10.4 Пересборка ядра](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.4)  
    [10.5 Исправление исходного кода ядра](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.5)  
[11 Модули Linux](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp11)  
    [11.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.1)  
    [11.2 Запись, установка и удаление модулей](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2)  
        [11.2.1 Запись модулей](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.1)  
        [11.2.2 Установка и удаление модулей](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.2)  
    [11.3 Пример](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.3)  
[12 Файловая система _proc_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp12)  
     [12.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.1)  
    [12.2 Сетевые файлы _proc_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.2)  
     [12.3 Регистрация _proc_ Файлы](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3)  
        [12.3.1 Форматирование функции для предоставления информации](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.1)  
        [12.3.2 Создание записи процедуры _12.3.3_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.2)  
         [Регистрация записи процедуры _12.3.4_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.3)  
         [Отмена регистрации записи процедуры _12.4_](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.4)  
     [Пример](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.4)  
[13 Пример — отбрасыватель пакетов](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp13)  
    [13.1 Обзор](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.1)  
    [13.2 Соображения](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.2)  
    [13.3 Экспериментальные системы и тесты](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.3)  
    [13.4 Результаты и предварительный анализ](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4)  
        [13.4.1 Стандартное ядро](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.1)  
        [​​13.4.2 Модифицированное ядро, отбрасывающее пакеты](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.2)  
        [13.4.3 Предварительный анализ](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.3)  
    [13.5 Код](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5)  
        [13.5.1 Ядро](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.1)  
        [13.5.2 Модуль](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.2)  
[14 Дополнительные ресурсы](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp14)  
    [14.1 Интернет-сайты](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.1)  
    [14.2 Книги](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.2)  
[15 Акронимы](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp15)  

# Глава 1  
Введение

Это версия 1.0 этого документа от 31 мая 2000 г. со ссылкой на ядро ​​Linux версии 2.2.14.

## 1.1   Предыстория

Linux становится все более популярным в качестве альтернативной операционной системы. Поскольку он доступен всем в рамках движения за открытый исходный код, буквально тысячи программистов постоянно работают над кодом, чтобы реализовать новые функции, улучшить существующие и исправить ошибки и неэффективность в коде. Есть много источников для получения дополнительной информации о Linux, от самого исходного кода (скачиваемого из Интернета) до книг, ``HOW-TO'' и досок объявлений, поддерживаемых на самые разные темы.

Этот документ представляет собой попытку объединить многие из этих источников в один последовательный справочник и руководство по изменению сетевого кода в ядре Linux. В нем представлена ​​внутренняя работа на четырех уровнях: общий обзор, более конкретные исследования сетевой активности, подробное описание функций и ссылки на фактический код и структуры данных. Он разработан, чтобы предоставить столько деталей, сколько пожелает читатель. Это руководство было написано специально для ядра Linux 2.2.14 (которое уже было заменено ядром 2.2.15), и многие примеры взяты из дистрибутива Red Hat 6.1; надеюсь, предоставленная информация является достаточно общей, чтобы она по-прежнему применялась в дистрибутивах и новых ядрах. Он также фокусируется почти исключительно на TCP/UDP, IP,

В качестве справочника для программистов ядра этот документ содержит информацию и указатели по редактированию и перекомпиляции ядра, написанию и установке модулей и работе с файловой системой _/proc_ . Также представлен пример программы, которая отбрасывает пакеты для выбранного хоста, а также анализ результатов. Между описаниями и примерами это должно ответить на большинство вопросов о том, как Linux выполняет сетевые операции и как вы можете изменить его в соответствии со своими целями.

Этот проект начался в сетевой лаборатории факультета компьютерных наук Университета Нью-Гемпшира как попытка внесения изменений в ядро ​​Linux для экспериментов с различными алгоритмами маршрутизации. Вскоре стало очевидно, что взламывать ядро ​​вслепую — плохая идея, поэтому этот документ родился как исследовательский отчет и справочник для будущих программистов. Наконец, он стал достаточно большим (и, надеюсь, достаточно полезным), поэтому мы решили обобщить его, формализовать и выпустить для всеобщего обозрения.

И последнее замечание: Linux — это постоянно меняющаяся система, и настоящее освоение ее, если такое вообще возможно, займет гораздо больше времени, чем было потрачено на составление этого справочника. Если вы заметили какие-либо искажения, упущения, явные ошибки или даже опечатки (!) в этом документе, пожалуйста, свяжитесь с человеком, который в настоящее время ведет его. Целью этого проекта было создание бесплатного и полезного справочника для Linux-программистов.

## 1.2   Условные обозначения документов

Предполагается, что читатель понимает язык программирования C и знаком с распространенными сетевыми протоколами. Это не обязательно для более общей информации, но подробности в этом документе предназначены для опытных программистов и могут быть непонятны рядовым пользователям Linux.

Почти весь представленный код требует доступа суперпользователя для реализации. Некоторые из примеров могут создавать дыры в безопасности там, где их раньше не было; программисты должны быть осторожны, чтобы восстановить свои системы до нормального состояния после экспериментов с ядром.

Ссылки на файлы и имена программ пишутся _наклонным_ шрифтом.

Код, записи командной строки и имена машин написаны шрифтом пишущей машинки .

Общие записи или переменные (например, имя выходного файла) и комментарии выделены _курсивом_ .

## 1.3   Пример примера сети

В этом документе есть многочисленные примеры, которые помогают пояснить представленный материал. Ради последовательности и знакомства большинство из них ссылаются на пример сети, показанный на рис.  [1.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#i_example) .

![i_example.gif](https://www.cs.unh.edu/cnrg/people/gherrin/i_example.gif)  

Рисунок 1.1: Пример структуры сети.

Эта сеть представляет собой компьютерную систему в вымышленном безымянном университете (U!). Он имеет маршрутизатор, подключенный к Интернету в целом ( крайслер ). Эта машина подключена (через интерфейс джипа ) к общеуниверситетской сети u.edu , состоящей из компьютеров, названных в честь автомобильных компаний, принадлежащих Chrysler ( dodge , eagle и т. д.). Существует также подсеть LAN для отдела компьютерных наук, cs.u.edu , хосты которой названы в честь моделей автомобилей Dodge ( stealth , neon и т. д.). Они подключены к сети кампуса с помощью компьютера dodge/viper . И u.edu , и cs.u.eduсети используют оборудование и протоколы Ethernet.

Это явно не настоящая сеть. Все IP-адреса берутся из блока, зарезервированного для частных сетей класса B (уникальность которых не гарантируется). В большинстве реальных сетей класса B было бы гораздо больше компьютеров, а в сети всего с восемью компьютерами, вероятно, не было бы подсети. Подключение к Интернету (через Chrysler ) обычно осуществляется через линию T1 или T3, и этот маршрутизатор, вероятно, будет «настоящим» маршрутизатором (то есть аппаратным маршрутизатором Cisco Systems), а не компьютером с двумя сетевыми картами. Однако этот пример достаточно реалистичен, чтобы служить своей цели: проиллюстрировать реализацию сети Linux и взаимодействие между хостами, подсетями и сетями.

## 1.4   Авторское право, лицензия и отказ от ответственности

Авторское право (c) 2000 г. принадлежит Гленну Херрину. Этот документ может быть свободно воспроизведен полностью или частично при условии указания автора с помощью строки, подобной следующей:

> Скопировано из Linux IP Networking, доступного по адресу _[http://www.cs.unh.edu/cnrg/gherrin](http://www.cs.unh.edu/cnrg/gherrin)_ .

(Видимость авторства должна быть пропорциональна объему воспроизведенного документа!) Коммерческое распространение разрешено и поощряется. Все модификации этого документа, включая переводы, антологии и частичные документы, должны соответствовать следующим требованиям:

1.  Модифицированные версии должны быть помечены соответствующим образом.
2.  Лицо, внесшее изменения, должно быть идентифицировано.
3.  Признание первоначального автора должно быть сохранено.
4.  Местоположение исходного неизмененного документа должно быть указано.
5.  Имя оригинального автора не может использоваться для утверждения или подразумевающего одобрения конечного документа без разрешения первоначального автора.

Пожалуйста, обратите внимание на любые изменения, включая удаления.

Это вариант (изменения являются преднамеренными) лицензии Linux Documentaion Project (LDP), доступной по адресу:

> _[http://www.linuxdoc.org/COPYRIGHT.html](http://www.linuxdoc.org/COPYRIGHT.html)_

Этот документ в настоящее время не является частью LDP, но может быть представлен в будущем.

Этот документ распространяется в надежде, что он будет полезен, но (конечно) без какой-либо явной или подразумеваемой гарантии пригодности для какой-либо цели. Используйте его на свой страх и риск.

## 1.5   Благодарности

Я написал этот документ в рамках своего магистерского проекта для факультета компьютерных наук Университета Нью-Гемпшира. Я хотел бы поблагодарить профессора Пилар де ла Торре за организацию проекта и профессора Радима Бартоса за то, что он был и спонсором, и моим советником, дав мне многочисленные указания, большую поддержку и набор компьютеров для экспериментов. Я также хотел бы отдать должное армии Соединенных Штатов, которая была моим домом в течение 11 лет и оплачивала мое посещение UNH.

Гленн Херрин Мейджор, первичный документатор и исследователь  
армии США , версия 1.0 gherrin@cs.unh.edu  
  

# Глава 2.  
Обзор трафика сообщений

В этой главе представлен обзор всей системы обмена сообщениями Linux. В нем обсуждаются конфигурации, вводятся задействованные структуры данных и описываются основы IP-маршрутизации.

## 2.1   Путь сетевого трафика

Интернет-протокол (IP) является сердцем системы обмена сообщениями Linux. В то время как Linux (более или менее) строго придерживается концепции многоуровневости — и можно использовать другой протокол (например, ATM), — IP почти всегда является связующим звеном, через которое проходят пакеты. IP-реализация сетевого уровня выполняет маршрутизацию и пересылку, а также инкапсуляцию данных. На рис.  [2.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_path) показана упрощенная схема того, как сетевые пакеты проходят через ядро ​​Linux.

![o_path.gif](https://www.cs.unh.edu/cnrg/people/gherrin/o_path.gif)  

Рисунок 2.1: Абстракция пути трафика сообщений Linux.

Когда приложение генерирует трафик, оно отправляет пакеты через сокеты на транспортный уровень (TCP или UDP), а затем на сетевой уровень (IP). На уровне IP ядро ​​ищет маршрут к хосту либо в кэше маршрутизации, либо в своей информационной базе пересылки (FIB). Если пакет предназначен для другого компьютера, ядро ​​обращается к нему, а затем отправляет его на выходной интерфейс канального уровня (обычно устройство Ethernet), которое в конечном итоге отправляет пакет через физическую среду.

Когда пакет поступает по среде, входной интерфейс получает его и проверяет, действительно ли пакет предназначен для хост-компьютера. Если это так, он отправляет пакет на уровень IP, который ищет маршрут к месту назначения пакета. Если пакет необходимо переслать на другой компьютер, уровень IP отправляет его обратно на выходной интерфейс. Если пакет предназначен для приложения, он отправляет его через транспортный уровень и сокеты для чтения приложением, когда он будет готов.

Попутно каждый сокет и протокол выполняет различные проверки и функции форматирования, подробно описанные в последующих главах. Весь процесс реализован с помощью ссылок и таблиц переходов, которые изолируют каждый протокол, большинство из которых настраиваются во время инициализации при загрузке компьютера. Подробную информацию о процессе инициализации см. в Главе  [3 .](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#initialization)

## 2.2   Стек протоколов

Сетевые устройства образуют нижний уровень стека протоколов; они используют протокол канального уровня (обычно Ethernet) для связи с другими устройствами для отправки и получения трафика. Входные интерфейсы копируют пакеты с носителя, выполняют некоторые проверки на наличие ошибок, а затем пересылают их на сетевой уровень. Выходные интерфейсы получают пакеты с сетевого уровня, выполняют некоторые проверки на наличие ошибок, а затем отправляют их по среде.

IP — это стандартный протокол сетевого уровня. Он проверяет входящие пакеты, чтобы определить, предназначены ли они для хост-компьютера или их необходимо переслать. Он при необходимости дефрагментирует пакеты и доставляет их транспортным протоколам. Он поддерживает базу данных маршрутов для исходящих пакетов; он обращается к ним и при необходимости фрагментирует их перед отправкой на канальный уровень.

TCP и UDP являются наиболее распространенными протоколами транспортного уровня. UDP просто обеспечивает структуру для адресации пакетов к портам внутри компьютера, в то время как TCP позволяет выполнять более сложные операции на основе соединений, включая механизмы восстановления после потери пакетов и реализации управления трафиком. Любой из них копирует полезную нагрузку пакета между пользователем и пространством ядра. Однако и то, и другое является лишь частью промежуточного уровня между приложениями и сетью.

Специфичные для IP сокеты INET — это элементы данных и реализации универсальных сокетов. У них есть связанные очереди и код, выполняющий операции сокета, такие как чтение, запись и установление соединений. Они действуют как посредник между общим сокетом приложения и протоколом транспортного уровня.

Универсальные сокеты BSD — это более абстрактные структуры, содержащие сокеты INET. Приложения читают и записывают в сокеты BSD; сокеты BSD переводят операции в операции сокетов INET. См. главу  [4](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#connect) для получения дополнительной информации о сокетах.

Приложения, работающие в пользовательском пространстве, образуют верхний уровень стека протоколов; они могут быть такими же простыми, как двустороннее чат-соединение, или такими сложными, как протокол информации о маршрутизации (RIP — см. главу  [9](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route) ).

## 2.3   Структура пакета

Ключом к поддержанию строгой многоуровневости протоколов без потери времени на копирование параметров и полезной нагрузки туда и обратно является общая структура данных пакета (буфер сокета или sk_buff — рис.  [2.2](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_skbuff) ). Во всех вызовах различных функций, когда данные проходят через протоколы, данные полезной нагрузки копируются только дважды; один раз от пользователя в пространство ядра и один раз из пространства ядра в выходной носитель (для исходящего пакета).

![o_skbuff.gif](https://www.cs.unh.edu/cnrg/people/gherrin/o_skbuff.gif)  

Рисунок 2.2: Структура пакета ( sk_buff ).

Эта структура содержит указатели на всю информацию о пакете — его сокет, устройство, маршрут, расположение данных и т. д. Транспортные протоколы создают эти структуры пакетов из выходных буферов, а драйверы устройств создают их для входящих данных. Затем каждый уровень заполняет информацию, которая ему нужна, при обработке пакета. Все протоколы — транспортный (TCP/UDP), интернет (IP) и канальный уровень (Ethernet) — используют один и тот же буфер сокетов.

## 2.4   Интернет-маршрутизация

Уровень IP обеспечивает маршрутизацию между компьютерами. Он хранит две структуры данных; База информации о переадресации (FIB), которая отслеживает все детали для каждого известного маршрута, и более быстрый кэш маршрутизации для пунктов назначения, которые в настоящее время используются. (Существует также третья структура — таблица соседей — которая отслеживает компьютеры, физически подключенные к хосту.)

FIB является основной ссылкой маршрутизации; он содержит до 32 зон (по одной на каждый бит IP-адреса) и записи для каждого известного места назначения. Каждая зона содержит записи для сетей или хостов, которые могут быть однозначно идентифицированы определенным количеством битов — сеть с сетевой маской 255.0.0.0 имеет 8 значащих битов и будет находиться в зоне 8, а сеть с сетевой маской 255.255.255.0 имеет 24 значащих бита и находится в зоне 24. Когда IP нужен маршрут, он начинает с наиболее конкретных зон и просматривает всю таблицу, пока не найдет совпадение (всегда должна быть хотя бы одна запись по умолчанию). Файл _/proc/net/route_ содержит содержимое FIB.

Кэш маршрутизации представляет собой хеш-таблицу, которую IP использует для фактической маршрутизации пакетов. Он содержит до 256 цепочек текущих записей маршрутизации, положение каждой записи определяется хэш-функцией. Когда хосту необходимо отправить пакет, IP ищет запись в кэше маршрутизации. Если такового нет, он находит соответствующий маршрут в FIB и вставляет новую запись в кэш. (Эта запись используется для маршрутизации различными протоколами, а не запись FIB.) Записи остаются в кэше до тех пор, пока они используются; если для пункта назначения нет трафика, время ожидания записи истекает, и IP удаляет ее. Файл _/proc/net/rt_cache_ содержит содержимое кеша маршрутизации.

Эти таблицы выполняют всю маршрутизацию в обычной системе. Даже другие протоколы (например, RIP) используют те же структуры; они просто изменяют существующие таблицы в ядре, используя функцию ioctl() . Подробную информацию о маршрутизации см. в главе  [8 .](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#routing)

# Глава 3  
Инициализация сети

В этой главе представлена ​​инициализация сети при запуске. В нем представлен обзор того, что происходит при загрузке операционной системы Linux, показано, как ядро ​​и вспомогательные программы _ifconfig_ и _route_ устанавливают сетевые связи, показаны различия между несколькими примерами конфигураций, а также обобщен код реализации в ядре и сетевых программах.

## 3.1   Обзор

Linux инициализирует таблицы маршрутизации при запуске, только если компьютер настроен для работы в сети. (Почти все Linux-машины реализуют работу в сети, даже автономные машины, хотя бы для того, чтобы использовать петлевое устройство.) Когда ядро ​​заканчивает загрузку, оно запускает набор общих, но специфичных для системы служебных программ и считывает файлы конфигурации, некоторые из которых установить сетевые возможности компьютера. Они определяют его собственный адрес, инициализируют его интерфейсы (например, карты Ethernet) и добавляют важные и известные статические маршруты (например, один к маршрутизатору, который соединяет его с остальной частью Интернета). Если компьютер сам является маршрутизатором, он также может выполнять программу, которая позволяет ему динамически обновлять свои таблицы маршрутизации (но это НЕ выполняется на большинстве хостов).

Весь процесс настройки может быть статическим или динамическим. Если адреса и имена никогда (или редко) не меняются, системный администратор должен определить параметры и переменные в файлах при настройке системы. В более изменчивой среде хост будет использовать протокол, такой как протокол динамической конфигурации оборудования (DHCP), чтобы запрашивать информацию об адресе, маршрутизаторе и DNS-сервере, с помощью которой можно настроить себя при загрузке. (На самом деле, в любом случае администратор почти всегда будет использовать интерфейс с графическим интерфейсом, например панель управления Red Hat, которая автоматически записывает файлы конфигурации, показанные ниже.)

Важно отметить, что хотя большинство компьютеров под управлением Linux запускаются одинаково, программы и их расположение никоим образом не стандартизированы; они могут сильно различаться в зависимости от распространения, соображений безопасности или прихотей системного администратора. В этой главе представлено как можно более общее описание, но предполагается дистрибутив Red Hat Linux 6.1 и обычно статическая сетевая среда.

## 3.2   Запуск

Когда Linux загружается как операционная система, она загружает свой образ с диска в память, распаковывает его и устанавливает себя, устанавливая файловые системы, управление памятью и другие ключевые системы. В качестве последней задачи ядра (инициализации) выполняется программа _инициализации_ . Эта программа считывает файл конфигурации ( _/etc/inittab_ ), который указывает ей выполнить сценарий запуска (находящийся в _/etc/rc.d_ в дистрибутивах Red Hat). Это, в свою очередь, запускает дополнительные сценарии, включая сетевой сценарий ( _/etc/rc.d/init.d/network_ ). (См. Раздел [3.3](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_i_examples) для примеров взаимодействия сценария и файла.)

### 3.2.1   Сценарий инициализации сети

Сценарий сетевой инициализации задает переменные среды для идентификации хост-компьютера и определения того, будет ли компьютер использовать сеть. В зависимости от заданных значений сетевой сценарий включает (или выключает) переадресацию IP-адресов и фрагментацию IP-адресов. Он также устанавливает маршрутизатор по умолчанию для всего сетевого трафика и устройство, используемое для отправки такого трафика. Наконец, он вызывает любые сетевые устройства с помощью программ _ifconfig_ и _route_ . (В динамической среде он будет запрашивать у DHCP-сервера свою сетевую информацию вместо того, чтобы читать свои собственные файлы.)

Сценарий (сценарии), задействованный в создании сети, может быть очень простым; вполне возможно иметь один большой сценарий, который просто выполняет ряд команд, которые должным образом настроят одну машину. Тем не менее, большинство дистрибутивов Linux поставляются с большим количеством универсальных сценариев, которые работают для самых разных настроек компьютеров. Это оставляет много косвенного и условного выполнения в сценариях, но на самом деле значительно упрощает настройку любой машины. Например, в дистрибутивах Red Hat сценарий _/etc/rc.d/init.d/network_ запускает несколько других сценариев и устанавливает переменные, такие как interfaces_boot , чтобы отслеживать, какой файл _/etc/sysconfig/network-scripts/ifup_скрипты для запуска. Отследить процесс вручную очень сложно, но простая модификация всего двух конфигурационных файлов (с указанием правильных имен и IP-адресов в файлах _/etc/sysconfig/network_ и _/etc/sysconfig/network-scripts/ifcfg-eth0_ ) настраивает вся система правильно (и графический интерфейс делает процесс еще проще).

Когда сетевой сценарий завершается, FIB содержит указанные маршруты к заданным хостам или сетям, а кэш маршрутизации и таблицы соседей пусты. Когда трафик начинает течь, ядро ​​​​обновляет таблицу соседей и кэш маршрутизации в рамках обычных сетевых операций. (Сетевой трафик может начаться во время инициализации, если хост настроен динамически или, например, обращается к сетевым часам.)

### 3.2.2   _Ифконфиг_

Программа _ifconfig_ настраивает интерфейсные устройства для использования. (Эта программа, хотя и очень широко используется, не является частью ядра.) Она предоставляет каждому устройству его (IP) адрес, сетевую маску и широковещательный адрес. Устройство, в свою очередь, будет запускать свои собственные функции инициализации (для установки любых статических переменных) и регистрировать свои прерывания и процедуры обслуживания в ядре. Команды _ifconfig_ в сетевом скрипте выглядят так:

> ifconfig ${DEVICE} ${IPADDR} сетевая маска ${NMASK} широковещательная рассылка ${BCAST}

(где переменные либо пишутся непосредственно в скрипте, либо определяются в других скриптах).

Программа _ifconfig_ также может предоставить информацию о сконфигурированных в данный момент сетевых устройствах (вызов без аргументов отображает все активные интерфейсы; вызов с параметром -a отображает все интерфейсы, активные или нет):

> ifconfig

Это предоставляет всю доступную информацию о каждом рабочем интерфейсе; адреса, статус, статистика пакетов и особенности операционной системы. Обычно будет как минимум два интерфейса - сетевая карта и петлевое устройство. Информация по каждому интерфейсу выглядит так (это интерфейс вайпера ):

> Инкапсуляция канала eth0: Ethernet HWaddr 00:C1:4E:7D:9E:25
>       инет-адрес: 172.16.1.1 Bcast: 172.16.1.255 Маска: 255.255.255.0
>       ВВЕРХ ТРАНСЛЯЦИЯ РАБОТАЕТ MULTICAST MTU:1500 Метрика:1
>       Пакеты RX: 389016 ошибки: 16534 отброшены: 0 переполнение: 0 кадр: 24522
>       Пакеты TX: 400845 ошибки: 0 отброшены: 0 переполнены: 0 перевозчик: 0
>       коллизии: 0 txqueuelen: 100
>       Прерывание: 11 Базовый адрес: 0xcc00

Суперпользователь может использовать _ifconfig_ для изменения настроек интерфейса из командной строки; вот синтаксис:

> _параметры интерфейса_ ifconfig [aftype] _|_ _адрес ..._

... и некоторые из наиболее полезных вызовов:

> ifconfig eth0 down — выключение eth0  
> ifconfig eth1 up — активация eth1  
> ifconfig eth0 arp — включение ARP на eth0  
> ifconfig eth0 -arp — отключение ARP на eth0  
> ifconfig eth0 netmask 255.255.255.0 — установка сетевой маски eth0  
> ifconfig lo mtu 2000 — установка максимального значения обратной связи блок передачи  
> ifconfig eth1 172.16.0.7 — установить IP-адрес eth1

Обратите внимание, что изменение конфигурации интерфейса может косвенно изменить таблицы маршрутизации. Например, изменение сетевой маски может сделать некоторые маршруты спорными (включая маршрут по умолчанию или даже маршрут к самому хосту), и ядро ​​удалит их.

### 3.2.3   _маршрут_

Программа _маршрутизации_ просто добавляет предопределенные маршруты для интерфейсных устройств в информационную базу пересылки (FIB). Это также не часть ядра; это пользовательская программа, команда которой в сценарии выглядит так:

> route add -net ${NETWORK} netmask ${NMASK} dev ${DEVICE} -or-  
> route add -host ${IPADDR} ${DEVICE}  

(где переменные снова прописаны или определены в других сценариях).

Программа маршрутизации также может удалять маршруты (если запущена с опцией del ) или предоставлять информацию о маршрутах _,_ которые в настоящее время определены (если запущена без опций):

> маршрут

Это отображает таблицу IP-маршрутизации ядра (FIB, а не кэш маршрутизации). Например ( невидимый компьютер):

> Таблица IP-маршрутизации ядра
> Шлюз назначения Флаги Генмаски Метрика Ссылка Использование Iface
> 172.16.1.4 * 255.255.255.255 UH 0 0 0 eth0
> 172.16.1.0 * 255.255.255.0 U 0 0 0 eth0
> 127.0.0.0 * 255.0.0.0 U 0 0 0 ниже
> по умолчанию viper.u.edu 0.0.0.0 UG 0 0 0 eth0

Суперпользователь может использовать _route_ для добавления и удаления IP-маршрутов из командной строки; вот основной синтаксис:

> добавить маршрут _[-net | -host] target [параметр arg]_  
> route del _[-net | -host] цель [опция arg]_

... и несколько полезных примеров:

> route add -host 127.16.1.0 eth1 - добавляет маршрут к хосту  
> route add -net 172.16.1.0 netmask 255.255.255.0 eth0 - добавляет сетевой  
> маршрут add default gw jeep - устанавливает маршрут по умолчанию через jeep  
> (Обратите внимание, что маршрут к jeep должен быть уже настроен)  
> route del -host 172.16.1.16 - удаляет запись для хоста 172.16.1.16

### 3.2.4   Программы динамической маршрутизации

Если компьютер является маршрутизатором, сетевой сценарий запустит программу маршрутизации, такую ​​как _routed_ или _gated_ . Поскольку большинство компьютеров всегда находятся в одной проводной сети с одним и тем же набором адресов и ограниченными возможностями маршрутизации, на большинстве компьютеров не выполняется ни одна из этих программ. (Если кабель Ethernet обрезан, трафик просто не пойдет; нет необходимости пытаться перенаправлять или настраивать таблицы маршрутизации.) См. главу  [9](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route) для получения дополнительной информации о _routed_ .

## 3.3   Примеры

Ниже приведены примеры файлов для систем, настроенных тремя различными способами, и пояснения того, как они работают. Обычно каждый компьютер выполняет сетевой сценарий, который считывает файлы конфигурации, даже если файлы предписывают компьютеру не реализовывать какую-либо сеть.

### 3.3.1   Домашний компьютер

Эти файлы будут на компьютере, который не подключен к сети постоянно, но имеет модем для доступа по протоколу ppp . (Этот раздел не относится к компьютеру из общего примера.)

Это первый файл, который будет читать сетевой скрипт; он устанавливает несколько переменных среды. Первые две переменные заставляют компьютер запускать сетевые программы (даже если он не в сети), но не пересылать пакеты (поскольку ему некуда их отправлять). Последние две переменные являются общими элементами.

_/etc/sysconfig/сеть_

> NETWORKING=yes  
> FORWARD_IPV4=false  
> HOSTNAME=localhost.localdomain  
> GATEWAY=

После установки этих переменных сетевой сценарий решит, что ему необходимо настроить хотя бы одно сетевое устройство, чтобы оно стало частью сети. Следующий файл (который практически одинаков на всех компьютерах с Linux) устанавливает переменные окружения для loopback-устройства. Он дает ему имя и дает ему (стандартный) IP-адрес, сетевую маску и широковещательный адрес, а также любые другие переменные, относящиеся к устройству. (Переменная ONBOOT — это флаг для программы-скрипта, который сообщает ей настроить это устройство при загрузке.) Большинство компьютеров, даже те, которые никогда не будут подключаться к Интернету, устанавливают петлевое устройство для межпроцессного взаимодействия.

_/etc/sysconfig/сетевые скрипты/ifcfg-ло_

> DEVICE=lo  
> IPADDR=127.0.0.1  
> NMASK=255.0.0.0  
> NETWORK=127.0.0.0  
> BCAST=127.255.255.255  
> ONBOOT=yes  
> NAME=loopback  
> BOOTPROTO=none

После установки этих переменных скрипт запустит программу _ifconfig_ и остановится, так как в данный момент больше делать нечего. Однако, когда программа ppp подключается к поставщику услуг Интернета, она устанавливает устройство ppp , а также адресацию и маршруты на основе динамических значений, назначенных поставщиком услуг Интернета. DNS-сервер и другая информация о соединении должны быть в файле _ifcfg-ppp_ .

### 3.3.2   Хост-компьютер в локальной сети

Эти файлы будут на компьютере, подключенном к локальной сети; у него есть одна карта Ethernet, которая должна появляться при загрузке компьютера. Эти файлы отражают записи на стелс- компьютере из общего примера.

Это первый файл, который будет читать сетевой скрипт; снова первые переменные просто определяют, что компьютер будет работать в сети, но не будет пересылать пакеты. Последние четыре переменные идентифицируют компьютер и его связь с остальной частью Интернета (все, что не находится в локальной сети).

_/etc/sysconfig/сеть_

> NETWORKING=yes  
> FORWARD_IPV4=false  
> HOSTNAME=stealth.cs.u.edu  
> DOMAINNAME=cs.u.edu  
> GATEWAY=172.16.1.1  
> GATEWAYDEV=eth0  

После установки этих переменных сетевой скрипт настроит сетевые устройства. Этот файл устанавливает переменные среды для карты Ethernet. Он называет устройство и дает ему его IP-адрес, сетевую маску и широковещательный адрес, а также любые другие переменные устройства. Этот тип компьютера также будет иметь файл конфигурации обратной связи, точно такой же, как и для компьютера, не подключенного к сети.

_/etc/sysconfig/сетевые скрипты/ifcfg-eth0_

> DEVICE=eth0  
> IPADDR=172.16.1.4  
> NMASK=255.255.255.0  
> NETWORK=172.16.1.0  
> BCAST=172.16.1.255  
> ONBOOT=да  
> BOOTPROTO=нет  

После установки этих переменных сетевой сценарий запустит _программу ifconfig_ для запуска устройства. Наконец, сценарий запустит программу _маршрутизации_ , чтобы добавить маршрут по умолчанию ( GATEWAY ) и любые другие указанные маршруты (которые можно найти в _файле /etc/sysconfig/static-routes_ , если таковые имеются). В этом случае указывается только маршрут по умолчанию, так как весь трафик либо остается в локальной сети (где компьютер будет использовать ARP для поиска других хостов), либо проходит через маршрутизатор, чтобы попасть во внешний мир.

### 3.3.3   Компьютер сетевой маршрутизации

Эти файлы будут на компьютере, который служит маршрутизатором между двумя сетями; у него есть две карты Ethernet, по одной для каждой сети. Одна карта находится в большой сети (WAN), подключенной к Интернету (через еще один маршрутизатор), а другая — в подсети (LAN). Компьютеры в локальной сети, которым необходимо обмениваться данными с остальной частью Интернета, отправляют трафик через этот компьютер (и наоборот). Эти файлы отражают записи на компьютере dodge/viper из общего примера.

Это первый файл, который будет читать сетевой скрипт; он устанавливает несколько переменных среды. Первые два просто определяют, что компьютер будет работать в сети (поскольку он находится в сети) и что этот компьютер будет пересылать пакеты (из одной сети в другую). _IP Forwarding встроен в большинство ядер, но он не активен, если в файле /proc/net/ipv4/ip_forward_ нет 1 ``записи'' . (Один из сетевых сценариев выполняет команду echo 1 > /proc/net/ipv4/ip_forward, если FORWARD_IPV4 имеет значение true.) Последние четыре переменные идентифицируют компьютер и его связь с остальной частью Интернета (все, что не находится в одной из его собственные сети).

_/etc/sysconfig/сеть_

> NETWORKING=yes  
> FORWARD_IPV4=true  
> HOSTNAME=dodge.u.edu  
> DOMAINNAME=u.edu  
> GATEWAY=172.16.0.1  
> GATEWAYDEV=eth1  

После установки этих переменных сетевой скрипт настроит сетевые устройства. Эти файлы устанавливают переменные среды для двух карт Ethernet. Они называют устройства и дают им их IP-адреса, сетевые маски и широковещательные адреса. (Обратите внимание, что переменная BOOTPROTO остается определенной для второй карты.) Опять же, этот компьютер будет иметь стандартный файл конфигурации обратной связи.

_/etc/sysconfig/сетевые скрипты/ifcfg-eth0_

> DEVICE=eth0  
> IPADDR=172.16.1.1  
> NMASK=255.255.255.0  
> NETWORK=172.16.1.0  
> BCAST=172.16.1.255  
> ONBOOT=да  
> BOOTPROTO=статический

_/etc/sysconfig/сетевые скрипты/ifcfg-eth1_

> DEVICE=eth1  
> IPADDR=172.16.0.7  
> NMASK=255.255.0.0  
> NETWORK=172.16.0.0  
> BCAST=172.16.255.255  
> ONBOOT=да

После установки этих переменных сетевой сценарий запустит программу _ifconfig_ для запуска каждого устройства. Наконец, сценарий запустит программу _маршрутизации_ , чтобы добавить маршрут по умолчанию ( GATEWAY ) и любые другие указанные маршруты (которые можно найти в _файле /etc/sysconfig/static-routes_ , если таковые имеются). В этом случае снова маршрут по умолчанию является единственным указанным маршрутом, поскольку весь трафик будет идти в сеть, указанную сетевыми масками, или через маршрутизатор по умолчанию для достижения остальной части Интернета.

## 3.4   Функции Linux и сетевых программ

Ниже приведены алфавитные списки функций ядра Linux и сетевых программ, которые наиболее важны для инициализации, где они находятся в исходном коде и что они делают. Показанный каталог SOURCES представляет собой каталог, содержащий исходный код для данного сетевого файла _._ Исполняемые файлы должны поставляться с любым дистрибутивом Linux, но исходный код, вероятно, не входит.

Эти исходные коды доступны в виде пакета, отдельного от исходного кода ядра (Red Hat Linux использует диспетчер пакетов _rpm_ ). Приведенный ниже код взят из пакета исходного кода _net-tools-1.53-1_ от 29 августа 1999 г. Пакеты доступны на веб-странице _www.redhat.com/apps/download ._ После загрузки _root_ может установить пакет с помощью следующих команд (начиная с каталога с пакетом):

> rpm -i net-tools-1.53-1.src.rpm  
> cd /usr/src/redhat/ИСТОЧНИКИ  
> tar xzf net-tools-1.53.tar.gz

Это создает каталог _/usr/src/redhat/SOURCES/net-tools-1.53_ ​​и заполняет его исходным кодом программ _ifconfig_ и _route_ (среди прочего). Этот процесс должен быть похожим (но, несомненно, не совсем таким же) для других дистрибутивов Linux.

### 3.4.1   _Ифконфиг_

devinet_ioctl() — net/ipv4/devinet.c (398)
  создает структуру информационного запроса (ifreq) и копирует данные из
      пользователь в пространство ядра
  если это запрос или действие уровня INET, выполняет его
  если это запрос или действие устройства, вызывает функцию устройства
  копирует ifreq обратно в память пользователя
  возвращает 0 в случае успеха
>>> ifconfig main() - SOURCES/ifconfig.c (478)
  открывает сокет (только для использования с функцией ioctl)
  ищет аргументы командной строки для опций
  вызывает if_print(), если не было аргументов или был единственный аргумент
      это имя интерфейса
  перебирает оставшиеся аргументы, устанавливает или очищает флаги или
      вызов ioctl() для установки переменных интерфейса
if_fetch() — ИСТОЧНИКИ/lib/interface.c (338)
  заполняет структуру интерфейса несколькими вызовами ioctl() для
      флаги, аппаратный адрес, метрика, MTU, карта и адресная информация
if_print() — ИСТОЧНИКИ/ifconfig.c (121)
  вызывает ife_print() для заданного (или всех) интерфейса(ов)
      (вызывает if_readlist() для заполнения списка структур при необходимости и
      затем отображает информацию о каждом интерфейсе)
if_readlist() — ИСТОЧНИКИ/lib/interface.c (261)
  открывает /proc/net/dev и анализирует данные в структурах интерфейса
  вызывает add_interface() для каждого устройства, чтобы поместить структуры в список
inet_ioctl() - net/ipv4/af_inet.c (855)
  выполняет переключение на основе переданной команды
      [для ifconfig вызывает devinet_ioctl()]
иоктл () -
  переходит к соответствующей процедуре обработчика [= inet_ioctl()]

### 3.4.2   _маршрут_

INET_rinput() — SOURCES/lib/inet_sr.c (305)
  проверяет наличие ошибок (не может очистить таблицу или изменить кеш маршрутизации)
  вызывает INET_setroute()
INET_rprint() — ИСТОЧНИКИ/lib/inet_gr.c (442)
  если флаг FIB установлен, вызывает rprint_fib()
      (читает, анализирует и отображает содержимое /proc/net/route)
  если флаг CACHE установлен, вызывает rprint_cache()
      (читает, анализирует и отображает содержимое /proc/net/rt_cache)
INET_setroute() — ИСТОЧНИК/lib/inet_sr.c (57)
  устанавливает, является ли маршрут к сети или к хосту
  проверяет, является ли адрес законным
  перебирает аргументы, заполняя структуру rtentry
  проверяет наличие конфликтов сетевых масок
  создает временный сокет
  вызывает ioctl() с rtentry для добавления или удаления маршрута
  закрывает сокет и возвращает 0
иоктл () -
  переходит к соответствующей процедуре обработчика [= ip_rt_ioctl()]
ip_rt_ioctl() — net/ipv4/fib_frontend.c (246)
  преобразует переданные параметры в запись таблицы маршрутизации (struct rtentry)
  при удалении маршрута:
    вызывает fib_get_table(), чтобы найти соответствующую таблицу
    вызывает функцию table->tb_delete(), чтобы удалить его
  если добавить маршрут
    вызывает fib_net_table(), чтобы найти точку входа
    вызывает функцию table->tb_insert() для добавления записи
  возвращает 0 в случае успеха
>>> route main() - SOURCES/route.c (106)
  вызывает процедуры инициализации, которые устанавливают функции печати и редактирования
  получает и анализирует параметры командной строки (воздействует на некоторые параметры
      непосредственно путем установки флагов или отображения информации)
  проверяет параметры (распечатывает сообщение об использовании, если есть ошибка)
  если нет вариантов, вызывает route_info()
  если есть возможность добавлять, удалять или сбрасывать маршруты,
      вызывает route_edit() с переданными параметрами
  если опция недействительна, печатает сообщение об использовании
  возвращает результат
route_edit() — ИСТОЧНИКИ/lib/setroute.c (69)
  вызывает get_aftype() для перевода семейства адресов из текста в указатель
  проверяет наличие ошибок (неподдерживаемое или несуществующее семейство)
  вызывает функцию семейства адресов rinput() [= INET_rinput()]
route_info() — ИСТОЧНИКИ/lib/getroute.c (72)
  вызывает get_aftype() для перевода семейства адресов из текста в указатель
  проверяет наличие ошибок (неподдерживаемое или несуществующее семейство)
  вызывает функцию семейства адресов rprint() [= INET_rprint()]

# Глава 4  
Соединения

В этой главе представлен процесс подключения. Он предоставляет обзор процесса подключения, описание структур данных сокетов, введение в систему маршрутизации и резюмирует код реализации в ядре.

## 4.1   Обзор

Простейшая форма сети — это соединение между двумя хостами. На каждом конце приложение получает сокет, устанавливает соединение на транспортном уровне, а затем отправляет или получает пакеты. В Linux сокет фактически состоит из двух структур сокета (одна содержит другую). Когда приложение создает сокет, он инициализируется, но пуст. Когда сокет устанавливает соединение (независимо от того, включает ли это трафик с другой стороны), уровень IP определяет маршрут к удаленному хосту и сохраняет эту информацию в сокете. С этого момента весь трафик, использующий это соединение, использует этот маршрут — отправленные пакеты будут проходить через правильное устройство и соответствующие маршрутизаторы к удаленному хосту, а полученные пакеты появятся в очереди сокета.

## 4.2   Структуры сокетов

В Linux есть две основные структуры сокетов: общие сокеты BSD и сокеты INET, специфичные для IP. Они сильно взаимосвязаны; сокет BSD имеет сокет INET в качестве члена данных, а сокет INET имеет сокет BSD в качестве своего владельца.

Сокеты BSD имеют тип struct socket , как определено в _include/linux/socket.h_ . Переменные сокета BSD обычно называются sock или его разновидностью. В этой структуре всего несколько записей, самые важные из которых описаны ниже.

-   struct proto_ops *ops — эта структура содержит указатели на специальные функции протокола для реализации общего поведения сокета. Например, ops- > sendmsg указывает на функцию inet_sendmsg() .
-   _struct inode *inode_ — эта структура указывает на индексный дескриптор файла, связанный с данным сокетом.
-   struct sock *sk — это сокет INET, связанный с этим сокетом.

Сокеты INET имеют тип struct sock , определенный в _include/net/sock.h_ . Переменные сокета INET обычно называются sk или его разновидностью. Эта структура имеет много записей, связанных с широким спектром использования; есть много хаков и полей, зависящих от конфигурации. Наиболее важные члены данных описаны ниже:

-   struct sock *next, *pprev - все сокеты связаны различными протоколами, поэтому эти указатели позволяют протоколам проходить через них.
-   struct dst_entry *dst_cache — это указатель на маршрут к другой стороне сокета (пункт назначения для отправляемых пакетов).
-   struct sk_buff_head receive_queue — это заголовок очереди приема.
-   struct sk_buff_head write_queue — это заголовок очереди отправки.
-   __u32 saddr - адрес источника (в Интернете) для этого сокета.
-   struct sk_buff_head back_log,error_queue — дополнительные очереди для отставания пакетов (не путать с основной очередью отставания) и ошибочные пакеты для данного сокета.
-   struct proto *prot — эта структура содержит указатели на специфические функции протокола транспортного уровня. Например, prot- > recvmsg может указывать на функцию tcp_v4_recvmsg() .
-   структура объединения tcp_op af_tcp; tp_pinfo — параметры TCP для этого сокета.
-   struct socket *sock — родительский сокет BSD.
-   Обратите внимание, что в этой структуре гораздо больше полей; это только самые важные и неочевидные. Остальные либо не очень важны, либо имеют имена, говорящие сами за себя (например, ip_ttl — это счетчик IP Time-To-Live).

## 4.3   Сокеты и маршрутизация

Сокеты проходят процесс поиска маршрутизации только один раз для каждого пункта назначения (во время соединения). Поскольку сокеты Linux так тесно связаны с IP, они содержат маршруты к другому концу соединения (в переменной sock-> sk-> dst_cache ). Транспортные протоколы вызывают функцию ip_route_connect() для определения маршрута от хоста к хосту в процессе соединения; после этого предполагается, что маршрут не изменится (хотя путь, на который указывает dst_cache, действительно может измениться). Сокету не нужно постоянно просматривать таблицу маршрутизации для каждого отправляемого или получаемого пакета; он пытается снова, только если происходит что-то неожиданное (например, соседний компьютер выходит из строя). Это преимущество использования соединений.

## 4.4   Процессы подключения

### 4.4.1   Установление соединений

Прикладные программы устанавливают сокеты с помощью ряда системных вызовов, которые ищут удаленный адрес, устанавливают сокет, а затем подключаются к машине на другом конце.

    /* поиск хоста */
    сервер = gethostbyname (ИМЯ_СЕРВЕРА);
    /* получить сокет */
    sockfd = сокет (AF_INET, SOCK_STREAM, 0);
    /* устанавливаем адрес */
    адрес.sin_family = AF_INET;
    address.sin_port = htons(PORT_NUM);
    memcpy(&address.sin_addr,server->h_addr,server->h_length);
    /* подключаемся к серверу */
    connect(sockfd, &address, sizeof(address));

Функция gethostbyname () просто ищет хост (например, ``viper.cs.u.edu'') и возвращает структуру, содержащую интернет-адрес (IP). Это имеет очень мало общего с маршрутизацией (только постольку, поскольку хосту может потребоваться запросить сеть для поиска адреса) и представляет собой просто перевод из удобочитаемой формы (текст) в совместимую с компьютером форму (беззнаковое 4-байтовое целое число). ).

Вызов socket () более интересен. Он создает объект сокета с соответствующим типом данных ( sock для сокетов INET) и инициализирует его. Сокет содержит информацию об индексе и указатели протокола для различных сетевых функций. Он также устанавливает значения по умолчанию для очередей (входящие, исходящие, ошибок и невыполненных работ), фиктивную информацию заголовка для сокетов TCP и различную информацию о состоянии.

Наконец, вызов connect() переходит к процедуре соединения, зависящей от протокола (например, tcp_v4_connect() или udp_connect() ). UDP просто устанавливает маршрут к месту назначения (поскольку виртуального соединения нет). TCP устанавливает маршрут, а затем начинает процесс TCP-соединения, отправляя пакет с соответствующим установленным флагом соединения и окна.

### 4.4.2   Прохождение вызовов сокетов

-   Проверить наличие ошибок в звонке
-   Создать (выделить память) объект сокета
-   Поместить сокет в список INODE
-   Установить указатели на функции протокола (INET)
-   Хранить значения для типа сокета и семейства протоколов
-   Установить состояние сокета как закрытое
-   Инициализировать очереди пакетов

### 4.4.3   Пошаговое подключение к звонку

-   Проверить на ошибки
-   Определить маршрут к месту назначения:
    
    -   Проверьте таблицу маршрутизации на наличие существующей записи (верните ее, если она существует)
    -   Найдите пункт назначения в FIB
    -   Создать новую запись в таблице маршрутизации
    -   Поместить запись в таблицу маршрутизации и вернуть ее
    
-   Сохранить указатель на запись маршрутизации в сокете
-   Функция соединения, специфичная для протокола вызова (например, отправка пакета TCP-соединения)
-   Установить состояние сокета на установленное

### 4.4.4   Закрытие соединений

Закрыть сокет довольно просто. Приложение вызывает метод close() для сокета, который становится вызовом функции sock_close() . Это изменяет состояние сокета на отключение и вызывает функцию освобождения члена данных (сокета INET). Сокет INET, в свою очередь, очищает свои очереди и вызывает функцию закрытия транспортного протокола, tcp_v4_close() или udp_close() . Они выполняют любые необходимые действия (функции TCP могут отправлять пакеты для завершения соединения TCP), а затем очищают все оставшиеся структуры данных. Обратите внимание, что для маршрутизации никаких изменений не производится; (теперь пустой) сокет больше не имеет ссылки на пункт назначения, и запись в кэше маршрутизации останется до тех пор, пока она не будет освобождена из-за неиспользования.

### 4.4.5   Закрытие обхода

-   Проверить на наличие ошибок (существует ли сокет?)
-   Измените состояние сокета на отключение, чтобы предотвратить дальнейшее использование
-   Выполните любые действия по закрытию протокола (например, отправьте TCP-пакет с установленным битом FIN)
-   Свободная память для структур данных сокетов (TCP/UDP и INET)
-   Удалить сокет из списка INODE

## 4.5   Функции Linux

Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для соединений, где они находятся в исходном коде и что они делают. Чтобы следовать вызовам функций для создания сокета, начните с sock_create() . Чтобы следовать вызовам функций для закрытия сокета, начните с sock_close() .

destroy_sock — net/ipv4/af_inet.c (195)
  удаляет любые таймеры
  вызывает любые специфичные для протоколов функции уничтожения
  освобождает очереди сокетов
  освобождает саму структуру сокета
fib_lookup() — include/net/ip_fib.h (153)
  вызывает tb_lookup() [= fn_hash_lookup()] для локальных и основных таблиц
  возвращает маршрут или недостижимую ошибку
fn_hash_lookup() — net/ipv4/fib_hash.c (261)
  ищет и возвращает маршрут к адресу
inet_create() - net/ipv4/af_inet.c (326)
  вызывает sk_alloc(), чтобы получить память для sock
  инициализирует структуру носка:
    устанавливает структуру прототипа в соответствующие значения для TCP или UDP
    вызывает sock_init_data()
    устанавливает семью, протокол и т. д. переменные
  вызывает функцию инициализации протокола (если есть)
inet_release() — net/ipv4/af_inet.c (463)
  изменяет состояние сокета на отключение
  вызывает ip_mc_drop_socket для выхода из группы многоадресной рассылки (при необходимости)
  устанавливает владение элементом данных сокета в NULL
  вызывает sk->prot->close() [=TCP/UDP_close()]
ip_route_connect() — include/net/route.h (140)
  вызывает ip_route_output() для получения адреса назначения
  возвращает, если вызов работает или генерирует ошибку
  в противном случае очищает указатель маршрута и повторяет попытку
ip_route_output() — net/ipv4/route.c (1664)
  вычисляет хеш-значение для адреса
  проходит через таблицу (начиная с хэша) для сопоставления адресов и TOS
  если есть совпадение, обновляет статистику и возвращает запись маршрута
  иначе вызывает ip_route_output_slow()
ip_route_output_slow() — net/ipv4/route.c (1421)
  если исходный адрес известен, ищет выходное устройство
  если адрес назначения неизвестен, устанавливает петлю
  вызывает fib_lookup() для поиска маршрута в FIB
  выделяет память для новой записи в таблице маршрутизации
  инициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,
      флаги
  вызывает rt_set_nexthop(), чтобы найти следующий пункт назначения
  возвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации
rt_intern_hash() — net/ipv4/route.c (526)
  перебирает rt_hash_table (начиная с хеш-значения)
  если ключи совпадают, поместите запись rtable в переднее ведро
  иначе поместите запись rtable в хеш-таблицу по адресу hash
>>> sock_close() - net/socket.c (476)
  проверяет, существует ли сокет (может быть нулевым)
  вызывает sock_fasync() для удаления сокета из асинхронного списка
  вызывает sock_release()
>>> sock_create() - net/socket.c (571)
  проверяет параметры
  вызывает sock_alloc() для получения доступного inode для сокета и
      инициализировать его
  устанавливает тип сокета-> (на SOCK_STREAM, SOCK_DGRAM...)
  вызывает net_family->create() [= inet_create()] для построения структуры sock
  возвращает установленный сокет
sock_init_data() - net/core/sock.c (1018)
  инициализирует все общие значения носка
sock_release() - сеть/socket.c (309)
  меняет состояние на отключение
  вызывает sock->ops->release() [= inet_release()]
  вызывает iput() для удаления сокета из списка инодов
sys_socket() — сеть/socket.c (639)
  вызывает sock_create() для получения и инициализации сокета
  вызывает get_fd() для назначения fd сокету
  устанавливает socket->file в fcheck() (указатель на файл)
  вызывает sock_release(), если что-то не получается
tcp_close() - сеть/ipv4/tcp.c (1502)
  проверить на ошибки
  извлекает и отбрасывает все пакеты из входящей очереди
  отправляет сообщения адресату, чтобы закрыть соединение (если требуется)
tcp_connect() — сеть/ipv4/tcp_output.c (910)
  завершает пакет соединения с соответствующими битами и установленными размерами окна
  помещает пакет в очередь вывода сокета
  вызывает tcp_transmit_skb() для отправки пакета, инициируя TCP-соединение
tcp_v4_connect() - сеть/ipv4/tcp_ipv4.c (571)
  проверяет на ошибки
  вызывает ip_route_connect() для поиска маршрута к месту назначения
  создает пакет подключения  
  вызывает tcp_connect() для отправки пакета
udp_close() - сеть/ipv4/udp.c (954)
  вызывает udp_v4_unhash() для удаления сокета из списка сокетов
  вызывает destroy_sock()
udp_connect() - сеть/ipv4/udp.c (900)
  вызывает ip_route_connect() для поиска маршрута к месту назначения
  обновляет сокет с адресами и портами источника и назначения
  изменяет состояние сокета на установленное
  сохраняет маршрут назначения в sock->dst_cache

# Глава 5  
Отправка сообщений

В этой главе представлена ​​сторона отправки сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.

## 5.1   Обзор

![s_tx.gif](https://www.cs.unh.edu/cnrg/people/gherrin/s_tx.gif)  

Рисунок 5.1: Передача сообщения.

Исходящее сообщение начинается с системного вызова приложения для записи данных в сокет. Сокет проверяет свой собственный тип соединения и вызывает соответствующую процедуру отправки (обычно INET). Функция отправки проверяет состояние сокета, проверяет его тип протокола и отправляет данные в процедуру транспортного уровня (такую ​​как TCP или UDP). Этот протокол создает новый буфер для исходящего пакета (буфер сокета или struct sk_buff skb).), копирует данные из буфера приложения и заполняет информацию своего заголовка (такую ​​как номер порта, параметры и контрольная сумма) перед передачей нового буфера на сетевой уровень (обычно IP). Функции отправки IP заполняют большую часть буфера собственными заголовками протокола (такими как IP-адрес, параметры и контрольная сумма). При необходимости он также может фрагментировать пакет. Затем уровень IP передает пакет функции уровня канала, которая перемещает пакет в очередь xmit отправляющего устройства и гарантирует, что устройство знает, что у него есть трафик для отправки. Наконец, устройство (такое как сетевая карта) сообщает шине о необходимости отправить пакет.

## 5.2   Отправка обхода

### 5.2.1   Запись в сокет

-   Запись данных в сокет (приложение)
-   Заполните заголовок сообщения расположением данных (сокет)
-   Проверить наличие основных ошибок — привязан ли сокет к порту? может ли сокет отправлять сообщения? что-то не так с розеткой?
-   Передайте заголовок сообщения соответствующему транспортному протоколу (сокет INET).

### 5.2.2   Создание пакета с UDP

-   Проверить на ошибки — данные слишком велики? это UDP соединение?
-   Убедитесь, что маршрут к месту назначения существует (вызовите процедуры IP-маршрутизации, если маршрут еще не установлен; сбой, если маршрута нет)
-   Создайте заголовок UDP (для пакета)
-   Вызов функции построения и передачи IP

### 5.2.3   Создание пакета с TCP

-   Проверить соединение - установлено? он открыт? розетка работает?
-   Проверяйте и комбинируйте данные с частичными пакетами, если это возможно
-   Создать буфер пакетов
-   Скопируйте полезную нагрузку из пользовательского пространства
-   Добавьте пакет в исходящую очередь
-   Встроить текущий заголовок TCP в пакет (с ACK, SYN и т. д.)
-   Вызов функции IP-передачи

### 5.2.4   Упаковка пакета в IP

-   Создать буфер пакетов (при необходимости — UDP)
-   Узнать маршрут до пункта назначения (при необходимости - TCP)
-   Заполнить IP-заголовок пакета
-   Скопируйте заголовок транспорта и полезную нагрузку из пользовательского пространства.
-   Отправьте пакет в функцию вывода устройства целевого маршрута.

### 5.2.5   Передача пакета

-   Поместите пакет в очередь вывода устройства
-   Разбудить устройство
-   Подождите, пока планировщик запустит драйвер устройства.
-   Протестируйте носитель (устройство)
-   Отправить заголовок ссылки
-   Скажите шине передать пакет по среде

## 5.3   Функции Linux

Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для трафика сообщений, где они находятся в исходном коде и что они делают. Чтобы отслеживать вызовы функций, начните с sock_write() .

dev_queue_xmit() — net/core/dev.c (579)
  вызывает start_bh_atomic()
  если у устройства есть очередь
    вызывает enqueue() для добавления пакета в очередь
    вызывает qdisc_wakeup() [= qdisc_restart()] для пробуждения устройства
  иначе вызывает hard_start_xmit()
  вызывает end_bh_atomic()
DEVICE->hard_start_xmit() - зависит от устройства, drivers/net/DEVICE.c
  проверяет, открыта ли среда
  отправляет заголовок
  говорит шине отправить пакет
  обновляет статус
inet_sendmsg() — net/ipv4/af_inet.c (786)
  извлекает указатель на сокет sock
  проверяет сокет, чтобы убедиться, что он работает
  проверяет указатель протокола
  возвращает sk->prot[tcp/udp]->sendmsg()
ip_build_xmit-net/ipv4/ip_output.c (604)
  вызывает sock_alloc_send_skb() для установки памяти для skb
  устанавливает заголовок skb
  вызывает getfrag() [= udp_getfrag()] для копирования буфера из пространства пользователя
  возвращает rt->u.dst.output() [= dev_queue_xmit()]
ip_queue_xmit() - net/ipv4/ip_output.c (234)
  ищет маршрут
  строит IP-заголовок
  фрагменты при необходимости
  добавляет контрольную сумму IP
  вызывает skb->dst->output() [= dev_queue_xmit()]
qdisc_restart() - net/sched/sch_generic.c (50)
  выталкивает пакет из очереди
  вызывает dev->hard_start_xmit()
  обновляет статус
  если произошла ошибка, запрашивает пакет
sock_sendmsg() - net/socket.c (325)
  вызывает scm_sendmsg() [сообщение управления сокетом]
  вызывает sock->ops[inet]->sendmsg() и уничтожает scm
>>> sock_write() - net/socket.c (399)
  вызывает socki_lookup(), чтобы связать сокет с inode fd/file
  создает и заполняет заголовок сообщения размером данных/адресами
  возвращает sock_sendmsg()
tcp_do_sendmsg() — сеть/ipv4/tcp.c (755)
  ожидает подключения, если необходимо
  вызывает skb_tailroom() и добавляет данные в ожидающий пакет, если это возможно
  проверяет состояние окна
  вызывает sock_wmalloc() для получения памяти для skb
  вызывает csum_and_copy_from_user() для копирования пакета и выполнения контрольной суммы
  вызывает tcp_send_skb()
tcp_send_skb() — сеть/ipv4/tcp_output.c (160)
  вызывает __skb_queue_tail() для добавления пакета в очередь
  вызывает tcp_transmit_skb(), если это возможно
tcp_transmit_skb() — сеть/ipv4/tcp_output.c (77)
  строит заголовок TCP и добавляет контрольную сумму
  вызывает tcp_build_and_update_options()
  проверяет ACK, SYN
  вызывает tp->af_specific[ip]->queue_xmit()
tcp_v4_sendmsg() — сеть/ipv4/tcp_ipv4.c (668)
  проверяет тип IP-адреса, открывает соединение, адреса портов
  возвращает tcp_do_sendmsg()
udp_getfrag() — сеть/ipv4/udp.c (516)
  копирует и вычисляет контрольную сумму буфера из пользовательского пространства
udp_sendmsg() — сеть/ipv4/udp.c (559)
  длина проверок, флаги, протокол
  устанавливает заголовок UDP и адресную информацию
  проверяет мультикаст
  заполняет маршрут
  заполняет оставшуюся часть заголовка
  вызывает ip_build_xmit()
  обновляет статус UDP
  возвращает ошибку

# Глава 6  
Получение сообщений

В этой главе представлена ​​принимающая сторона трафика сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.

## 6.1   Обзор

![r_rx.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_rx.gif)  

Рисунок 6.1: Получение сообщений.

Входящее сообщение начинается с прерывания, когда система уведомляет устройство о готовности сообщения. Устройство выделяет место для хранения и указывает шине поместить сообщение в это пространство. Затем он передает пакет канальному уровню, который помещает его в очередь невыполненных работ и помечает сетевой флаг для следующего запуска "нижней половины".

Нижняя половина — это система Linux, которая сводит к минимуму объем работы, выполняемой во время прерывания. Выполнение большого объема обработки во время прерывания нехорошо именно потому, что это прерывает работающий процесс; вместо этого у обработчиков прерываний есть «верхняя половина» и «нижняя половина». Когда поступает прерывание, запускается верхняя половина и выполняет любые критические операции, такие как перемещение данных из очереди устройства в память ядра. Затем он помечает флаг, сообщающий ядру, что есть еще работа, когда у процессора есть время, и возвращает управление текущему процессу. В следующий раз, когда планировщик процессов запустится, он увидит флаг, проделает дополнительную работу и только затем запланирует любые нормальные процессы.

Когда планировщик процессов видит, что есть сетевые задачи, он запускает нижнюю половину сети. Эта функция извлекает пакеты из очереди ожидания, сопоставляет их с известным протоколом (обычно IP) и передает их функции приема этого протокола. Уровень IP проверяет пакет на наличие ошибок и направляет его; пакет попадет в исходящую очередь (если он предназначен для другого хоста) или до транспортного уровня (например, TCP или UDP). Этот уровень снова проверяет наличие ошибок, ищет сокет, связанный с портом, указанным в пакете, и помещает пакет в конец очереди приема этого сокета.

Как только пакет окажется в очереди сокета, сокет разбудит процесс приложения, которому он принадлежит (при необходимости). Затем этот процесс может выполнить или вернуться из системного вызова чтения , который копирует данные из пакета в очереди в свой собственный буфер. (Процесс также может пока ничего не делать, если он не ждал пакет, и получить данные из очереди, когда они ему понадобятся.)

## 6.2   Получение обхода

### 6.2.1   Чтение из сокета (Часть I)

-   Попробуйте прочитать данные из сокета (приложения)
-   Заполните заголовок сообщения расположением буфера (сокета)
-   Проверить наличие основных ошибок — привязан ли сокет к порту? может ли сокет принимать сообщения? что-то не так с розеткой?
-   Передайте заголовок сообщения соответствующему транспортному протоколу (сокет INET).
-   Спите, пока не будет достаточно данных для чтения из сокета (TCP/UDP)

### 6.2.2   Получение пакета

-   Разбудить принимающее устройство (прерывание)
-   Протестируйте носитель (устройство)
-   Получите заголовок ссылки
-   Выделить место для пакета
-   Скажите шине поместить пакет в буфер
-   Поместите пакет в очередь ожидания
-   Установите флаг для запуска нижней половины сети, когда это возможно
-   Вернуть управление текущему процессу

### 6.2.3   Запуск сети "Нижняя половина"

-   Запустите нижнюю половину сети (планировщик)
-   Отправлять любые ожидающие пакеты для предотвращения прерываний (нижняя половина)
-   Перебрать все пакеты в очереди невыполненных работ и передать пакет до его протокола приема в Интернете — IP.
-   Снова очистить очередь отправки
-   Выход из нижней половины

### 6.2.4   Развертка пакета в IP

-   Проверить пакет на наличие ошибок - слишком короткий? слишком долго? неверная версия? ошибка контрольной суммы?
-   Дефрагментация пакета при необходимости
-   Получите маршрут для пакета (может быть для этого хоста или может потребоваться переадресация)
-   Отправьте пакет в подпрограмму обработки назначения (прием TCP или UDP или, возможно, повторная передача на другой хост)

### 6.2.5   Прием пакета в UDP

-   Проверьте заголовок UDP на наличие ошибок
-   Сопоставить пункт назначения с сокетом
-   Отправить сообщение об ошибке обратно, если такого сокета нет
-   Поместить пакет в соответствующую очередь приема сокета
-   Разбудить любые процессы, ожидающие данных из этого сокета

### 6.2.6   Прием пакета в TCP

-   Проверить последовательность и флаги; сохранить пакет в правильном месте, если это возможно
-   Если он уже получен, немедленно отправьте ACK и отбросьте пакет.
-   Определить, какой пакет сокета принадлежит
-   Поместить пакет в соответствующую очередь приема сокета
-   Пробуждение и процессы, ожидающие данных из этого сокета

### 6.2.7   Чтение из сокета (Часть II)

-   Просыпаться, когда данные готовы (сокет)
-   Функция приема на транспортном уровне вызова
-   Переместить данные из очереди приема в пользовательский буфер (TCP/UDP)
-   Вернуть данные и управление в приложение (сокет)

## 6.3   Функции Linux

Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для получения трафика, где они находятся в исходном коде и что они делают. Чтобы отслеживать вызовы функций из сети вверх, начните с DEVICE_rx() . Чтобы отслеживать вызовы функций из приложения вниз, начните с sock_read() .

>>> DEVICE_rx() - зависит от устройства, drivers/net/DEVICE.c
  (получает управление от прерывания)
  выполняет проверки состояния, чтобы убедиться, что он должен получать
  вызывает dev_alloc_skb(), чтобы зарезервировать место для пакета
  получает пакет от системной шины
  вызывает eth_type_trans() для определения типа протокола
  вызывает netif_rx()
  обновляет статус карты
  (возврат из прерывания)
inet_recvmsg() — net/ipv4/af_inet.c (764)
  извлекает указатель на сокет sock
  проверяет сокет, чтобы убедиться, что он принимает
  проверяет указатель протокола
  возвращает sk->prot[tcp/udp]->recvmsg()
ip_rcv() - сеть/ipv4/ip_input.c (395)
  проверяет пакет на наличие ошибок:
    недопустимая длина (слишком короткая или слишком длинная)
    неправильная версия (не 4)
    неверная контрольная сумма
  вызывает __skb_trim() для удаления заполнения
  дефрагментирует пакет при необходимости
  вызывает ip_route_input() для маршрутизации пакета
  проверяет и обрабатывает параметры IP
  возвращает skb->dst->input() [= tcp_rcv,udp_rcv()]
net_bh() - net/core/dev.c (835)
  (запускается планировщиком)
  если есть пакеты, ожидающие выхода, вызывает qdisc_run_queues()
      (см. раздел отправки)
  пока очередь невыполненных работ не пуста
    пусть другие нижние половины бегут
    вызовите skb_dequeue(), чтобы получить следующий пакет
    если пакет для кого-то другого (FASTROUTED) ставится в очередь на отправку
    прокручивать списки протоколов (отводы и основной) для соответствия типу протокола
    вызовите pt_prev->func() [= ip_rcv()] для передачи пакета соответствующему
        протокол
  вызовите qdisc_run_queues() для сброса вывода (при необходимости)
netif_rx() - net/core/dev.c (757)
  ставит время в skb->stamp
  если очередь невыполненных работ слишком заполнена, отбрасывает пакет
  еще
    вызывает skb_queue_tail() для помещения пакета в очередь ожидания
    отмечает нижнюю половину для последующего выполнения
sock_def_readable() - net/core/sock.c (989)
  вызывает wake_up_interruptible(), чтобы поместить ожидающий процесс в очередь выполнения
  вызывает sock_wake_async() для отправки SIGIO в процесс сокета
sock_queue_rcv_skb() — include/net/sock.h (857)
  вызывает skb_queue_tail() для помещения пакета в очередь приема сокета
  вызывает sk->data_ready() [= sock_def_readable()]
>>> sock_read() - net/socket.c (366)
  устанавливает заголовки сообщений
  возвращает sock_recvmsg() с результатом чтения
sock_recvmsg() — сеть/socket.c (338)
  читает пакет управления сокетом (scm) или пакет
      вызов sock->ops[inet]->recvmsg()
tcp_data() — сеть/ipv4/tcp_input.c (1507)
  сжимает очередь приема при необходимости
  вызывает tcp_data_queue() для постановки пакета в очередь
  вызывает sk->data_ready() для пробуждения сокета
tcp_data_queue() — net/ipv4/tcp_input.c (1394)
  если пакет не по порядку:
    если старый, сразу выбрасывает
    иначе вычисляет соответствующее место хранения
  вызывает __skb_queue_tail() для помещения пакета в очередь приема сокета
  обновляет состояние подключения
tcp_rcv_installed() - net/ipv4/tcp_input.c (1795)
  если быстрый путь
    проверяет все флаги и информацию заголовка
    отправляет подтверждение
    вызывает _skb_queue_tail() для помещения пакета в очередь приема сокета
  иначе (медленный путь)
    если не по порядку, отправляет ACK и отбрасывает пакет
    проверить наличие FIN, SYN, RST, ACK
    вызывает tcp_data() для постановки пакета в очередь
    отправляет подтверждение
tcp_recvmsg() — сеть/ipv4/tcp.c (1149)
  проверяет на ошибки
  подождите, пока не будет доступен хотя бы один пакет
  очищает сокет, если соединение закрыто
  вызывает memcpy_toiovec() для копирования полезной нагрузки из буфера сокета в
      пользовательское пространство
  вызывает cleanup_rbuf() для освобождения памяти и отправки ACK при необходимости
  вызывает remove_wait_queue() для пробуждения процесса (при необходимости)
udp_queue_rcv_skb() — сеть/ipv4/udp.c (963)
  вызывает sock_queue_rcv_skb()
  обновляет статус UDP (освобождает skb, если очередь не удалась)
udp_rcv() - сеть/ipv4/udp.c (1062)
  получает заголовок UDP, обрезает пакет, проверяет контрольную сумму (при необходимости)
  проверяет мультикаст
  вызывает udp_v4_lookup() для сопоставления пакета с сокетом
  если сокет не найден, отправьте сообщение ICMP обратно, освободите skb и остановите
  вызывает udp_deliver() [= udp_queue_rcv_skb()]
udp_recvmsg() — сеть/ipv4/udp.c (794)
  вызывает skb_recv_datagram() для получения пакета из очереди
  вызывает skb_copy_datagram_iovec() для перемещения полезной нагрузки из буфера сокета
      в пространство пользователя
  обновляет метку времени сокета
  заполняет исходную информацию в заголовке сообщения
  освобождает память пакетов

# Глава 7  
IP-переадресация

В этой главе представлена ​​чистая сторона маршрутизации (посредством IP-переадресации) трафика сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.

## 7.1   Обзор

См. Рисунок [7.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#f_fwd) для абстрактной схемы процесса пересылки. (По сути, это комбинация процессов получения и отправки.)

![f_fwd.gif](https://www.cs.unh.edu/cnrg/people/gherrin/f_fwd.gif)  

Рисунок 7.1: IP-переадресация.

Переадресованный пакет поступает с прерыванием, когда система уведомляет устройство о готовности сообщения. Устройство выделяет место для хранения и указывает шине поместить сообщение в это пространство. Затем он передает пакет канальному уровню, который помещает его в очередь невыполненных работ, помечает сетевой флаг для следующего выполнения "нижней половины" и возвращает управление текущему процессу.

Когда планировщик процессов запускается в следующий раз, он видит, что есть сетевые задачи, которые нужно выполнить, и запускает ``нижнюю половину'' сети. Эта функция извлекает пакеты из очереди ожидания, сопоставляет их с IP и передает их функции получения. Уровень IP проверяет пакет на наличие ошибок и направляет его; пакет будет подниматься на транспортный уровень (например, TCP или UDP, если он предназначен для этого хоста) или в боковом направлении к функции IP-пересылки. В рамках функции пересылки IP проверяет пакет и отправляет сообщение ICMP обратно отправителю, если что-то не так. Затем он копирует пакет в новый буфер и при необходимости фрагментирует его.

Наконец, уровень IP передает пакет функции уровня канала, которая перемещает пакет в очередь xmit отправляющего устройства и гарантирует, что устройство знает, что у него есть трафик для отправки. Наконец, устройство (такое как сетевая карта) сообщает шине о необходимости отправить пакет.

## 7.2   Прохождение IP Forward Walk-Through

### 7.2.1   Получение пакета

-   Разбудить принимающее устройство (прерывание)
-   Протестируйте носитель (устройство)
-   Получите заголовок ссылки
-   Выделить место для пакета
-   Скажите шине поместить пакет в буфер
-   Поместите пакет в очередь ожидания
-   Установите флаг для запуска нижней половины сети, когда это возможно
-   Вернуть управление текущему процессу

### 7.2.2   Запуск сети "Нижняя половина"

-   Запустите нижнюю половину сети (планировщик)
-   Отправлять любые ожидающие пакеты для предотвращения прерываний (net_bh)
-   Перебрать все пакеты в очереди невыполненных работ и передать пакет до его протокола приема в Интернете — IP.
-   Снова очистить очередь отправки
-   Выход из нижней половины

### 7.2.3   Проверка пакета в IP

-   Проверить пакет на наличие ошибок - слишком короткий? слишком долго? неверная версия? ошибка контрольной суммы?
-   Дефрагментация пакета при необходимости
-   Получите маршрут для пакета (может быть для этого хоста или может потребоваться переадресация)
-   Отправьте пакет в подпрограмму обработки назначения (в этом случае повторная передача на другой хост)

### 7.2.4   Пересылка пакета в IP

-   Проверьте поле TTL (и уменьшите его)
-   Проверить пакет на неправильную (нежелательную) маршрутизацию
-   Отправьте ICMP обратно отправителю, если есть какие-либо проблемы
-   Скопируйте пакет в новый буфер и освободите старый
-   Установите любые параметры IP
-   Фрагментировать пакет, если он слишком велик для нового пункта назначения
-   Отправьте пакет в функцию вывода устройства целевого маршрута

### 7.2.5   Передача пакета

-   Поместите пакет в очередь вывода устройства
-   Разбудить устройство
-   Подождите, пока планировщик запустит драйвер устройства.
-   Протестируйте носитель (устройство)
-   Отправить заголовок ссылки
-   Скажите шине передать пакет по среде

## 7.3   Функции Linux

Ниже приведен алфавитный список функций ядра Linux, наиболее важных для IP-переадресации, где они находятся в исходном коде и что они делают. Чтобы следить за вызовами функций, начните с DEVICE_rx().

dev_queue_xmit() — net/core/dev.c (579)
  вызывает start_bh_atomic()
  если у устройства есть очередь
    вызывает enqueue() для добавления пакета в очередь
    вызывает qdisc_wakeup() [= qdisc_restart()] для пробуждения устройства
  иначе вызывает hard_start_xmit()
  вызывает end_bh_atomic()
DEVICE->hard_start_xmit() - зависит от устройства, drivers/net/DEVICE.c
  проверяет, открыта ли среда
  отправляет заголовок
  говорит шине отправить пакет
  обновляет статус
>>> DEVICE_rx() - зависит от устройства, drivers/net/DEVICE.c
  (получает управление от прерывания)
  выполняет проверки состояния, чтобы убедиться, что он должен получать
  вызывает dev_alloc_skb(), чтобы зарезервировать место для пакета
  получает пакет от системной шины
  вызывает eth_type_trans() для определения типа протокола
  вызывает netif_rx()
  обновляет статус карты
  (возврат из прерывания)
ip_finish_output() - включить/net/ip.h (140)
  устанавливает отправляющее устройство в устройство вывода для данного маршрута
  вызывает функцию вывода для пункта назначения [= dev_queue_xmit()]
ip_forward() - сеть/ipv4/ip_forward.c (72)
  проверяет предупреждения маршрутизатора
  если пакет не предназначен для какого-либо хоста, отбрасывает его
  если TTL истек, отбрасывает пакет и отправляет сообщение ICMP обратно
  если нельзя следовать строгому маршруту, отбрасывает пакет и отправляет ICMP
      сообщение обратно отправителю
  при необходимости отправляет ICMP-сообщение о том, что пакет отправителя перенаправлен
  копирует и выпускает старый пакет
  уменьшает TTL
  если есть опции, вызывает ip_forward_options() для их установки
  вызывает ip_send()
ip_rcv() - сеть/ipv4/ip_input.c (395)
  проверяет пакет на наличие ошибок:
    недопустимая длина (слишком короткая или слишком длинная)
    неправильная версия (не 4)
    неверная контрольная сумма
  вызывает __skb_trim() для удаления заполнения
  дефрагментирует пакет при необходимости
  вызывает ip_route_input() для маршрутизации пакета
  проверяет и обрабатывает параметры IP
  возвращает skb->dst->input() [= ip_forward()]
ip_route_input() — net/ipv4/route.c (1366)
  вызывает rt_hash_code() для получения индекса для таблицы маршрутизации
  перебирает таблицу маршрутизации (начиная с хэша), чтобы найти соответствие для пакета
  если он находит совпадение:
    обновляет статистику маршрута (время и использование)
    устанавливает место назначения пакета в запись таблицы маршрутизации
    возвращает успех
  еще
    проверяет многоадресные адреса
    возвращает результат ip_route_input_slow() (попытка маршрутизации)
ip_route_output_slow() — net/ipv4/route.c (1421)
  если исходный адрес известен, ищет выходное устройство
  если адрес назначения неизвестен, настройте loopback
  вызывает fib_lookup() для поиска маршрута
  выделяет память для новой записи в таблице маршрутизации
  инициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,
      флаги
  вызывает rt_set_nexthop(), чтобы найти следующий пункт назначения
  возвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации
ip_send() - включить/net/ip.h (162)
  вызывает ip_fragment(), если пакет слишком велик для устройства
  вызывает ip_finish_output()
net_bh() - net/core/dev.c (835)
  (запускается планировщиком)
  если есть пакеты, ожидающие выхода, вызывает qdisc_run_queues()
      (см. раздел отправки)
  пока очередь невыполненных работ не пуста
    пусть другие нижние половины бегут
    вызовите skb_dequeue(), чтобы получить следующий пакет
    если пакет для кого-то другого (FASTROUTED) ставится в очередь на отправку
    прокручивать списки протоколов (отводы и основной) для соответствия типу протокола
    вызовите pt_prev->func() [= ip_rcv()] для передачи пакета соответствующему
        протокол
  вызовите qdisc_run_queues() для сброса вывода (при необходимости)
netif_rx() - net/core/dev.c (757)
  ставит время в skb->stamp
  если очередь невыполненных работ слишком заполнена, отбрасывает пакет
  еще
    вызывает skb_queue_tail() для помещения пакета в очередь ожидания
    отмечает нижнюю половину для последующего выполнения
qdisc_restart() - net/sched/sch_generic.c (50)
  выталкивает пакет из очереди
  вызывает dev->hard_start_xmit()
  обновляет статус
  если произошла ошибка, запрашивает пакет
rt_intern_hash() — net/ipv4/route.c (526)
  помещает новый маршрут в таблицу маршрутизации

# Глава 8  
Базовая маршрутизация интернет-протокола

В этой главе представлены основы IP-маршрутизации. В нем содержится обзор того, как работает маршрутизация, исследуется, как создаются и обновляются таблицы маршрутизации, и обобщается код реализации в ядре.

## 8.1   Обзор

Linux поддерживает три набора данных маршрутизации — один для компьютеров, которые напрямую подключены к хосту (например, через локальную сеть), и два для компьютеров, которые подключены только косвенно (через IP-сеть). Изучите рисунок  [8.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_overview) , чтобы увидеть, как могут выглядеть записи для компьютера в общем примере.

![r_overview.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_overview.gif)  

Рисунок 8.1: Пример общей таблицы маршрутизации.

Таблица соседей содержит информацию об адресах компьютеров, которые физически подключены к хосту (отсюда и название "сосед"). Он включает информацию о том, какое устройство к какому соседу подключается и какие протоколы использовать при обмене данными. Linux использует протокол разрешения адресов (ARP) для поддержки и обновления этой таблицы; он динамичен в том смысле, что записи добавляются по мере необходимости, но в конечном итоге исчезают, если не используются снова в течение определенного времени. (Однако администраторы могут сделать записи постоянными, если это имеет смысл.)

Linux использует два сложных набора таблиц маршрутизации для поддержки IP-адресов: универсальную информационную базу пересылки (FIB) с указаниями на все возможные адреса и меньший (и более быстрый) кэш маршрутизации с данными о часто используемых маршрутах. Когда IP-пакет должен быть отправлен на удаленный узел, уровень IP сначала проверяет кэш маршрутизации на наличие записи с соответствующим источником, пунктом назначения и типом службы. Если такая запись есть, IP использует ее. Если нет, IP запрашивает маршрутную информацию из более полной (но более медленной) FIB, создает новую запись кэша с этими данными, а затем использует новую запись. В то время как записи FIB являются полупостоянными (обычно они изменяются только при включении или отключении маршрутизаторов), записи кэша остаются только до тех пор, пока не устареют (они не используются в течение "долгого" периода).

## 8.2   Таблицы маршрутизации

Примечание: в этих таблицах есть ссылки на переменные таких типов, как u32 (порядок байтов хоста) и __u32 (порядок байтов сети). В архитектуре Intel они оба эквивалентны unsigned int s, и на самом деле они все равно транслируются (с использованием функции ntohl ); тип просто указывает порядок, в котором хранится содержащееся в нем значение.

### 8.2.1   Таблица соседей

Таблица соседей (структура которой показана на рис.  [8.2](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_neigh_struct) ) содержит информацию о компьютерах, физически связанных с главным компьютером. (Обратите внимание, что в исходном коде используется европейское написание «neighbour».) Записи (обычно) не являются постоянными; эта таблица может не содержать записей (если компьютер в последнее время не пропускал сетевой трафик) или может содержать столько записей, сколько компьютеров физически подключено к его сети (если он недавно связывался со всеми из них). Записи в таблице на самом деле являются другими структурами таблиц, которые содержат адресацию, устройство, протокол и статистическую информацию.

![r_neigh_struct.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_neigh_struct.gif)  

Рисунок 8.2: Отношения структуры данных Neighbor Table.

struct neigh_table *neigh_tables — эта глобальная переменная является указателем на список соседних таблиц; каждая таблица содержит набор общих функций и данных, а также хэш-таблицу конкретной информации о наборе соседей. Это очень подробная низкоуровневая таблица, содержащая конкретную информацию, такую ​​как приблизительное время прохождения сообщений, размеры очередей, указатели устройств и указатели на функции устройств.

Таблица соседей ( struct neigh_table ) Структура - эта структура (элемент списка) содержит общую информацию о соседях и таблицу данных о соседях и данных pneigh. Все компьютеры, подключенные через один тип подключения (например, одну карту Ethernet), будут находиться в одной таблице.

-   struct neigh_table *next — указатель на следующую таблицу в списке.
-   struct neigh_parms parms — структура, содержащая время в пути сообщения, длину очереди и статистическую информацию; на самом деле это глава списка.
-   struct neigh_parms *parms_list — указатель на список информационных структур.
-   struct Neighbor *hash_buckets[] - хеш-таблица соседей, связанных с этой таблицей; есть NEIGH_HASHMASK+1 (32) сегмента.
-   struct pneigh_entry *phash_buckets[] — хэш-таблица структур, содержащих указатели и ключи устройств; имеется PNEIGH_HASHMASK+1 (16) сегментов.
-   Другие поля включают информацию о таймере, указатели функций, блокировки и статистику.

Данные соседа ( struct Neighbor ) Структура - эти структуры содержат конкретную информацию о каждом соседе.

-   struct device *dev - указатель на устройство, которое подключено к этому соседу.
-   __u8 nud_state — флаги состояния; значения могут быть неполными, достижимыми, устаревшими и т. д.; также содержит информацию о состоянии для постоянства и использования ARP.
-   struct hh_cache *hh - указатель на кешированный аппаратный заголовок для передачи этому соседу.
-   struct sk_buff_head arp_queue — указатель на пакеты ARP для этого соседа.
-   Другие поля включают указатели на списки, указатели на функции (таблицы) и статистическую информацию.

### 8.2.2   Информационная база пересылки

![r_fib_gen.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_gen.gif)  

Рисунок 8.3: Концептуальная организация пересылающей информационной базы (FIB).

Информационная база пересылки (FIB) — самая важная структура маршрутизации в ядре; это сложная структура, которая содержит информацию о маршрутизации, необходимую для достижения любого действительного IP-адреса по его сетевой маске. По сути, это большая таблица с общей адресной информацией вверху и очень конкретной информацией внизу. Уровень IP вводит в таблицу адрес назначения пакета и сравнивает его с самой конкретной сетевой маской, чтобы увидеть, совпадают ли они. Если это не так, IP переходит к следующей наиболее общей сетевой маске и снова сравнивает их. Когда он, наконец, находит совпадение, IP копирует «направления» к удаленному хосту в кэш маршрутизации и отправляет пакет по пути. См. рисунки  [8.3](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen)  и  [8.4.](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_struct)для организации и структур данных, используемых в FIB — обратите внимание, что на рис.  [8.3](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen) показаны некоторые другие возможности FIB, такие как два набора сетевой информации для одной зоны, и поэтому он не соответствует общему примеру.)

struct fib_table *local_table, *main_table - эти глобальные переменные являются точками доступа к таблицам FIB; они указывают на структуры таблиц, которые указывают на хеш-таблицы, указывающие на зоны. Содержимое переменной main_table находится в _/proc/net/route_ .

Таблица FIB Структура fib_table — _include/net/ip_fib.h_ — эти структуры содержат таблицы переходов функций, каждая из которых указывает на хеш-таблицу, содержащую информацию о зоне. Обычно их всего один или два.

-   int (*tb_ _functions_ )() — указатели на табличные функции (поиск, удаление, вставка и т. д.), которые при инициализации устанавливаются в fn_hash_function _(_ ) .
-   unsigned char tb_data[0] — указатель на ассоциированную хэш-таблицу FIB (несмотря на ее объявление как массив символов).
-   unsigned char tb_id - идентификатор таблицы; 255 для local_table , 254 для main_table .
-   беззнаковый tb_stamp

Таблица сетевых масок Структура fn_hash - _net/ipv4/fib_hash.c_ - эти структуры содержат указатели на отдельные зоны, организованные по сетевой маске. (Каждая зона соответствует уникальной маске сети.) Существует одна такая маска для каждой таблицы FIB (если только две таблицы не указывают на одну и ту же хеш-таблицу).

-   struct fn_zone *fn_zones[33] — указатели на записи зоны (одна зона для каждого бита в маске; fn_zone[0] указывает на зону для сетевой маски 0x0000, fn_zone[1] указывает на зону для 0x8000 и fn_zone[32] указывает на зону для 0xFFFF.
-   struct fn_zone *fn_zone_list - указатель на первую (самую конкретную) непустую зону в списке; если есть запись для сетевой маски 0xFFFF, она будет указывать на эту зону, в противном случае она может указывать на зону 0xFFF0, 0xFF00, 0xF000 и т. д.

Сетевая зона Структура fn_zone — _net/ipv4/fib_hash.c_ — эти структуры содержат некоторую информацию о хешировании и указатели на хеш-таблицы узлов. Существует один из них для каждой известной сетевой маски.

-   struct fn_zone *fz_next — указатель на следующую непустую зону в хеш-структуре (следующая наиболее общая сетевая маска; например, fn_hash- > fn_zone[28]- > fz_next может указывать на fn_hash- > fn_zone[27] ).
-   struct fib_node **fz_hash — указатель на хеш-таблицу узлов для этой зоны.
-   int fz_nent — количество записей (узлов) в этой зоне.
-   int fx_divisor — количество сегментов в хеш-таблице, связанных с этой зоной; в таблице 16 сегментов для большинства зон (кроме первой зоны - 0000 - петлевого устройства).
-   u32 fz_hashmask — маска для входа в хеш-таблицу узлов; 15 (0x0F) для большинства зон, 0 для зоны 0).
-   int fz_order — индекс этой зоны в родительской структуре fn_hash (от 0 до 32).
-   u32 fz_mask - маска сети зоны, определяемая как ~ ((1<<(32-fz_order))-1) ; например, первый (нулевой) элемент сдвинут влево на 1 32 минус 0 раз (0x10000), минус 1 (0xFFFF) и дополнен (0x0000). Второй элемент имеет сетевую маску 0x8000, следующий 0xC000, следующий 0xE000, 0xF000, 0xF800 и так далее до последнего (32d) элемента с маской 0xFFFF.

Информация о сетевом узле Структура fib_node — _net/ipv4/fib_hash.c_ — эти структуры содержат информацию, уникальную для каждого набора адресов, и указатель на информацию об общих функциях (таких как устройства и протоколы); по одному для каждой известной сети (уникальная комбинация источника/назначения/TOS).

-   struct fib_node *fn_next — указатель на следующий узел.
-   struct fib_info *fn_info — указатель на дополнительную информацию об этом узле (общую для многих узлов).
-   fn_key_t fn_key — ключ хеш-таблицы — младшие 8 бит адреса назначения (или 0 для петлевого устройства).
-   Другие поля содержат конкретную информацию об этом узле (например, fn_tos и fn_state ).

Информация о сетевом протоколе ( fib_info ) Структура — _include/net/ip_fib.h_ — эти структуры содержат информацию о протоколе и оборудовании, специфичную для интерфейса и, следовательно, общую для многих потенциальных зон; несколько сетей могут быть адресованы через один и тот же интерфейс (например, тот, который ведет к остальной части Интернета). Существует один из них для каждого интерфейса.

-   fib_protocol — индекс сетевого протокола (например, IP), используемого для данного маршрута.
-   struct fib_nh fib_nh[0] — содержит указатель на устройство, используемое для отправки или получения трафика по данному маршруту.
-   Другие поля включают указатели на списки, а также статистические и справочные данные (например, fib_refcnt и fib_flags .

![r_fib_struct.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_struct.gif)  

Рисунок 8.4: Отношения данных Базы пересылаемой информации (FIB).

**Пример обхода FIB:**

1.  ip_route_output_slow() (вызывается потому, что маршрут не находится в кэше маршрутизации) устанавливает структуру rt_key с адресом источника 172.16.0.7, адресом назначения 172.16.0.34 и TOS 2.
2.  ip_route_output_slow() вызывает fib_lookup() и передает ему ключ для поиска.
3.  fib_lookup() вызывает local_table- > tb_lookup() (которая является ссылкой на функцию fn_hash_lookup ), чтобы локальная таблица нашла ключ.
4.  fn_hash_lookup() выполняет поиск в хэш-таблице локальной таблицы, начиная с наиболее конкретной зоны - 24 (сетевая маска 255.255.255.0, десятичное число с точками) (на которую указывает переменная fn_zone_list ).
5.  fz_key() создает тестовый ключ, объединяя адрес назначения с сетевой маской зоны и получая значение ключа 172.16.0.0.
6.  fz_chain() выполняет хеш-функцию (см. fn_hash() ) и объединяет это значение с fz_hashmask зоны (15), чтобы получить индекс (6) в хеш-таблице узлов зоны. К сожалению, этот узел пуст; в этой зоне нет возможных совпадений.
7.  fn_hash_lookup() переходит к следующей непустой зоне - 16 (сетевая маска 255.255.0.0, десятичное число с точками) (на которую указывает переменная fz_next текущей зоны ).
8.  fz_key() создает новый тестовый ключ, объединяя адрес назначения и маску сети этой зоны, в результате чего значение ключа равно 172.16.0.0.
9.  fz_chain() выполняет хеш-функцию и объединяет это значение с fz_hashmask зоны (15), чтобы получить индекс (10) в хеш-таблице узлов зоны. В этом слоте есть узел.
10.  fn_hash_lookup() сравнивает свой ключ поиска с ключом узла. Они не совпадают, но значение ключа поиска меньше, чем у ключа узла, поэтому он переходит к следующему узлу.
11.  fn_hash_lookup() сравнивает свой ключ поиска с ключом нового узла. Они совпадают, поэтому он выполняет некоторую проверку ошибок и проверяет точное совпадение с узлом и связанной с ним информационной переменной.
12.  Поскольку все совпадает, fn_hash_lookup() заполняет структуру fib_result всей информацией об этом маршруте. (В противном случае он будет продолжать проверять больше узлов и зон, пока не найдет совпадение или полностью не выйдет из строя.)
13.  ip_route_output_slow() берет структуру fib_result и, предполагая, что все в порядке, создает из нее новую запись кэша маршрутизации.

### 8.2.3   Кэш маршрутизации

![r_cache_gen.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_gen.gif)  

Рисунок 8.5: Концептуальная организация кэша маршрутизации.

Кэш маршрутизации — это самый быстрый метод поиска маршрута в Linux; он сохраняет каждый маршрут, который используется в настоящее время или недавно использовался, в хеш-таблице. Когда IP нужен маршрут, он переходит к соответствующему сегменту хэша и ищет цепочку кэшированных маршрутов, пока не найдет совпадение, а затем отправляет пакет по этому пути. (См. раздел [8.2.2](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_the_FIB) о том, что происходит, когда маршрут еще не находится в кэше.) Маршруты выстраиваются в цепочку по порядку, наиболее часто используемые первыми, и имеют таймеры и счетчики, которые удаляют их из таблицы, когда они больше не используются. См. рисунок  [8.5](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_gen) для абстрактного обзора и рисунки  [8.6](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_struct)  и  [8.7](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_dst_struct) для подробных диаграмм структур данных.

struct rtable *rt_hash_table[RT_HASH_DIVISOR] — эта глобальная переменная содержит 256 сегментов (указателей) цепочек записей кэша маршрутизации ( rtable ); хеш-функция объединяет адрес источника, адрес назначения и TOS, чтобы получить точку входа в таблицу (от 0 до 255). Содержимое этой таблицы указано в _/proc/net/rt_cache_ .

Структура записи таблицы маршрутизации ( rtable ) — _include/net/route.h_ — эти структуры содержат записи кэша назначения и идентификационную информацию, специфичную для каждого маршрута.

-   объединение < struct dst_entry dst; struct rtable* rt_next) > u - это запись в таблице; структура объединения позволяет быстро получить доступ к следующей записи в таблице за счет чрезмерного использования поля next rtable для указания на следующую запись кэша, если это необходимо.
-   __u32 rt_dst — адрес назначения.
-   __u32 rt_src — исходный адрес.
-   rt_int iif - интерфейс ввода.
-   __u32 rt_gateway — адрес соседа, через которого следует маршрут для достижения пункта назначения.
-   struct rt_key key — структура, содержащая ключ поиска в кэше (с полями src, dst, iif, oif, tos и scope)
-   Другие поля содержат флаги, тип и другую разную информацию.

Структура кеша назначения ( dst_entry ) — _include/net/dst.h_ — эти структуры содержат указатели на определенные входные и выходные функции и данные для маршрута.

-   struct device *dev - устройство ввода/вывода для данного маршрута.
-   unsigned pmtu - максимальный размер пакета для данного маршрута.
-   struct Neighbor *neighbor - указатель на соседа (следующую ссылку) для данного маршрута.
-   struct hh_cache *hh — указатель на аппаратный кэш заголовков; поскольку это одинаково для каждого исходящего пакета по физическому каналу, он сохраняется для быстрого доступа и повторного использования.
-   int (*input)(struct sk_buff*) — указатель на входную функцию для этого маршрута (обычно tcp_recv() ).
-   int (*output)(struct sk_buff*) — указатель на функцию вывода для этого маршрута (обычно dev_queue_xmit() ).
-   struct dst_ops *ops — указатель на структуру, содержащую семейство, протокол и функции проверки, перенаправления и уничтожения для этого маршрута.
-   Другие поля содержат статистическую информацию и информацию о состоянии, а также ссылки на другие записи таблицы маршрутизации.

Структура Neighbor Link ( сосед ) — _include/net/neighbor.h_ — эти структуры, по одной для каждого хоста, который находится ровно в одном переходе, содержат указатели на свои функции доступа и информацию.

-   struct device *dev - указатель на устройство, которое физически подключено к этому соседу.
-   struct hh_cache *hh — указатель на аппаратный заголовок, который всегда предшествует трафику, отправляемому этому соседу.
-   int (*output)(struct sk_buff*) — указатель на функцию вывода для этого соседа (обычно dev_queue_xmit() ?).
-   struct sk_buff_head arp_queue — первый элемент в очереди ARP для трафика, относящегося к этому соседу — входящего или исходящего?
-   struct neigh_ops *ops - указатель на структуру, содержащую данные о семействе и функции вывода для этой ссылки.
-   Другие поля содержат статистическую информацию и информацию о состоянии, а также ссылки на других соседей.

![r_cache_struct.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_struct.gif)  

Рисунок 8.6: Отношения структуры данных кэша маршрутизации.

![r_dst_struct.gif](https://www.cs.unh.edu/cnrg/people/gherrin/r_dst_struct.gif)  

Рисунок 8.7: Отношения структуры данных целевого кэша.

**Пример обхода кэша маршрутизации:**

1.  ip_route_output() (вызывается для поиска маршрута) вызывает rt_hash_code() с адресом источника 172.16.1.1, адресом назначения 172.16.1.6 и TOS 2.
2.  rt_hash_code() выполняет хэш-функцию для источника, получателя и TOS и объединяет результат с 255, чтобы получить запись в хэш-таблицу (5).
3.  ip_route_output() входит в хеш-таблицу по индексу 5. Там есть запись, но адреса назначения не совпадают.
4.  ip_route_output() переходит к следующей записи (на которую указывает поле u.rt_next последней записи). Это соответствует в каждом случае - адрес назначения, адрес источника, iif из 0, соответствующий oif и приемлемый TOS.
5.  ip_route_output() обновляет статистику в новой структуре dst_cache записи таблицы, устанавливает указатель для вызывающей функции, чтобы он ссылался на маршрут, и возвращает 0, указывающий на успех.

### 8.2.4   Обновление маршрутной информации

Linux обновляет информацию о маршрутизации только при необходимости, но таблицы изменяются по-разному. Кэш маршрутизации является наиболее изменчивым, в то время как FIB обычно вообще не меняется.

Таблица соседей изменяется по мере обмена сетевым трафиком. Если хосту нужно отправить что-то на адрес, который находится в локальной подсети, но еще не находится в таблице соседей, он просто передает запрос ARP и добавляет новую запись в таблицу соседей, когда получает ответ. Периодически записи истекают и исчезают; этот цикл продолжается бесконечно (если только маршрут не был специально помечен как постоянный ARP). Ядро обрабатывает большинство изменений автоматически.

FIB на большинстве хостов и даже маршрутизаторов остается статичным; он заполняется во время инициализации всеми возможными зонами для маршрутизации через все подключенные маршрутизаторы и никогда не изменяется, если только один из маршрутизаторов не выйдет из строя. ( Подробнее о демонах IP-маршрутизации см. в главе [9 ).](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route) Изменения должны поступать через внешние вызовы ioctl() для добавления или удаления зон.

Кэш маршрутизации часто меняется в зависимости от трафика сообщений. Если хосту необходимо отправить пакеты на удаленный адрес, он ищет адрес в кэше маршрутизации (и при необходимости в FIB) и отправляет пакет через соответствующий маршрутизатор. На узле, подключенном к локальной сети с одним маршрутизатором, подключенным к Интернету, каждая запись будет указывать либо на соседнего узла, либо на маршрутизатор, но может быть много записей, указывающих на маршрутизатор (по одной на каждый удаленный адрес). Записи создаются по мере установления соединений и быстро истекают, когда трафик на этот адрес перестает течь. Все делается с помощью вызовов уровня IP для создания маршрутов и таймеров ядра для их удаления.

## 8.3   Функции Linux

Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для маршрутизации, где они находятся в исходном коде и что они делают.

arp_rcv() - сеть/ipv4/arp.c (542)
  проверяет наличие ошибок (устройство без ARP, отсутствие устройства, пакет не для хоста,
      тип устройства не совпадает и т.д.)
  проверить на работоспособность - понимает только ОТВЕТ и ЗАПРОС
  извлекает данные из пакета
  проверка плохих запросов - петлевых или многоадресных адресов
  проверяет пакет обнаружения дубликатов адресов (при необходимости отправляет ответ)
  если сообщение является запросом и ip_route_input() имеет значение true:
    если пакет локальный:
      вызывает neigh_event_ns() для поиска и обновления соседа, отправившего пакет
      проверяет скрытое устройство (не отвечает, если скрыто)
      отправляет ответ с адресом устройства
    в противном случае:
      вызывает neigh_event_ns() для поиска и обновления соседа, отправившего пакет
      вызывает neigh_release()
      при необходимости вызывает arp_send() с адресом
      в противном случае вызывает pneigh_enqueue() и возвращает 0
  если сообщение является ответом:
    вызывает __neigh_lookup()
    проверяет, пришло ли несколько ответов ARP; сохраняет только
        самый быстрый (первый)
    вызывает neigh_update() для обновления записи ARP
	вызывает neigh_release()
  освобождает skbuffer и возвращает 0
arp_send() - net/ipv4/arp.c (434)
  проверяет, поддерживает ли устройство ARP
  выделяет skbuffer
  заполняет информацию заголовка буфера
  заполняет информацию ARP
  вызывает dev_queue_xmit() с готовым пакетом
arp_req_get() — net/ipv4/arp.c (848)
  вызывает __neigh_lookup() для поиска записи по заданному адресу
  копирует данные из соседней записи в запись arpreq
  возвращает 0, если найден, или ENXIO, если адрес отсутствует в таблице ARP.
fib_get_procinfo() — net/ipv4/fib_frontend.c (109)
  выводит заголовок и результаты main_table->fn_hash_get_info() для proc FS
fib_lookup() — include/net/ip_fib.h (153)
  вызывает tb_lookup() [= fn_hash_lookup()] для local_table и main_table
  если у любого из них есть запись, он заполняет fib_result и возвращает 0
  иначе возвращает недостижимую ошибку
fib_node_get_info() — net/ipv4/fib_semantics.c (971)
  выводит содержимое fib_node и fib_info для proc FS
fib_validate_source() — net/ipv4/fib_frontend.c (191)
  проверяет устройство и адрес входящего пакета
  возвращает код ошибки, если что-то не так
  возвращает 0, если пакет кажется легальным
fn_hash() — net/ipv4/fib_hash.c (108)
  выполняет хеш-функцию на адресе назначения:
    u32 h = ntohl(daddr)>>(32 - fib_zone->fz_order);
    ч ^= (ч>>20);
    ч ^= (ч>>10);
    ч ^= (ч>>5);
    ч &= FZ_HASHMASK(fz); // FZ_HASHMASK равен 15 почти для всех зон
fn_hash_get_info() — net/ipv4/fib_hash.c (723)
  перебирает зоны в таблице FIB, печатая fib_node_get_info() для
      проц ФС
fn_hash_lookup() — net/ipv4/fib_hash.c (261)
  перебирает зоны в заданной таблице
    перебирает узлы в каждой зоне (начиная с хеш-записи)
      если сетевые маски (узел и пункт назначения) совпадают
          проверяет TOS и статус узла
          вызывает fib_semantic_match() для проверки типа пакета
          заполняет fib_result данными об успехе и возвращает 0
  возвращает 1, если ничего не совпало
fn_new_zone() — net/ipv4/fib_hash.c (220)
  выделяет память (в ядре) для новой зоны
  выделяет место для 16 сегментов узлов для зоны (кроме первой зоны -
      0.0.0.0 [loopback] - который получает только один)
  хранит сетевую маску (крайние левые n бит, где n — позиция
      зона в таблице)
  ищет более конкретную зону в родительской таблице
  вставляет зону в список зон (наиболее конкретная зона - голова)
  устанавливает новую зону в родительскую таблицу
  возвращает новую зону
fz_chain() - net/ipv4/fib_hash.c (133)
  вызывает fn_hash() для получения хеш-значения
  возвращает fib_node в fib_zone по хеш-индексу
ip_dev_find() - net/ipv4/fib_frontend.c (147)
  ищет и возвращает устройство с заданным адресом в локальной таблице
ip_route_connect() — include/net/route.h (140)
  вызывает ip_route_output() для получения адреса назначения
  возвращает, если вызов работает или генерирует ошибку
  в противном случае очищает указатель маршрута и повторяет попытку
ip_route_input() — net/ipv4/route.c (1366)
  вычисляет хеш-значение для адреса
  просматривает таблицу (начиная с хэша), чтобы найти совпадение соединения
      (источник, место назначения, TOS и IIF/OIF)
  если есть совпадение, обновляет статистику и возвращает запись маршрутизации
  иначе вызывает ip_route_input_slow()
ip_route_input_slow() — net/ipv4/route.c (1097)
  создает ключ кэша таблицы маршрутизации
  проверяет наличие специальных адресов (таких как петля, широковещательная рассылка или ошибки)
  вызывает fib_lookup() для поиска маршрута
  выделяет память для новой записи таблицы маршрутизации
  инициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,
      флаги
  вызывает fib_validate_source() для проверки источника пакета
  сообщение printks и возвращает ошибку, если источник неверный
  вызывает rt_set_nexthop() для поиска следующего пункта назначения (соседнего)
  возвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации
ip_route_output() — net/ipv4/route.c (1664)
  вычисляет хеш-значение для адреса
  просматривает таблицу (начиная с хэша), чтобы найти совпадение соединения
      (источник, место назначения, TOS и IIF/OIF)
  если есть совпадение, обновляет статистику и возвращает запись маршрутизации
  иначе вызывает ip_route_output_slow()
ip_route_output_slow() — net/ipv4/route.c (1421)
  создает ключ кэша таблицы маршрутизации
  если исходный адрес известен, вызывает ip_dev_find для определения выходного устройства
  если адрес назначения неизвестен, настройте loopback
  вызывает fib_lookup() для поиска маршрута
  выделяет память для новой записи таблицы маршрутизации
  инициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,
      флаги
  вызывает rt_set_nexthop() для поиска следующего пункта назначения (соседнего)
  возвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации
ip_rt_ioctl() - net/ipv4/fib_frontend.c (250)
  включает SIOCADDRT или SIOCDELRT (в противном случае возвращает EINVAL)
  проверяет разрешение и копирует аргумент в пространство ядра
  преобразует скопированный аргумент в структуру rtentry
  при удалении маршрута вызывает fib_get_table() и table->delete()
  иначе вызывает fib_new_table() и table->insert()
  освобождает место для аргумента и возвращает 0 в случае успеха
neigh_event_ns() - net/core/neighbour.c (760)
  вызывает __neigh_lookup() для поиска адреса в соседней таблице
  вызывает neigh_update()
  возвращает указатель на назначенного соседа
neigh_update() - net/core/neighbour.c (668)
  проверяет права на изменение таблицы
  проверяет статус соседа, если это не новая запись
  сравнивает заданный адрес с кешированным:
    если ноль или устройство не имеет адреса, использует текущий адрес
    если отличается, проверьте флаг переопределения
  вызывает neigh_sync(), чтобы убедиться, что сосед все еще активен
  обновляет время контакта с соседом
  если старая запись была действительна, а новая не меняет адрес, возвращает 0
  если новый адрес отличается от старого, заменяет старый новым
  если новое и старое состояния совпадают, возвращает 0
  вызывает neigh_connect() или neigh_suspect() для установки/проверки соединения
  если старое состояние было недействительным:
    просматривает пакеты в очереди ARP, вызывая соседний output()
        функция на каждом
    очищает очередь ARP
  возвращает 0
rt_cache_get_info() — net/ipv4/route.c (191)
  печатает заголовок и все элементы rt_hash_table для proc FS
rt_hash_code() — net/ipv4/route.c (18)
  использует адрес источника, адрес назначения и тип службы для
      определить (и вернуть) хеш-значение:
    hash = ((daddr&0xF0F0F0F0)>>4)|((daddr&0x0F0F0F0F)<<4);
    хэш = хэш ^ сад ^ тос;
    хеш = хэш ^ (хэш >> 16);
    хеш = (хэш ^ (хэш >> 8)) & 0xFF;
rt_intern_hash() — net/ipv4/route.c (526)
  помещает новый маршрут в таблицу маршрутизации

# Глава 9  
Динамическая маршрутизация с помощью _routed_

В этой главе представлена ​​динамическая маршрутизация, выполняемая маршрутизатором (в отличие от конечного хост-компьютера). В нем представлен обзор того, как _маршрутизируемая_ программа реализует протоколы маршрутизации в Linux, исследуется, как она изменяет таблицы маршрутизации ядра, и обобщается код реализации.

## 9.1   Обзор

Обычный хост-компьютер имеет очень ограниченные возможности маршрутизации пакетов; сообщение либо для себя, либо для другого компьютера, а если оно для другого компьютера, то существует очень ограниченное количество вариантов его отправки. Обычно такому хосту достаточно отправить пакет в локальную сеть, чтобы "шлюзовый" компьютер (маршрутизатор) подхватил его и отправил дальше. Linux обычно не поддерживает никакой метрической информации (расстояния) о маршрутах, хотя в FIB есть переменные для ее хранения. Для простой маршрутизации к конечному хосту единственным важным вопросом является «смогу ли я добраться туда отсюда», а не «какой путь лучше?».

Однако маршрутизатор должен принимать решения о том, куда направлять трафик. Может быть несколько маршрутов к месту назначения, и маршрутизатор должен выбрать один (исходя из расстояния, измеряемого в переходах, или какой-либо другой метрики, такой как туманное качество обслуживания). Протокол маршрутной информации (RIP) — это простой протокол, который позволяет маршрутизирующим компьютерам отслеживать расстояние до различных пунктов назначения и обмениваться этой информацией между собой.

Используя RIP, каждый узел поддерживает таблицу, в которой содержится расстояние от него до других сетей и маршрут, по которому он будет отправлять пакеты в этот пункт назначения. Периодически маршрутизаторы обновляют друг друга; когда становятся очевидными более короткие маршруты, узел обновляет свою таблицу. Обновления — это просто сообщения RIP с адресом назначения и метрическими компонентами этой таблицы. На рисунке  [9.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#d_rip) показана схема таблицы маршрутизации RIP и пакета RIP.

![d_rip.gif](https://www.cs.unh.edu/cnrg/people/gherrin/d_rip.gif)  

Рисунок 9.1: Пакет и таблица протокола маршрутной информации.

## 9.2   Как работает _маршрутизация_

_routed_ — это широко доступная программа для реализации RIP через сообщения UDP на компьютерах POSIX. По сути, это автономная программа, которая использует вызовы ioctl() для получения информации и обновления таблиц маршрутизации на хост-компьютере.

### 9.2.1   Структуры данных

_routed_ поддерживает две идентичные таблицы данных — одну для хостов и одну для сетей. Каждая представляет собой хеш-таблицу с сегментами ROUTEHASHSIZ (32) цепочек записей маршрутизации. Записи содержат информацию RIP (но могут также совпадать со структурой rtentry , чтобы _routed_ мог передать их ядру через вызовы ioctl() ). Наряду с базовым пунктом назначения, маршрутизатором и метрикой в ​​записях хранятся флаги, состояние и информация о таймере.

### 9.2.2   Инициализация

Когда начинается _маршрутизация_ , она выполняет различные действия по инициализации и вызывает ioctl() для получения информации об интерфейсе от ядра. Затем он отправляет сообщение RIP/UDP с запросом маршрутной информации от всех соседних маршрутизаторов. Наконец, он входит в бесконечный цикл, в котором он ждет трафика или таймеров, чтобы заставить его что-то сделать.

### 9.2.3   Нормальная работа

Когда приходят сообщения RIP (через сокет UDP), _routed_ анализирует их и либо изменяет свою таблицу (для ответных сообщений), либо отправляет информацию обратно запрашивающему маршрутизатору (для запросов). Отправка информации — это просто поиск адресата в его собственной таблице, помещение этой информации в пакет RIP и отправка через сокет UDP. Обновление его таблицы может не иметь никакого значения (если изменений нет или изменение не имеет значения) или может привести к изменению маршрутизации. Если обновление показывает более короткий маршрут к месту назначения, _routed_ обновит свою собственную таблицу, а затем вызовет ioctl() для обновления таблиц маршрутизации ядра (FIB).

Когда таймер обновления истекает, каждые TIMER_RATE секунд _routed_ просматривает каждую запись в обеих таблицах и обновляет свои таймеры. Устаревшие записи устанавливаются на бесконечное расстояние ( HOPCNT_INFINITY ), а слишком старые записи удаляются (только из таблицы RIP, а не из FIB ядра). Наконец, он отправляет обновление на соседние маршрутизаторы. Это обновление содержит новую информацию таблицы (ответные сообщения) для всех записей, которые изменились с момента последнего обновления.

_routed_ оставляет фактическую маршрутизацию обычным механизмам маршрутизации ядра; все, что он делает, это обновляет таблицы ядра на основе информации от других маршрутизаторов и передает свою собственную маршрутную информацию. Обновления затем изменяют способ маршрутизации пакетов ядром, но _маршрутизация_ сама по себе не выполняет никакой маршрутизации.

## 9.3   Функции _маршрутизации_

Ниже приведен алфавитный список функций _маршрутизируемой_ программы, которые наиболее важны для маршрутизации, где они находятся в исходном коде и что они делают. Показанный каталог SOURCES представляет собой каталог, содержащий исходный код для данного сетевого файла _._

Маршрутизируемый исходный код доступен в виде пакета, отдельного от исходного кода ядра (Red Hat Linux использует диспетчер пакетов _rpm_ _)_ . Приведенный ниже код взят из пакета исходного кода _netkit-routed-0.10 от_ 8 марта 1997 г. Этот пакет доступен на веб-странице _www.redhat.com/apps/download_ ; в частности, это пришло с _www.redhat.com/swt/src/netkit-routed-0.10.src.html_ . После загрузки _root_ может установить пакет с помощью следующих команд (начиная с каталога с пакетом):

> rpm -i netkit-routed-0.10.src.rpm  
> cd /usr/src/redhat/SOURCES  
> tar xzf netkit-routed-0.10.tar.gz

Это создает каталог _/usr/src/redhat/SOURCES/netkit-routed-0.10_ и заполняет его исходным кодом маршрутизируемой _программы_ . Этот процесс должен быть похожим (но, несомненно, не совсем таким же) для других дистрибутивов Linux.

ifinit() — ИСТОЧНИКИ/routed/startup.c (88)
  открывает сокет UDP
  вызывает ioctl(SIOCFIGCONF) для получения конфигурации интерфейса
  циклы через интерфейсы:
    вызывает ioctl() для получения флагов, широковещательного адреса, метрики и сетевой маски
    создает новую структуру интерфейса
    копирует информацию в структуру интерфейса
    вызывает addrouteforif() для добавления записи маршрутизации для интерфейса
  устанавливает переменную поставщика, если необходимо
  закрывает сокет
process() - SOURCES/routed/main.c (298)
  запускает непрерывный цикл:
    получает пакет (ждет)
    проверяет, что пакет имеет правильный размер
    вызывает rip_input() для обработки пакета (RIP)
rip_input() - ИСТОЧНИКИ/routed/input.c (60)
  трассирует ввод при необходимости
  проверяет пакет, чтобы убедиться, что протокол и адрес поддерживаются
  проверяет версию RIP (не может быть 0)
  переключаться на основе содержимого пакета -
    если пакет является запросом:
      проверяет запрос на валидность
      если запрос для всех записей, вызывает Supply()
      еще ищет запрошенный адрес, создает и отправляет ответный пакет
    включена или выключена трассировка пакета:
      проверяет, что запрос пришел с действительного порта
      если все в порядке, включает или выключает трассировку
    если пакет является ответом:
      проверяет, что ответ пришел от маршрутизатора
      таймер обновлений для интерфейса
      перебирает каждую запись в полученном пакете:
        анализирует информацию о маршруте
        проверяет информацию о семействе адресов, хосте и метрике
        обновляет количество переходов (добавляет метрику в сообщении к счетчику переходов к маршрутизатору
            которые отправляют сообщение, с учетом максимума HOPCNT_INFINITY)
        вызывает rtlookup() для поиска адреса в таблице маршрутизации
        если это кажется новым маршрутом:
           вызывает rtfind() для поиска эквивалентного маршрута
           если он действительно новый, вызывает rtadd() и возвращает
        вызывает rtchange() для изменения маршрута при необходимости (новый маршрут или
           изменение количества прыжков)
        обновляет таймеры маршрута
  если были изменения:
    отправляет обновление, если необходимо
    обновляет общую информацию о таймере обновления
>>> routed main() - SOURCES/routed/main.c (78)
  открывает перенаправленный файл журнала
  вызывает getservbyname() для получения UDP-маршрутизатора
  устанавливает сокет UDP для трафика сообщений RIP
  запускает аргументы командной строки для установки флагов
  если не отлаживать, разветвляет и запускает программу в новом сеансе (родитель умирает)
  вызывает rtinit() для инициализации таблиц данных
  вызывает ifinit() для заполнения информации об интерфейсе
  вызывает toall() для запроса информации со всех других маршрутизаторов
  устанавливает обработчики сигналов для ALRM, HUP, TERM, INT, USR1 и USR2
  запускает непрерывный цикл:
    если необходимо обновление, устанавливает переменные таймера
    вызывает select() для ожидания трафика
    если select() возвращает ошибку (кроме EINTR), регистрирует ее
    если время ожидания select() истекло (время обновления)
        вызывает toall() для трансляции обновления
        сбрасывает переменные таймера
    если на сокете есть ожидающий трафик, вызывает process()
rtadd() - ИСТОЧНИКИ/routed/tables.c (138)
  проверяет, что семейство адресов находится в правильном диапазоне
  вызывает семейную функцию af_rtflags() для установки флагов маршрутизации
  определяет хеш-значение для соответствующей таблицы (хост или сеть)
  создает и заполняет новую структуру rt_entry
  вызывает insque() для добавления записи в таблицу
  вызывает rtioctl() для добавления записи в таблицу ядра
  если вызов не удался:
    если маршрут должен работать, вызывает семейство af_format() для добавления пункта назначения
        и шлюз к таблицам ядра
    если хост недоступен, удаляет и освобождает запись
rtchange() - ИСТОЧНИКИ/routed/tables.c (207)
  определяет, требует ли изменение добавления или удаления шлюзов
  вызывает rtioctl() для добавления и/или удаления маршрутов
rtfind() - ИСТОЧНИКИ/routed/tables.c (100)
  определяет хеш-значение для таблицы хостов
  циклы через стол; возвращает запись, если адреса равны
  определяет хеш-значение для чистой таблицы
  возвращается к циклу по таблице, на этот раз возвращая запись, если вызов
      для семейства функция af_netmatch() возвращает true
  возвращает ноль (0), если совпадений нет
rtinit() — ИСТОЧНИКИ/routed/tables.c (336)
  перебирает хэш-таблицу сети, устанавливая указатели вперед и назад
  перебирает хэш-таблицу хоста, устанавливая указатели вперед и назад
rtioctl() — ИСТОЧНИКИ/routed/tables.c (346)
  заполняет структуру rtentry из параметров
  выводит действия трассировки при необходимости
  вызывает ioctl(SIOCADDRT или SIOCDELRT) для обновления таблицы ядра
  возвращает результат вызова ioctl() (или -1 для ошибочного параметра)
rtlookup() — ИСТОЧНИКИ/routed/tables.c (65)
  определяет хеш-значение для адреса
  просматривает таблицу хостов в поисках соответствия
  если сначала неудачно, пытается снова с чистой таблицей
  возвращает указатель на запись или ноль (0)
sndmsg() — ИСТОЧНИКИ/routed/output.c (77)
  вызывает соответствующую выходную функцию семейства
  трассирует пакет при необходимости
Supply() - SOURCES/routed/ouput.c (91)
  создает ответное сообщение RIP
  зацикливается на таблице хостов маршрутизации
    перебирает записи маршрутизации
      проверяет, нужна ли запись хосту маршрутизации
      если это так, помещает информацию о маршрутизации в пакет и отправляет его
  возвращается и делает это снова с таблицей сети маршрутизации
timer() — SOURCES/routed/timer.c (56)
  обновляет переменные таймера
  перебирает таблицу хостов
    обновляет информацию о таймере для каждой записи
    удаляет запись, если она слишком старая
    изменяет метрику на бесконечность, если она стареет
  возвращается и делает это снова с чистой таблицей
  вызывает toall(), если требуется обновление
toall() - ИСТОЧНИКИ/routed/output.c (55)
  циклы через интерфейсы:
    устанавливает адрес назначения для широковещательного или определенного адреса
    вызывает переданную функцию [sndmsg() или Supply()] с адресом

# Глава 10.  
Редактирование исходного кода Linux

## 10.1   Дерево исходного кода Linux

Исходный код Linux обычно находится в каталоге /usr/src (если он установлен). В разных деревьях каталогов может быть много версий (например, _linux-2.2.5_ или _linux-2.2.14_ ). Должна быть одна программная ссылка ( _linux_ ) на самую последнюю версию кода (например, _linux ® linux-2.2.14_ ).

Это обзор структуры исходных каталогов Linux (показаны не все ветки:

_/USR/SRC/линукс/_

-   _arch_ - специфичный для архитектуры код, по процессору
    -   _i386_ — код для процессоров Intel (включая линейки 486 и Pentium)
        
        -   _boot_ - расположение только что скомпилированных ядер
        
-   _драйверы_ - код для драйверов всех видов
    
    -   _block_ — блокировать драйверы устройств (например, жестких дисков)
    -   _cdrom_ - драйверы устройств CD-ROM
    -   _net_ — драйверы сетевых устройств
    -   _pci_ - драйверы шины PCI
    
-   _fs_ - код для разных файловых систем (EXT2, MS-DOS и т.д.)
-   _include_ — заголовочные файлы, используемые во всем коде
    
    -   _asm ® asm-i386_ - заголовки, зависящие от процессора
    -   _config_ — общие заголовки конфигурации
    -   _linux_ — общие заголовки
    -   _net_ — сетевые заголовки
    
-   _ядро_ - код для конкретных подпрограмм ядра
-   _lib_ — код для ошибок, строк и printf
-   _mm_ - код управления памятью
-   _модули_ - объектные файлы и ссылки для загрузки ядра по мере необходимости
-   _net_ - код для сети
    
    -   _ядро_ - независимый от протокола код
    -   _ipv4_ — код, специфичный для IPv4
    -   _package_ - независимый от протокола код пакета
    -   _sched_ — код для планирования сетевых действий
    

## 10.2   Использование тегов EMACS

Исходный код Linux, очевидно, очень большой и разбросан по многим файлам. Файл _TAGS_ позволяет быстро перейти к определенному файлу в поисках ссылки.

### 10.2.1   Ссылки с помощью TAGS

Внутри файла переместите курсор на ключевое слово, которое вы хотите найти (например, ``sock''). Нажмите ``ESC'' ``.'' - EMACS предложит найти тег (по умолчанию это слово, на котором находится курсор); нажмите ``ENTER''. При первом использовании вам нужно будет указать, какой файл TAGS использовать (например, _/usr/src/TAGS_ ). Далее EMACS автоматически откроет соответствующий файл (например, _/usr/src/linux/include/linux/sock.h_ ) в новом буфере и поместит курсор на определение этой структуры, #define или функции. Если выводится не то определение, которое вы искали, нажмите ``CTRL-U'' ``ESC'' ``.'', чтобы вызвать альтернативные ссылки.

Эти теги работают даже тогда, когда вы вносите изменения в исходные файлы, хотя они будут работать медленнее по мере того, как будет вноситься все больше и больше изменений. EMACS хранит теги в файле (по умолчанию _TAGS_ ) с каждой ссылкой, именем файла и номером строки. Если тег находится не на сохраненном номере строки, EMACS выполнит поиск в файле, чтобы найти новое местоположение.

### 10.2.2   Создание файлов TAGS

Если вам нужно начать с нуля, выполните следующие действия.

Команда для создания файла тегов:

> etags _имя файла_

Команда для добавления новой информации в файл тегов:

> etags - _имя файла_

Они помещают новые теги в файл _TAGS_ в текущем каталоге. Имена файлов сохраняются как заданные, поэтому абсолютные ссылки всегда будут относиться к одним и тем же файлам, а относительные ссылки зависят от положения файла _TAGS_ . (Прочитайте справочную страницу для _etags_ для получения дополнительной информации).

Например, чтобы создать файл тегов для исходных файлов _ipv4_ , введите:

> etags /usr/src/linux/net/ipv4/*.c

Чтобы добавить заголовочные файлы, введите:

> etags -a /usr/src/include/net/*.h

Файл _TAGS_ теперь будет содержать краткие ссылки на весь исходный код C и информацию заголовков в этих каталогах.

## 10.3   Использование тегов vi

Редактор vi также поддерживает использование файлов тегов (и создает их с помощью команды _gctags_ , которая работает почти так же, как показанная выше команда _etags_ ).

## 10.4   Пересборка ядра

(Более подробные инструкции см. в Linux-kernel-HOWTO.)

Это краткое пошаговое руководство по перекомпиляции и установке ядра с нуля.

1.  Перейдите в начало исходного каталога ( _/usr/src/linux_ ). Если еще нет исторической копии рабочего файла _.config_ (например, текущей), СДЕЛАЙТЕ ОДНУ. Пока у вас не будет достаточно опыта, чтобы вам больше не нужно было это руководство, ничего не перезаписывайте, пока не убедитесь, что есть копия, к которой вы можете вернуться. (С другой стороны, если у вас есть стабильная версия ядра, нет причин хранить старые версии. Даже система разработки, вероятно, должна иметь только исходную рабочую версию, последнюю известную стабильную версию и текущую версию.
    
2.  Запустите make xconfig ( make config и make menuconfig также работают, но xconfig намного удобнее для пользователя). Настроить систему по желанию; есть помощь, доступная для большинства опций. Файл конфигурации должен по умолчанию использовать текущие настройки, поэтому вам нужно будет изменить только то, что вы хотите добавить или удалить. Как правило, выберите «Y» для важных или часто используемых функций (таких как файловая система ext2), «M» для вещей, которые иногда бывают полезны (например, звуковые драйверы), и «N» для вещей. которые не применяются (например, поддержка радиолюбителей). Если вы сомневаетесь, обратитесь к тексту справки или включите что-нибудь в качестве модуля.
    
3.  Запустите make dep , чтобы убедиться, что выбранные вами параметры будут правильно скомпилированы. Это займет несколько минут, так как компьютер проверит все зависимости. Если все пойдет хорошо, программа make просто завершит работу; если есть проблема, он будет отображать сообщения об ошибках и останавливаться.
    
4.  Запустите make clean , чтобы удалить старые объектные файлы, ЕСЛИ вы хотите все перекомпилировать. Это, очевидно, сделает процесс компиляции более длительным.
    
5.  Запустите make bzImage , чтобы собрать новое ядро. ( make zImage и make boot также собирают образы ядра, но bzImage скомпилируется в наиболее компактный файл. Если по какой-то причине вы используете один из этих двух методов, вы можете получить ошибку «ядро слишком большое» при запуске _lilo_ - попробуйте еще раз с bzImage .) Это займет довольно много времени, в зависимости от доступной памяти.
    
6.  Запустите make modules , чтобы собрать любые модули (не включенные в основной образ ядра).
    
7.  При необходимости переименуйте старые модули:
    
    > mv /lib/modules/2.2.xx /lib/modules/2.2.xx-старый
    
    (Обратите внимание, что вам не нужно будет делать это, если вы компилируете совершенно новую версию; старые будут по-прежнему находиться в _/lib/modules/2.2.xx_ при сборке версии 2.2. _yy_ .)
    
8.  Запустите make modules_install , чтобы установить новые модули. Вы должны сделать это, даже если вы собрали монолитное ядро ​​(без модулей). (Обратите внимание, что в загрузочном каталоге может быть текстовый файл _с информацией о модуле Red Hat или ссылка; это не очень важно, и это не обновляет его.)_
    
9.  Скопируйте новое ядро ​​в каталог _/boot_ и измените ссылку на ядро ​​(обычно _это vmlinuz_ ):
    
    > cp arch/i386/boot/bzImage /boot/vmlinuz-2.2.xx  
    > ln -sf /boot/vmlinuz-2.2.xx /boot/vmlinuz
    
10.  Скопируйте новый файл _System.map_ в каталог _/boot_ и измените ссылку на карту:
    
    > cp System.map /boot/System.map-2.2.xx  
    > ln -sf /boot/System.map-2.2.xx /boot/System.map
    
11.  Создайте новый файл _initrd_ , если на компьютере есть устройства SCSI:
    
    > /sbin/mkinitrd /boot/initrd-2.2.xx.img 2.2.xx
    
12.  Отредактируйте файл _/etc/lilo.conf_ , чтобы установить новое ядро; скопируйте блок для старого ядра ( image=vmlinuz ) и измените существующий, чтобы оставить его как вариант. Например, переименуйте образ в vmlinuz-2.2.xx-old и измените метку на стабильную . Таким образом, вы всегда сможете перезагрузиться на текущее (предположительно стабильное) ядро, если ваши изменения вызовут проблемы.
    
13.  Запустите /sbin/lilo , чтобы установить новое ядро ​​в качестве опции загрузки.
    
14.  Перезагрузите компьютер с новым ядром.
    
15.  Если новое ядро ​​не работает должным образом, загрузите старое ядро ​​и перенастройте систему перед повторной попыткой.
    

## 10.5   Исправление исходного кода ядра

Linux — это постоянно меняющаяся операционная система; обновления могут быть выпущены каждые несколько месяцев. Есть два способа установить новую версию ядра: загрузить новый исходный код целиком или загрузить патчи и применить их.

Загрузка всего исходного кода может быть предпочтительнее, чтобы гарантировать, что все работает правильно. Для этого загрузите последний исходный код ядра и установите его ( _untar_ ). Обратите внимание, что это будет (вероятно) полный дистрибутив, а не специфичный для машины, и будет содержать много дополнительного кода. Большая часть этого может быть удалена, но конфигурационные файлы Makefile полагаются на некоторую информацию. Если вам не хватает места, удалите файлы _*.c_ и _*.h в каталогах_ _arch/,_ отличных от i386, и _include/asm-*_ , но действуйте осторожно.

Загрузка патчей может быть быстрее, но несколько сложнее. Из-за вариаций дистрибутива, внесенных вами изменений или других модификаций патчи могут работать некорректно. Вы должны применять файлы исправлений по порядку (чтобы перейти с 2.2.12 на 2.2.14, сначала примените исправление 2.2.13, а затем 2.2.14). Тем не менее, исправления могут быть предпочтительнее, поскольку они работают с существующим деревом каталогов.

После того, как вы загрузили патч (и разархивировали его, если необходимо), просто поместите его в каталог выше _linux_ (например, _/usr/src/_ ) и запустите программу патча, чтобы установить его:

> patch -Np0 -verbose -r rejfile < patch-2.2.xx _(где xx — версия патча)_

Опция -N игнорирует уже примененные патчи, а -p0 предполагает, что патч хочет применить себя к источнику в каталоге _linux_ . Параметр -r rejfile помещает все отклоненные патчи в один файл ( _rejfile_ ) - это может быть или не быть тем, что вы хотите сделать. Если вы не сохранили весь исходный дистрибутив, вам придется пропустить многие изменения (для различных процессорных архитектур), просто нажав ENTER в ответ на приглашения ``исправить какой файл'' и ``игнорировать исправление''. Как только вы освоитесь с процессом, запустите его без параметров -verbose и -r rejfile .

Получив новую версию ядра, следуйте инструкциям по пересборке ядра, чтобы начать его использовать. Возможно, вам не придется изменять какие-либо параметры конфигурации, но вы почти наверняка захотите запустить команду make clean , чтобы удалить все старые объектные файлы.

# Глава 11.  
Модули Linux

В этой главе представлена ​​модульная система Linux. В нем содержится обзор того, как работают модули, описывается, как их устанавливать и удалять, а также представлен пример программы.

## 11.1   Обзор

Ядра Linux более поздние, чем 2.0, могут быть (и обычно) модульными. Часть ядра постоянно остается в памяти (наиболее часто используемые процессы, такие как планировщик), но другие процессы загружаются только при необходимости. Например, файловая система MS-DOS для чтения дисков может быть загружена только при монтировании такого диска, а затем выгружена, когда она больше не нужна. Это сохраняет пространство, требуемое ядру в любой момент времени, небольшим, позволяя ему делать все больше и больше. Еще можно поместить все в одно ``монолитное'' ядро, которое не будет нуждаться в модулях, но это обычно делается только для машин специального назначения (где все необходимые процессы известны заранее).

Еще одним преимуществом модулей является то, что ядро ​​может загружать и выгружать их динамически (и автоматически с помощью демона _kerneld_ ). Это означает, что (привилегированный) пользователь может загружать модуль, тестировать его, выгружать и многократно отлаживать без перезагрузки компьютера. В этом документе предполагается, что у пользователя есть права суперпользователя (вы должны быть root для установки и удаления модулей) и ядро ​​сконфигурировано для модулей. (С монолитным ядром можно установить параметры конфигурации, чтобы не разрешать даже модули.)

## 11.2   Запись, установка и удаление модулей

### 11.2.1   Написание модулей

Модули такие же, как и любые другие программы, за исключением того, что они работают в пространстве ядра. Таким образом, они должны определять MODULE и включать _module.h_ и любые другие заголовочные файлы ядра, которые определяют используемые ими функции или переменные. Модули могут быть очень простыми (как показано в примере), но могут быть и довольно сложными, например, драйверы устройств и целые файловые системы.

Это общий формат модуля:

#define МОДУЛЬ
#include <linux/module.h>
/* ... другие необходимые заголовочные файлы ... */
/*
 * ... объявления модулей и функции ...
 */
init_module() {
  /* код, который ядро ​​будет вызывать при установке модуля */
}
недействительным cleanup_module () {
  /* код, который ядро ​​будет вызывать при удалении модуля */
}

Модули, использующие исходный код ядра, должны быть скомпилированы с помощью _gcc_ с параметром -I/usr/src/linux/include ; это гарантирует, что включенные файлы будут из правильного исходного дерева.

Обратите внимание, что не все переменные ядра экспортируются для использования модулями, даже если код объявляет их как extern . Файл _/proc/ksyms_ или программа _ksyms_ отображают экспортированные символы (не многие из них полезны для работы в сети). Последние ядра Linux экспортируют как символ, так и номер его версии, используя макрос EXPORT_SYMBOL(x) . Для переменных, созданных пользователем, используйте макрос EXPORT_SYMBOL_NOVERS(x), иначе компоновщик не сохранит переменную в таблице символов ядра. Авторы модулей также могут использовать макрос EXPORT_NO_SYMBOLS ; модули экспортируют все свои переменные по умолчанию.

### 11.2.2   Установка и удаление модулей

Установка и удаление модулей так же проста, как вызов программы с именем скомпилированного модуля. (Вы должны быть суперпользователем, чтобы установить или удалить модуль.)

Программа _insmod_ устанавливает модуль; сначала он связывает модуль с экспортированной таблицей символов ядра для разрешения ссылок, а затем устанавливает код в пространстве ядра.

> /sbin/insmod _имя_модуля_

Программа _rmmod_ удаляет установленный модуль и все экспортированные им ссылки.

> /sbin/rmmod _имя_модуля_

Программа _lsmod_ перечисляет все установленные на данный момент модули:

    /sbin/lsmod
    Размер модуля, используемый
    cdrom 13368 0 (автоочистка) [ide-cd]
    3c59x 19112 1 (автоочистка)

## 11.3   Пример

Это полный пример очень простого модуля.

_простой_модуль.c_

/* simple_module.c
 *
 * Эта программа представляет собой пример того, как установить тривиальный модуль
 * в ядро ​​Linux. Все, что делает модуль, это помещает сообщение в
 * файл журнала при его установке и удалении.
 *
 */
#define МОДУЛЬ
#include <linux/module.h>
/* kernel.h содержит функцию printk */
#include <linux/kernel.h>
/********************************************************* *************** init_module
 * ядро ​​вызывает эту функцию при загрузке модуля */
init_module() {
  printk("<1>Простой модуль установился правильно.\n");
  вернуть 0;
} /* init_module */
/********************************************************* *********** cleanup_module
 * ядро ​​вызывает эту функцию при удалении модуля */
недействительным cleanup_module () {
  printk("<1>Простой модуль удален.\n");
} /* модуль очистки */

Это _Makefile_ :

# Makefile для простого_модуля
CC = gcc -I/usr/src/linux/include/config
CFLAGS = -O2 -D__KERNEL__ -Стена
простой_модуль.о: простой_модуль.с
установить:
	/sbin/insmod простой_модуль
удалять:
	/sbin/rmmod простой_модуль

Для использования (должен быть root ):

корень # сделать
корень # сделать установку
корень # сделать удалить
root# хвост /var/log/messages
... ядро: простой модуль установился правильно.
... ядро: теперь простой модуль удален.

# Глава 12.  
Файловая система _proc_

В этой главе представлена ​​виртуальная файловая система _proc_ . Он дает обзор того, как работает файловая система, показывает, как существующий сетевой код использует систему, и подробно описывает, как писать и использовать записи _proc_ из программ.

## 12.1   Обзор

Файловая система _proc_ названа так потому, что находится в каталоге _/proc_ на большинстве машин Linux. НЕ включение _proc_ FS является опцией конфигурации, но система является мощным инструментом, который часто используется многими программами. Хотя она разработана как файловая система со структурой каталогов и индексными дескрипторами, на самом деле она представляет собой конструкцию зарегистрированных функций, предоставляющих информацию о важных переменных.

В каталоге _proc_ есть много подкаталогов — по одному для каждого запущенного процесса и другие для подсистем, таких как файловые системы, интерфейсы, терминалы и сеть ( _/proc/net_ ). _В самом основном каталоге /proc_ также есть много файлов - _прерывания_ , _ioports_ , _loadavg_ и _версия_ , и это лишь некоторые из них. В каждом подкаталоге процесса (названном по номеру процесса) находятся файлы, описывающие командную строку процесса, текущий рабочий каталог, статус и т. д.

Ядро перехватывает доступ к _proc-_ файлам и вместо выполнения «обычных» файловых операций над ними вызывает специальные (индивидуально зарегистрированные) функции. Когда файл в каталоге _/proc_ "создается", он регистрируется с помощью набора функций, которые сообщают ядру, что делать, когда файл читается или записывается. Большинство записей позволяют только чтение, и они просто выводят состояние определенных системных переменных для использования другими программами или для прочтения знающими пользователями.

Единственная сложность в использовании _proc-_ файлов заключается в том, что ядро ​​вызывает функцию генерации информации каждый раз при чтении файла; последующие чтения изменяющегося файла без копирования и буферизации результатов могут привести к совершенно другим результатам. Лучший способ использовать файл _proc_ — прочитать его в буфер PAGE_SIZE -byte. Это приведет к чтению всей записи сразу, и тогда буфер разрешит согласованный произвольный доступ.

## 12.2 Файлы   сетевых _процессов_

Это список самых важных файлов в каталоге _/proc/net/_ , что они содержат, а также ссылка на функцию и файл, которые их создают. Обратите внимание, что есть много других интересных записей _proc_ , таких как файлы _/proc/sys_ , _/proc/ksyms_ и _/proc/modules,_ и это лишь некоторые из них.

**_арп_**

отображает таблицу соседей ( arp_tbl ); IP- и аппаратные адреса, тип оборудования, устройство и флаги. ( arp_get_info() : _сеть/ipv4/arp.c_ 988)

**_разработчик_**

отображает статистику приема и передачи для каждого зарегистрированного интерфейса

**_dev_stat_**

отображает количество отброшенных полученных пакетов и статистику дросселирования и FASTROUTE ( dev_proc_stats() : _net/core/dev.c_ 1228)

**_нетстат_**

отображает куки синхронизации, обрезку и статистику ICMP ( netstat_get_info() : _net/ipv4/proc.c_ 355)

**_сырой_**

отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета RAW из структуры proto raw_prot ( get__netinfo() : _net/ipv4/proc.c_ 165)

**_маршрут_**

отображает таблицу FIB ( main_table ); интерфейс, адрес, шлюз, флаги и информацию об использовании. ( fib_get_procinfo() ): _net/ipv4/fib_frontend.c_ 109)

**_rt_cache_**

отображает кеш маршрутизации ( rt_hash_table ); интерфейс, адрес, шлюз, использование, источник и другую информацию. ( rt_cache_get_info() : _net/ipv4/route.c_ 191)

**_носокстат_**

отображает количество использованных сокетов и некоторую статистику о количестве TCP, UDP и RAW ( afinet_get_info() : _net/ipv4/proc.c_ 244)

**_TCP_**

отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета TCP из структуры proto tcp_prot ( get__netinfo() : _net/ipv4/proc.c_ 165)

**_UDP_**

отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета UDP из структуры proto udp_prot ( get__netinfo() : _net/ipv4/proc.c_ 165)

## 12.3   Регистрация файлов _proc_

В этом разделе описывается простейший метод регистрации записи ``файла'' процесса только для чтения _(_ доступен только в Linux 2.0 и более поздних версиях). Можно создать более полнофункциональную запись, определив структуры file_operations и inode_operations . Однако этот метод значительно сложнее, чем представленный здесь; посмотрите в исходном коде подробности о реализации полнофункциональной записи. Описанный ниже метод — определение функции, а затем ее регистрация и отмена регистрации — обеспечивает большую часть функций, необходимых для тестирования и отслеживания системных ресурсов. Только ядро ​​может зарегистрировать файл _proc_ ; пользователи могут сделать это, создав и установив модули ядра (хотя только rootможет устанавливать и удалять модули). Эти процедуры предполагают, что исходный код Linux установлен, а ядро ​​скомпилировано для использования модулей.

### 12.3.1   Форматирование функции для предоставления информации

static int _read_proc_function_ (char *buf, char ** start, off_t offset, int len, int не используется)

Это функция, которую ядро ​​Linux будет вызывать всякий раз, когда оно попытается прочитать из только что созданного ``файла'' _proc_ . Единственным важным параметром обычно является buf — указатель на буфер, который ядро ​​делает доступным для хранения информации. Остальные обычно не меняются. ( _read_proc_function_ — это, конечно же, имя новой функции.)

Обычно эта функция выводит заголовок, перебирает список или таблицу, выводя ее содержимое (используя обычную процедуру sprintf ), и возвращает длину результирующей строки. Единственным ограничением является то, что размер буфера ( buf ) не должен превышать PAGE_SIZE байт (это не менее 4 КБ).

В качестве примера такой функции посмотрите на функцию fib_get_procinfo() , начинающуюся со строки 109 файла _net/ipv4/fib_frontend.c_ . Эта функция отображает содержимое основной таблицы FIB.

### 12.3.2   Создание записи _процесса_

Поскольку это часть файловой системы, записи нужен индексный дескриптор. Это легко построить с помощью структуры proc_dir_entry :

#include <linux/proc_fs.h>
структура proc_dir_entry new_proc_entry = {
   0, // low_ino - номер инода (0 для динамического)
   5, // namelen - длина имени записи
   "вход", // имя
   С_ИФРЕГ | S_IRUGO, // режим
   1, // nсвязей
   0, // uid - владелец
   0, // гид - группа
   0, // размер - не используется
   NULL, // ops — операции с инодом (используйте по умолчанию)
   &read_proc_function // read_proc - адрес функции чтения
                          // оставить пустым!
}

Содержимое этого блока можно использовать, как показано, просто заменив поля namelen , name и read_proc_function на нужные значения. Обратите внимание, что многие записи, определенные ядром, имеют предопределенные номера инодов (например, PROC_NET_ROUTE , часть перечисления, определенного в _include/linux/proc_fs.h_ .

В качестве примера записи такого типа посмотрите на функцию __init_func() , начинающуюся со строки 607 файла _net/ipv4/fib_frontend.c_ . Эта функция вызывает proc_net_register() (описанную ниже) с вновь созданной структурой proc_dir_entry .

### 12.3.3   Регистрация записи _о процедуре_

Как только функция чтения и запись inode готовы, остается только зарегистрировать новый ``файл'' в системе _proc_ .

int proc_register(struct proc_dir_entry *dir, struct proc_dir_entry *entry)  
int proc_net_register(struct proc_dir_entry *entry)

dir — это указатель на каталог, которому принадлежит запись — &proc_root и proc_net (определенные в _include/proc_fs.h_ ), вероятно, наиболее полезны. entry — это указатель на саму запись, созданную выше. Эти две функции идентичны, за исключением того, что proc_net_register автоматически использует каталог _/proc/net_ . Они возвращают либо 0 (успех), либо EAGAIN (если нет доступных инодов).

### 12.3.4   Отмена регистрации записи _процесса_

Когда запись больше не нужна, ее следует удалить, отменив ее регистрацию.

int proc_unregister(struct proc_dir_entry *dir,int inode)  
int proc_net_unregister(int inode)

dir — это каталог _proc_ , в котором находится файл, а inode — номер инода файла. (Инод доступен в поле struct proc_dir_entry.low_ino записи , если он не является константой.) Опять же, эти функции идентичны, за исключением того, что proc_net_unregister автоматически использует каталог _/proc/net_ . Они возвращают либо 0 (успех), либо EINVAL (если такой записи нет).

## 12.4   Пример

Это полный пример модуля, который устанавливает простую запись _proc_ .

_simple_entry.c_

/* simple_entry.c
 *
 * Эта программа дает пример того, как установить запись в
 * Файловая система /proc. Все, что делает эта запись, это отображает некоторые статистические данные.
 * информация об ИП.
 */
#define МОДУЛЬ
#include <linux/module.h>
/* proc_fs.h содержит proc_dir_entry и регистрацию/отмену регистрации прототипов */
#include <linux/proc_fs.h>
/* ip.h содержит переменную ip_statistics */
#include <net/ip.h>
/********************************************************* *********** show_ip_stats
 * эта функция вызывается файловой системой /proc, когда что-либо пытается прочитать
 * из файла /proc/simple_entry — он помещает часть ядра в глобальные
 * содержимое переменной ip_statistics в буфер возврата */
int show_ip_stats (char *buf, char ** start, off_t offset, int len, int unused) {
  len = sprintf(buf,"Некоторые IP-статистики:\nIP-переадресация");
  если (ip_statistics.IpForwarding)
    len += sprintf(buf+len,"on\n");
  еще
    len += sprintf(buf+len,"off\n");
  len += sprintf(buf+len,"TTL по умолчанию: %lu\n",ip_statistics.IpDefaultTTL);
  len += sprintf(buf+len,"Frag Creates: %lu\n",ip_statistics.IpFragCreates);
  /* это может показать больше.... */
  вернуть лен;
} /* show_ip_stats */
/********************************************************* *************** test_entry
 * эта структура является своего рода регистрационной формой для /proc FS; оно говорит
 * FS для выделения динамического индекса, дает «файлу» имя и дает
 * адрес функции для вызова при чтении файла */
структура proc_dir_entry test_entry = {
  0, /* low_ino - номер инода (0 для динамического) */
  12, /* namelen - длина имени записи */
  "simple_entry", /* имя */
  С_ИФРЕГ | S_IRUGO, /* режим */
  1, /* nссылки */
  0, /* uid - владелец */
  0, /* гид - группа */
  0, /* размер - не используется */
  NULL, /* ops — операции с inode (использовать по умолчанию) */
  &show_ip_stats /* read_proc - адрес функции чтения */
                         /* оставить пустым! */
};
/********************************************************* *************** init_module
 * эта функция устанавливает модуль; он просто регистрирует запись в каталоге
 * с файловой системой /proc */
init_module() {
  /* зарегистрировать функцию в proc FS */
  int err = proc_register(&proc_root,&test_entry);
  /* записываем результаты регистрации в лог */
  если (!ошибка)
    printk("<1> simple_entry: зарегистрирован с инодом %d.\n",
          test_entry.low_ino);
  еще
    printk("<1> simple_entry: ошибка регистрации, код %d.\n",err);
  вернуть ошибку;
} /* init_module */
/********************************************************* *********** cleanup_module
 * эта функция удаляет модуль; он просто отменяет регистрацию каталога
 * запись из /proc ФС */
недействительным cleanup_module () {
  /* отменить регистрацию функции в proc FS */
  int err = proc_unregister(&proc_root,test_entry.low_ino);
  /* записываем результаты отмены регистрации в лог */
  если (!ошибка)
    printk("<1> simple_entry: незарегистрированный инод %d.\n",
          test_entry.low_ino);
  еще
    printk("<1> simple_entry: ошибка отмены регистрации, код %d.\n",err);
} /* модуль очистки */

Это _Makefile_ :

# Makefile для simple_entry
CC = gcc -I/usr/src/linux/include
CFLAGS = -O2 -D__KERNEL__ -Стена
простая_запись.о: простая_запись.с
установить:
	/sbin/insmod простая_запись
удалять:
	/sbin/rmmod простая_запись

Для использования (должен быть root ):

корень # сделать
корень # сделать установку
root# cat /proc/simple_entry
Немного статистики IP:
IP-переадресация включена
Срок жизни по умолчанию: 64
Создание фрагментов: 0
корень # сделать удалить
root# хвост /var/log/messages
... ядро: simple_entry: зарегистрировано с инодом 4365.
... ядро: simple_entry: незарегистрированный инод 4365.

# Глава 13.  
Пример — дроппер пакетов

В этом примере эксперимента в ядро ​​вставляется подпрограмма, которая выборочно отбрасывает пакеты на заданный хост. В нем обсуждается размещение кода, обрисовываются данные фактического испытания, представлен упрощенный анализ результатов и включается сам код.

## 13.1   Обзор

Эта программа реализована в виде модуля, который при установке сравнивает адрес получателя каждого исходящего пакета с заданным адресом. Если они совпадают, процент этих пакетов отбрасывается случайным образом. Он делает это для всего IP-трафика, независимо от того, где он был сгенерирован и какой транспортный протокол он использует. Для реализации этого требуется модификация ядра (чтобы разрешить модулю доступ к функциям передачи) и модуль, который использует преимущества этой модификации.

## 13.2   Соображения

**Размещение кода**

Этот код может быть встроен непосредственно в ядро ​​или оформлен в виде модуля:

-   Ядро — это концептуально намного проще; простое добавление некоторого кода в ядро ​​является довольно простым делом. Однако он вносит полупостоянные изменения и требует много времени для отладки, поскольку для каждого изменения необходимо перекомпилировать, установить и перезагрузить все ядро.
-   Модуль — это намного безопаснее и проще, поскольку (супер) пользователь может безболезненно устанавливать, удалять и отлаживать модули. Однако для этого требуется доступ к ядру, который не всегда доступен — даже из модуля. Ядро не всегда экспортирует переменные, к которым может потребоваться доступ модулю. (См. обсуждение программы _ksyms_ в главе  [11.](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#module) )
-   Оба - это лучший метод; выполнив несколько незначительных модификаций кода ядра для экспорта необходимых переменных и использования модуля только в том случае, если он загружен, пользователь может один раз перекомпилировать ядро, а затем выполнять тесты и эксперименты с модулями. Это по-прежнему имеет тот недостаток, что открывает потенциальные дыры в безопасности системы, но поскольку только экспериментатор знает, как они реализованы, это минимальный риск.

**Уровень протокола**

Этот код может быть реализован на многих уровнях:

-   Драйвер устройства — это возможно, так как весь трафик проходит через устройство. Однако это нарушает многоуровневые протоколы и требует взлома (предположительно) стабильного аппаратного драйвера.
-   Универсальные функции устройства — это лучший выбор, так как это самый низкий уровень, через который проходит весь трафик (в частности, функции dev_queue_xmit() и netif_rx() ). Это по-прежнему нарушает многоуровневость протокола, но все модификации могут быть сделаны в одном разделе кода.
-   IP-протокол — это концептуально правильное место для вставки специальной функции во входные, маршрутизирующие или выходные подпрограммы. Однако это не подходит именно потому, что в реализации есть три разные процедуры, через которые может пройти пакет: ip_forward() (переадресованные пакеты), ip_queue_xmit() (пакеты TCP) или ip_build_xmit() (пакеты UDP). См. разделы кодирования в главах  [5](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sending)  и  [7](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#forward) , чтобы увидеть, как взаимодействуют эти подпрограммы. Эти функции были бы хорошим выбором для вставки дроппера специального назначения, но не того, который влияет на весь трафик.
-   Транспортный протокол — эти подпрограммы подходят для обработки определенных типов трафика (например, только UDP), но в данном примере они бесполезны.

## 13.3   Экспериментальные системы и тесты

Этот пример был реализован на двух компьютерах, подключенных через один маршрутизатор, как показано на рис.  [13.1](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_setup) ; маршрутизатор работает с модифицированным ядром и модулем отбрасывания пакетов. В общем примере это представляет трафик, проходящий между neon и eagle , а dodge/viper отбрасывает пакеты для eagle .

![x_setup.gif](https://www.cs.unh.edu/cnrg/people/gherrin/x_setup.gif)  

Рисунок 13.1: Настройка экспериментальной системы.

Коммутатор представляет собой Cisco Catalyst 2900, настроенный с виртуальными локальными сетями (VLAN) для каждой «подсети» (одна для исходного компьютера и одна для целевого компьютера, при этом маршрутизирующий компьютер действует как маршрутизатор между ними). ​​Коммутатор работает полностью на уровне канала и практически невидим для целей маршрутизации.

Маршрутизирующий компьютер ( dodge/viper ) представляет собой Dell Optiplex GX1 с процессором Pentium II/350 и 128 МБ оперативной памяти. Он имеет три карты Ethernet 3Com 3c59x с подключением к коммутатору на скорости 10 Мбит/с.

Один хост-компьютер ( neon ) представляет собой AST Premmia GX с процессором Pentium/100 и 32 МБ оперативной памяти. Он имеет карту AMD Lance Ethernet с подключением к коммутатору на скорости 10 Мбит/с.

Другой хост-компьютер ( eagle ) — это Dell Optiplex XL590 с процессором Pentium/90 и 32 МБ оперативной памяти. Он имеет карту Ethernet 3Com 3c509 с подключением к коммутатору на скорости 10 Мбит/с.

На всех компьютерах установлен дистрибутив Linux Red Hat 6.1; исходный и конечный компьютеры имеют стандартные перекомпилированные ядра версии 2.2.14, в то время как маршрутизатор использует либо стандартное (2.2.14) ядро, либо слегка модифицированное, как указано.

Первый эталонный тест представляет собой тест «пинг-понг», который устанавливает TCP-соединение, а затем повторно отправляет пакеты туда и обратно. Он возвращает общее время передачи (от начала до конца, не включая установление и закрытие соединения); деление времени на количество итераций дает среднее время приема-передачи (RTT). Этот тест был запущен с 20 000 итераций 5-байтовых пакетов и 5 000 итераций 500-байтовых пакетов.

Второй эталонный тест представляет собой «взрывной» тест, который устанавливает TCP-соединение, а затем отправляет данные из источника в пункт назначения. Он возвращает общее время передачи (от начала до конца, не включая установление и закрытие соединения); умножение количества пакетов на размер пакетов и деление на время дает пропускную способность. Этот тест был запущен с 50 000 5-байтовых пакетов, 5000 500-байтовых пакетов и 1000 1500-байтовых пакетов.

Тесты проводились на обеих машинах (т. е. с neon на eagle и с eagle на neon ), но в обоих случаях отбрасывались только пакеты на eagle . В каждом испытании взрывной тест запускался один раз с настройками по умолчанию (100 пакетов по 1 байту каждый) перед запуском тестов производительности «для записи», чтобы убедиться, что кэш маршрутизации и все таблицы протоколов находятся в нормализованном состоянии. Полный набор был запущен десять раз, чтобы зафиксировать различия между испытаниями (здесь представлены средние значения). Ни на одной из машин (включая маршрутизатор) не запускались какие-либо другие пользовательские программы, кроме оболочки входа в систему и соответствующего модуля, клиента или серверных программ (даже X Windows).

## 13.4   Результаты и предварительный анализ

### 13.4.1   Стандартное ядро

Это эталонные стандарты; эти подпрограммы выполнялись с двумя компьютерами, подключенными напрямую (НЕ маршрутизированными), и когда на маршрутизаторе было немодифицированное ядро ​​​​Linux 2.2.14. Частота ошибок при таком прямом соединении близка к нулю.

_настольный теннис_

                           Среднее время (сек) Среднее значение RTT (миллисекунды)
               Частота выпадения 20K@5 5K@500 20K@5 5K@500
Прямой -
 неон → орел: --- 17,24 28,98 0,86 5,80
 от орла до неона: --- 17,20 28,99 0,86 5,80
Маршрутизированный -
 неон → орел: (0,0%) 24,53 48,59 1,23 9,72
 от орла до неона: (0,0%) 24,36 48,46 1,22 9,69

_взрыв_

                               Среднее время (сек) Пропускная способность (Мбит/сек)
               Частота выпадения 50K*5 10K*500 1K*1500 50K*5 10K*500 1K*1500
Прямой -
 неон → орел: --- 0,56 3,19 1,89 3,55 6,26 6,36
 от орла до неона: --- 0,78 3,03 1,77 2,58 6,61 6,76
Маршрутизированный -
 от неона до орла: (0,0%) 0,56 3,19 1,92 3,60 6,27 6,26
 от орла до неона: (0,0%) 0,77 3,19 1,93 2,60 6,27 6,23

### 13.4.2   Отбрасывание пакетов модифицированного ядра

Это результаты экспериментов. Скорость отбрасывания 0,0 % обеспечивает эталон для измерения накладных расходов на вызов тестовых и случайных функций без отбрасывания каких-либо пакетов.

_настольный теннис_

                           Среднее время (сек) Среднее значение RTT (миллисекунды)
               Частота выпадения 20K@5 5K@500 20K@5 5K@500
неон к орлу: 0,0% 25,55 49,12 1,28 9,82
                  0,1% 29,87 51,11 1,49 10,22
                  0,5% 44,78 58,07 2,24 11,61
                  1,0% 65,37 68,77 3,27 13,75
                  5,0% 245,51 160,09 12,28 32,02
                 10,0% 506,03 290,77 25,30 58,15
орел к неону: 0,0% 25,53 49,21 1,28 9,84
                  0,1% 29,08 50,92 1,45 10,18
                  0,5% 45,87 59,21 2,29 11,84
                  1,0% 66,19 68,66 3,31 13,73
                  5,0% 235,68 156,94 11,78 31,39
                 10,0% 519,61 297,02 25,98 59,40

_взрыв_

                               Среднее время (сек) Пропускная способность (Мбит/сек)
               Частота выпадения 50K*5 10K*500 1K*1500 50K*5 10K*500 1K*1500
неон к орлу: 0,0% 0,55 3,19 1,91 3,64 6,26 6,27
                  0,1% 0,55 3,07 1,93 3,62 6,51 6,21
                  0,5% 0,55 2,95 1,76 3,64 6,77 6,82
                  1,0% 0,55 2,87 1,75 3,65 6,96 6,87
                  2,5% 0,59 3,36 2,04 3,38 5,59 5,90
                  5,0% 0,63 4,63 2,71 3,19 4,31 4,43
                 10,0% 1,06 7,08 5,11 1,89 2,83 2,35
                 20,0% 3,43 30,35 18,55 0,58 0,66 0,65
орел к неону: 0,0% 0,79 3,21 1,93 2,53 6,23 6,23
                  0,1% 0,77 3,22 1,89 2,59 6,20 6,35
                  0,5% 0,80 3,24 1,88 2,51 6,17 6,39
                  1,0% 0,77 3,24 1,91 2,60 6,17 6,27
                  2,5% 0,79 3,17 1,90 2,53 6,31 6,33
                  5,0% 0,78 3,17 1,91 2,57 6,31 6,29
                 10,0% 0,81 3,85 2,51 2,48 5,20 4,78
                 20,0% 2,02 4,06 2,51 0,99 4,92 4,78

### 13.4.3   Предварительный анализ

Далее следует элементарная проверка результатов. Он НЕ предназначен для исчерпывающего анализа, и действительно, эксперимент не был достаточно обширным, чтобы предоставить достоверные данные, из которых можно было бы сделать определенные выводы. Однако это демонстрирует множество вовлеченных факторов и эффектов, которые несколько строк кода могут оказать на сеть. Дальнейший анализ, при желании, оставляем читателю в качестве упражнения.

![x_pong.gif](https://www.cs.unh.edu/cnrg/people/gherrin/x_pong.gif)  

Рисунок 13.2: Результаты тестирования пинг-понга.

![x_blast.gif](https://www.cs.unh.edu/cnrg/people/gherrin/x_blast.gif)  

Рис. 13.3: Результаты тестов взрыва.

Модификации ядра и вставка модуля оказали небольшое, но измеримое влияние на TCP-соединение (измеряемое увеличением RTT). Для очень маленьких пакетов эта разница составляла примерно 0,05 мс; для больших пакетов это было 0,10 мс. Почему должна быть разница? Обратите внимание, что направление движения и размер пакета сильно повлияли на пропускную способность. Это указывает на то, что скорость процессора и накладные расходы на уровни влияют на RTT; для 1500-байтового пакета 66 байтов обертки (20 для TCP, 20 для IP и не менее 26 для Ethernet) не очень важны, но для 5-байтового пакета эти накладные расходы очень велики. Предположим, что фактическая "стоимость" вставки модуля равна задержке для больших пакетов, 0,10 мс.

Отбрасывание пакетов из TCP-соединения приводило к довольно линейному падению производительности в тесте пинг-понг; см. график на рис.  [13.2](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_pong) . Это ожидаемо; когда либо пакет, либо подтверждение потеряны, отправитель делает паузу, а затем отправляет снова. RTT также очень близок (конечно, в пределах ожидаемой экспериментальной ошибки) независимо от того, какая машина является "источником"; опять же, это потому, что эталонный тест проверяет поведение обеих машин одновременно.

При малых размерах пакетов пропускная способность сильно различалась в зависимости от способа отправки данных. Это потому, что одна машина ( орел ) была медленнее другой. Для большого количества очень маленьких пакетов узким местом в сети является не среда или интерфейс, а скорость, с которой процессор может создавать и отправлять пакеты. Однако при больших размерах пакетов пропускная способность (при низкой частоте ошибок) для обоих источников одинакова; в этом случае ограничивающим фактором является сеть, а не процессор.

Наиболее удивительным результатом является очевидный пик пропускной способности, когда уровень потерь составляет примерно 1%, что даже лучше, чем полное отсутствие потерь (для удаленных данных; потеря ACK, отправленных от получателя к источнику, оказала незначительное влияние). Это очень противоречивый вывод; почему потеря пакетов должна увеличивать пропускную способность? Ошибки в 1% может быть достаточно, чтобы алгоритм экспоненциальной отсрочки TCP не замедлил скорость трафика. Немедленный ACK, отправляемый получателем при поступлении неупорядоченного пакета, может включать информацию о размере окна, которая удерживает отправителя от паузы. Прерывания, вызванные неупорядоченными пакетами, могут привести к тому, что планировщик будет запускать процесс эталонного теста чаще, очищая окно буфера и снова не позволяя отправителю приостановить работу. Есть много потенциальных причин;

## 13.5   Код

### 13.5.1   Ядро

Следующий код добавляет в ядро ​​лазейку. Он создает функцию, которая будет вызываться (если она существует) из функции dev_queue_xmit() , и экспортирует ее, чтобы модули могли ее использовать. Эти строки добавляются непосредственно в исходный код; тогда ядро ​​должно быть перекомпилировано. установил, загрузился. Обратите внимание, что ядро ​​по-прежнему работает нормально (хотя и с одним дополнительным сравнением), пока не установлен тестовый модуль.

_net/core/dev.c_ (после строки 579)

...
int *test_function(struct sk_buff *)=0; /* новый */
int dev_queue_xmit(struct sk_buff *skb)...
    ... структура Qdisc *q;
    if (test_function && (*test_function)(skb)) { /* новый */
        kfree_skb(скб); /* новый */
        вернуть 0; /* новый */
    } /* новый */
#ifdef CONFIG_NET_PROFILE...

_net/netsyms.c_ (после строки 544)

...
extern int (*test_function)(struct sk_buff *); /* новый */
EXPORT_SYMBOL_NOVERS (тестовая_функция); /* новый */
EXPORT_SYMBOL(register_gifconf);...

### 13.5.2   Модуль

Ниже приведен код самого модуля отбрасывания пакетов. При установке он вычисляет процентное отсечение и помещает адрес в указатель функции, определенный выше. С этого момента любые пакеты, отправленные через dev_queue_xmit(), также будут проходить через функцию packet_dropper , которая сравнивает адрес назначения с жестко заданным. Если они совпадают и случайное число оказывается ниже расчетного порога, пакет отбрасывается; в противном случае пакеты проходят нетронутыми. Когда модуль удаляется, он снова сбрасывает указатель функции на 0 ( null ). (Обратите внимание, что этот не очень надежный код для простоты зависит от двухбайтовых коротких целых чисел. Функция get_random_bytes()доступен только ядру — или, конечно, модулям — и предоставляет случайные числа, которые являются «просто криптографически стойкими».)

_package_dropper.c_

/* package_dropper.c
 *
 * Эта программа представляет собой пример того, как установить модуль в
 * слегка измененное ядро, которое будет случайным образом отбрасывать пакеты для определенного
 * (жестко закодированный) хост.
 *
 * Подробную информацию о get_random_bytes() см. в linux/drivers/char/random.c.
 *
 * Использование (для использования должен быть root):
 * /sbin/insmod packet_dropper
 * /sbin/rmmod packet_dropper
 */
#define МОДУЛЬ
#define MAX_UNSIGNED_SHORT 65535
#include <linux/module.h>
#include <linux/skbuff.h> /* для структуры sk_buff */
#include <linux/ip.h> /* для структуры iphdr */
extern int (*test_function)(struct sk_buff *); /* вызов функции */
extern void get_random_bytes (void *buf, int nbytes); /* случайная функция */
беззнаковая короткая отсечка; /* сбрасываем отсечку */
плавающая ставка = 0,050; /* процент выпадения */
__u32 цель = 0x220010AC; /* 172.16.0.34 */
/********************************************************* *********** packet_dropper
 * это то, что будет вызывать dev_queue_xmit, пока этот модуль установлен */
int packet_dropper (структура sk_buff * skb) {
  беззнаковая короткая т;
  если (skb->nh.iph->daddr == target) {
    get_random_bytes(&t,2);
    если (t <= отсечка) вернуть 1; /* отбрасываем этот пакет */
  }
  вернуть 0; /* продолжить обычную процедуру */
} /* package_dropper */
/********************************************************* *************** init_module
 * эта функция заменяет нулевой указатель реальным */
init_module() {
  EXPORT_NO_SYMBOLS;
  отсечка = ставка * MAX_UNSIGNED_SHORT;
  test_function = разбрасыватель пакетов;
  printk("<1> packet_dropper: теперь пакеты отбрасываются\n");
  вернуть 0;
} /* init_module */
/********************************************************* *********** cleanup_module
 * эта функция сбрасывает указатель функции обратно на ноль */
недействительным cleanup_module () {
  тестовая_функция = 0;
  printk("<1> packet_dropper: деинсталлирован\n");
} /* модуль очистки */

# Глава 14  
Дополнительные ресурсы

## 14.1   Интернет-сайты

**Проект документации по Linux**

http://metalab.unc.edu/mdw/index.html

**Штаб-квартира Linux**

http://www.linuxhq.com

**Linux HOWTO**

ftp://metalab.unc.edu/pub/Linux/docs/HOWTO

**Руководство для хакеров ядра Linux**

http://metalab.unc.edu/mdw/LDP/khg/HyperNews/get/khg.html

**Проект Linux-маршрутизатора**

http://www.linuxrouter.org

**Новый ТТСР**

http://users.leo.org/ ~ бартель

**Программное обеспечение Red Hat**

http://www.redhat.com

**Запросы комментариев**

http://www.rfc-editor.org/isi.html

## 14.2   Книги

**Компьютерная сеть**

Таненбаум, Эндрю, Prentice-Hall Inc., Аппер-Сэддл-Ривер, Нью-Джерси, 1996.

**Высокоскоростные сети**

Столлингс, Уильям, Prentice-Hall Inc., Аппер-Сэдл-Ривер, Нью-Джерси, 1998.

**Комментарий к ядру Linux Core**

Максвелл, Скотт, CoriolisOpen Press, Скоттсдейл, Аризона, 1999.

**Драйверы устройств Linux**

Рубини, Алессандро, O'Reilly & Associates, Inc., Севастополь, Калифорния, 1998 г.

**Внутреннее устройство ядра Linux**

Бек, Майкл и др., Аддисон-Уэсли, Харлоу, Англия, 1997.

**Запуск Linux**

Уэлш, Мэтт, Далхеймер, Маттиас и Кауфман, Лар, O'Reilly & Associates, Inc., Севастополь, Калифорния, 1999.

**Сетевое программирование Unix, Vol. 1 (2-е изд.)**

Стивенс, В. Ричард, Prentice-Hall Inc., Аппер-Сэддл-Ривер, Нью-Джерси, 1998.

# Глава 15  
Сокращения

**ARP**

Протокол разрешения адресов

**банкомат**

Асинхронный режим передачи (протокол)

**BSD**

Распространение программного обеспечения Беркли

**DHCP**

Протокол динамической конфигурации оборудования

**DNS**

Сервер доменных имен

**ФРБ**

Экспедиторская информационная база

**графический интерфейс**

Графический пользовательский интерфейс

**ICMP**

Протокол контрольных сообщений Интернета

**ИНЕТ**

Интернет

**IP**

протокол Интернета

**Интернет-провайдер**

Интернет-провайдер

**локальная сеть**

Локальная сеть

**ЛДП**

Проект документации по Linux

**вот**

Loopback (устройство или интерфейс)

**МТУ**

Максимальная единица передачи

**ГЧП**

Протокол точка-точка

**РАРП**

Протокол обратного разрешения адресов

**РВАТЬ**

Протокол маршрутной информации

**РТТ**

Время в пути туда и обратно

**TCP**

Протокол управления передачей

**UDP**

Протокол пользовательских датаграмм

**UNH**

Университет Нью-Гэмпшира

**ВЛАН**

Виртуальная локальная сеть

**глобальная сеть**

Глобальная сеть