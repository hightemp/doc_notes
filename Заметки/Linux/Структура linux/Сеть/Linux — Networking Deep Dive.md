https://medium.com/geekculture/linux-networking-deep-dive-731848d791c0
# Linux — глубокое погружение в сеть

Вы знаете, как работает сетевой процесс Linux?

![](https://miro.medium.com/v2/resize:fit:700/1*Fg2E4bYl1PN6gDeYvsK7Aw.png)

Как и ЦП, память и ввод-вывод, сеть является основной функцией системы Linux. Сеть — это технология, которая соединяет различные компьютеры или сетевые устройства вместе.

По сути, это метод межпроцессного взаимодействия, особенно межпроцессное взаимодействие между системами, которое должно осуществляться через сеть.

С популяризацией таких технологий, как высокий параллелизм, распределение, облачные вычисления и микросервисы, хорошее понимание производительности сети становится все более и более важным.

# Сетевая модель

Когда дело доходит до сетей, я думаю, вы часто слышали о 7-уровневой модели OSI, 4-уровневой традиционной модели TCP/IP или 5-уровневой новой модели TCP/IP.

Фактически сетевая модель TCP/IP является производной от сетевой модели OSI (открытое системное взаимодействие). Чтобы решить проблему совместимости разнородных устройств в сетевом соединении и разделить сложный процесс обработки сетевых пакетов, модель OSI делит структуру сетевого соединения на следующие 7 уровней:

-   **Приложение** : отвечает за предоставление унифицированного интерфейса для приложений.
-   **Презентация** : отвечает за преобразование данных в формат, совместимый с принимающей системой.
-   **Сеанс** : отвечает за поддержание коммуникационных соединений между хостами.
-   **Транспорт** : отвечает за добавление транспортного заголовка к данным для формирования пакета данных.
-   **Сеть** : отвечает за маршрутизацию и пересылку данных.
-   **Канал передачи** **данных** : отвечает за MAC-адресацию, обнаружение и исправление ошибок.
-   **Физический** : отвечает за передачу кадров данных в физической сети.

Но модель OSI все еще слишком сложна, чтобы обеспечить достижимый подход. Итак, в Linux мы на самом деле используем другую, более практичную пятиуровневую модель (старая модель — четыре уровня), сетевую модель TCP/IP.

Схема отображения выглядит следующим образом:

![](https://miro.medium.com/v2/resize:fit:700/1*LcGaDm_ZOCbrIerM2UDj0g.png)

# Сетевой стек Linux

В модели TCP/IP во время передачи по сети пакеты данных будут обрабатываться слой за слоем в соответствии со стеком протоколов, а заголовок протокола верхнего уровня будет инкапсулирован и отправлен на следующий уровень.

Конечно, логика обработки сетевых пакетов на каждом уровне зависит от фактического сетевого протокола. Например, на прикладном уровне приложение, предоставляющее REST API, может использовать протокол HTTP, инкапсулировать данные JSON, необходимые для передачи, в протокол HTTP, а затем передавать их на уровень TCP.

Инкапсуляция очень проста, просто добавьте метаданные фиксированного формата до и после исходной загрузки, и исходные данные загрузки не будут изменены. Как показано на следующей диаграмме:

![](https://miro.medium.com/v2/resize:fit:700/1*oX8ySayqkY9o0enLDPE_zQ.png)

Как видите, новые заголовки и трейлеры увеличивают размер сетевых пакетов, но все мы знаем, что пакеты данных произвольного размера нельзя передавать по физическим каналам. Максимальная единица передачи (MTU), настроенная на сетевом интерфейсе, определяет максимальный размер IP-пакета. MTU по умолчанию обычно составляет 1500 байт.

Как только пакет превышает размер MTU, он будет фрагментирован на сетевом уровне, чтобы гарантировать, что размер фрагментированного IP-пакета не превышает MTU.

После понимания сетевой модели TCP/IP и принципа инкапсуляции сетевых пакетов вы легко можете подумать, что сетевой стек в ядре Linux на самом деле похож на пятиуровневую структуру TCP/IP. Как показано на следующем рисунке, это схематическая диаграмма общего стека IP-сети Linux:

![](https://miro.medium.com/v2/resize:fit:700/1*GGOBF1fvc_QW3-yzpHPQGg.png)

Давайте посмотрим на этот сетевой стек сверху вниз:

-   Приложение верхнего уровня должно взаимодействовать с интерфейсом сокета через системные вызовы.
-   Ниже сокета находится транспортный уровень, сетевой уровень
-   Нижний уровень — это драйвер сетевой карты и физическое устройство сетевой карты.

Сетевая карта — это основное устройство для отправки и получения сетевых пакетов. Во время запуска системы сетевая карта регистрируется в системе через драйвер сетевой карты в ядре. В процессе сетевой передачи и приема ядро ​​взаимодействует с сетевой картой через прерывания.

В сочетании с упомянутым выше сетевым стеком Linux можно увидеть, что обработка сетевых пакетов очень сложна. Следовательно, аппаратное прерывание сетевой карты обрабатывает только чтение или отправку основных данных сетевой карты, и большая часть логики в стеке протоколов будет помещена в мягкое прерывание для обработки.

# Сетевой процесс Linux

Разобравшись с сетевым стеком Linux, давайте посмотрим, как Linux отправляет и получает сетевые пакеты.

## Получение сетевых пакетов

Когда сетевой кадр поступает на сетевую карту, сетевая карта помещает сетевой пакет в очередь приема пакетов через DMA (прямой доступ к памяти); а затем сообщить обработчику прерывания, что сетевой пакет был получен через аппаратное прерывание.

Далее стек протоколов ядра извлекает сетевой фрейм из буфера и обрабатывает сетевой фрейм слой за слоем снизу вверх через сетевой стек:

-   Проверьте достоверность пакета на канальном уровне, определите тип сетевого протокола (IPv4 или IPv6), затем удалите заголовок и трейлер кадра и передайте его на сетевой уровень.
-   Сетевой уровень извлекает заголовок IP и определяет следующее направление сетевого пакета, например, передать ли его транспортному уровню или переслать. Если пакет остается на локальном компьютере, он удаляет заголовок IP и передает его на транспортный уровень.
-   После того, как транспортный уровень извлекает заголовок TCP/UDP, он находит соответствующий сокет в соответствии с четырехкратным идентификатором <исходный IP, исходный порт, целевой IP, целевой порт>, а затем копирует данные в приемный буфер сокета.
-   Наконец, приложение может использовать интерфейс сокета для чтения данных.

Я обобщил описанный выше процесс на следующем графике, чтобы помочь вам лучше понять процесс.

![](https://miro.medium.com/v2/resize:fit:700/1*e9YmYFnsU58ZuMSmFjWySA.png)

## Отправка сетевых пакетов

Поняв процесс получения сетевых пакетов, легко понять процесс отправки.

-   Сначала приложение вызывает API сокетов для отправки сетевых пакетов.
-   Поскольку это системный вызов, он будет перехвачен на уровне сокетов режима ядра. Уровень сокета поместит пакет данных в буфер отправки сокета.
-   Затем сетевой стек извлекает пакет данных из буфера отправки сокета, а затем обрабатывает его слой за слоем в соответствии со стеком TCP/IP.
-   Транспортный уровень добавляет к пакету TCP-заголовок.
-   Сетевой уровень добавляет к пакету IP-заголовок и выполняет фрагментацию в соответствии с размером MTU.
-   Фрагментированные сетевые пакеты отправляются на уровень канала передачи данных, который обращается к MAC-адресу и добавляет заголовок и конец кадра, кадр будет помещен в очередь отправки.
-   Затем канальный уровень инициирует мягкое прерывание, уведомляющее драйвер сетевой карты о появлении новых сетевых кадров в очереди пакетов.
-   Драйвер сетевой карты считывает сетевой кадр из очереди отправки пакетов через DMA и отправляет его через физическую сетевую карту.

# Заключение

Несколько серверов соединены друг с другом через сетевые устройства, такие как сетевые карты, коммутаторы и маршрутизаторы, для формирования взаимосвязанной сети. Из-за неоднородности сетевых устройств и сложности сетевых протоколов Международная организация по стандартизации определила семиуровневую сетевую модель OSI, но эта модель слишком сложна. Стандартом де-факто на практике является более практичная модель TCP/IP.

Модель TCP/IP делит структуру сетевого взаимодействия на пять уровней: прикладной уровень, транспортный уровень, сетевой уровень, уровень канала передачи данных и физический уровень, которые также являются основными компонентами сетевого стека Linux:

-   Прикладная программа отправляет пакеты данных через интерфейс сокета, которые должны быть обработаны слой за слоем сверху вниз в стеке сетевых протоколов и, наконец, отправлены на сетевую карту для отправки.
-   При получении он также обрабатывается слой за слоем снизу вверх сетевого стека, прежде чем окончательно отправится в приложение.