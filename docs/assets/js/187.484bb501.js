(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{458:function(n,t,e){"use strict";e.r(t);var r=e(14),o=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("https://golangify.com/logging")]),n._v(" "),t("h1",{attrs:{id:"логирование-в-golang-записываем-лог-в-фаил"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#логирование-в-golang-записываем-лог-в-фаил"}},[n._v("#")]),n._v(" Логирование в Golang — Записываем лог в файл")]),n._v(" "),t("p",[n._v("На данный момент в файле "),t("code",[n._v("main.go")]),n._v(" мы выводим лог с помощью функций "),t("code",[n._v("log.Printf()")]),n._v(" и "),t("code",[n._v("log.Fatal()")]),n._v(".")]),n._v(" "),t("p",[n._v("В Go, обе эти функции выводят сообщения через "),t("strong",[n._v("стандартный логгер")]),n._v(", который по умолчанию добавляет к сообщениям префиксы с локальной датой и временем и записывает их в стандартный поток ошибок (который должен отображаться в окне терминала). Функция "),t("code",[n._v("log.Fatal()")]),n._v(" также вызовет "),t("code",[n._v("os.Exit(1)")]),n._v(" после того как выведет в терминал сообщение об ошибке, это приведет к мгновенному завершению работы приложения.")]),n._v(" "),t("h3",{attrs:{id:"содержание-статьи"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#содержание-статьи"}},[n._v("#")]),n._v(" Содержание статьи")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://golangify.com/logging#decouple-logging",target:"_blank",rel:"noopener noreferrer"}},[n._v("Разделение логирования для разных задач"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://golangify.com/logging#http-server",target:"_blank",rel:"noopener noreferrer"}},[n._v("Логирование ошибок от HTTP-сервера"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://golangify.com/logging#additional-methods",target:"_blank",rel:"noopener noreferrer"}},[n._v("Дополнительные методы логирования"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://golangify.com/logging#concurent-logging",target:"_blank",rel:"noopener noreferrer"}},[n._v("Конкурентное логирование в Golang"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://golangify.com/logging#logging-file",target:"_blank",rel:"noopener noreferrer"}},[n._v("Логирование сообщений в файл"),t("OutboundLink")],1)])]),n._v(" "),t("p",[n._v("Логгирование можно поделить на два различных типа, или "),t("strong",[n._v("уровня")]),n._v(". К первому типу относятся "),t("strong",[n._v("информационные сообщения")]),n._v(" (вроде «"),t("em",[n._v("Запуск сервера на :4000")]),n._v("«), а ко второму типу относятся "),t("a",{attrs:{href:"https://golangs.org/errors",title:"ошибки в golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("сообщения об ошибках"),t("OutboundLink")],1),n._v(".")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('log.Printf("Запуск сервера на %s", *addr) // Информационное сообщение\n\nerr := http.ListenAndServe(*addr, mux)\n\nlog.Fatal(err) // Сообщение об фатальной ошибке в работе программы\n')])])]),t("p",[n._v("Давайте усовершенствуем наше приложение, добавив возможность "),t("strong",[n._v("многоуровнего логирования")]),n._v(", чтобы информационные сообщения и сообщения об ошибках обрабатывались по-разному. А именно:")]),n._v(" "),t("ul",[t("li",[n._v("Информационным сообщениям добавим префикс "),t("code",[n._v('"INFO"')]),n._v(". Такое сообщение будет выводиться в стандартный поток вывода (stdout);")]),n._v(" "),t("li",[n._v("Сообщениям об ошибках добавим префикс "),t("code",[n._v('"ERROR"')]),n._v(". Такие сообщения будут выводиться в "),t("strong",[n._v("стандартный поток ошибок")]),n._v(" (stderr) вместе с соответствующим названием файла и номером строки, которая вызвала логгер для записи (это поможет в отладке на будущее).")])]),n._v(" "),t("p",[n._v("Есть несколько способов использования разных логгеров, но самый простой и понятный подход заключается в использовании "),t("a",{attrs:{href:"https://golangs.org/func",title:"создание функции в golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("функции"),t("OutboundLink")],1),n._v(" "),t("code",[n._v("log.New()")]),n._v(" для создания двух новых настраиваемых логгеров.")]),n._v(" "),t("p",[n._v("Откройте файл "),t("code",[n._v("main.go")]),n._v(" и обновите его код следующим образом:")]),n._v(" "),t("p",[n._v("cmd/web/main.go")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package main\n\nimport (\n\n"flag"\n\n"log"\n\n"net/http"\n\n"os" // новый импорт\n\n)\n\nfunc main() {\n\naddr := flag.String("addr", ":4000", "Сетевой адрес веб-сервера")\n\nflag.Parse()\n\n// Используйте log.New() для создания логгера для записи информационных сообщений. Для этого нужно\n\n// три параметра: место назначения для записи логов (os.Stdout), строка\n\n// с префиксом сообщения (INFO или ERROR) и флаги, указывающие, какая\n\n// дополнительная информация будет добавлена. Обратите внимание, что флаги\n\n// соединяются с помощью оператора OR |.\n\ninfoLog := log.New(os.Stdout, "INFO\\t", log.Ldate|log.Ltime)\n\n// Создаем логгер для записи сообщений об ошибках таким же образом, но используем stderr как\n\n// место для записи и используем флаг log.Lshortfile для включения в лог\n\n// названия файла и номера строки где обнаружилась ошибка.\n\nerrorLog := log.New(os.Stderr, "ERROR\\t", log.Ldate|log.Ltime|log.Lshortfile)\n\nmux := http.NewServeMux()\n\nmux.HandleFunc("/", home)\n\nmux.HandleFunc("/snippet", showSnippet)\n\nmux.HandleFunc("/snippet/create", createSnippet)\n\nfileServer := http.FileServer(http.Dir("./ui/static/"))\n\nmux.Handle("/static/", http.StripPrefix("/static", fileServer))\n\n// Применяем созданные логгеры к нашему приложению.\n\ninfoLog.Printf("Запуск сервера на %s", *addr)\n\nerr := http.ListenAndServe(*addr, mux)\n\nerrorLog.Fatal(err)\n\n}\n')])])]),t("p",[n._v("Отлично… проверим эти изменения в действии!")]),n._v(" "),t("p",[n._v("Попробуйте запустить приложение, затем откройте другое окно терминала и попробуйте запустить его во второй раз. В результате должна появится сообщение об ошибке, потому что сетевой адрес, который наш сервер хочет прослушать ("),t("code",[n._v('":4000"')]),n._v("), уже используется другим процессом.")]),n._v(" "),t("p",[n._v("Логи во втором терминале должны выглядеть следующим образом:")]),n._v(" "),t("p",[n._v("go run ./cmd/web")]),n._v(" "),t("p",[n._v("INFO 2021/01/23 19:26:13 Запуск сервера на :4000")]),n._v(" "),t("p",[n._v("ERROR 2021/01/23 19:26:13 main.go:37: listen tcp :4000: bind: address already in use")]),n._v(" "),t("p",[n._v("exit status 1")]),n._v(" "),t("p",[n._v("Обратите внимание, что у этих двух сообщений разные префиксы — чтобы их можно было легко различить в терминале — и наше сообщение об ошибке также включает в себя название файла и номер строки ("),t("code",[n._v("main.go:37")]),n._v("), которая вызывает логгер для записи возникнувшей ошибки.")]),n._v(" "),t("blockquote",[t("p",[t("strong",[n._v("На заметку")]),n._v(": Если вы хотите включить весь путь файла в лог  вместо просто названия файла, при "),t("strong",[n._v("создании логгера")]),n._v(" можно использовать флаг "),t("code",[n._v("log.Llongfile")]),n._v(" вместо "),t("code",[n._v("log.Lshortfile")]),n._v(". Вы также можете заставить свой логгер  использовать "),t("a",{attrs:{href:"https://golangs.org/go/time",title:"дата и время в golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("UTC дату"),t("OutboundLink")],1),n._v(" (вместо локальной), добавив флаг "),t("code",[n._v("log.LUTC")]),n._v(".")])]),n._v(" "),t("h2",{attrs:{id:"разделение-логирования-для-разных-задач"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#разделение-логирования-для-разных-задач"}},[n._v("#")]),n._v(" Разделение логирования для разных задач")]),n._v(" "),t("p",[n._v("Большое преимущество логирования сообщений в стандартных потоках (stdout и stderr), как у нас, заключается в том, что само приложение и логирование не связаны. Само приложение не занимается маршрутизацией или "),t("strong",[n._v("хранением логов")]),n._v(", и это может упростить управление логами, которое будет различаться в зависимости от среды.")]),n._v(" "),t("p",[n._v("Стандартные потоки отображаются в терминале, поэтому вывод логов можно легко посмотреть после запуска приложения из терминала.")]),n._v(" "),t("p",[n._v("Если приложение запущено в рабочем режиме и обслуживает реальных пользователей, то наши логи должны записываться в специальном месте. Таким местом могут быть "),t("a",{attrs:{href:"https://golangs.org/go/filesystem",title:"работа с файлами на golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("файлы на диске"),t("OutboundLink")],1),n._v(" или различные сервисы мониторинга работы приложения. В любом случае, конечное место хранения логов может быть указано в самой среде выполнения независимо от приложения.")]),n._v(" "),t("p",[n._v("Например, можно перенаправить потоки из "),t("strong",[n._v("stdout")]),n._v(" и "),t("strong",[n._v("stderr")]),n._v(" в файлы на диске при "),t("a",{attrs:{href:"https://golangs.org/managing-configuration-settings",title:"приложение на go из терминала",target:"_blank",rel:"noopener noreferrer"}},[n._v("запуске приложения из терминала"),t("OutboundLink")],1),n._v(" следующим образом:")]),n._v(" "),t("p",[n._v("$ go run ./cmd/web >>/tmp/info.log 2>>/tmp/error.log")]),n._v(" "),t("h2",{attrs:{id:"логирование-ошибок-от-http-сервера"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#логирование-ошибок-от-http-сервера"}},[n._v("#")]),n._v(" Логирование ошибок от HTTP-сервера")]),n._v(" "),t("p",[n._v("Нам нужно внести еще одно изменение в коде нашего веб-приложения. По умолчанию, если HTTP-сервер обнаруживает ошибку, он логирует её с помощью "),t("strong",[n._v("стандартного логгера")]),n._v(". Но, лучше использовать наш новый логгер "),t("code",[n._v("errorLog")]),n._v(".")]),n._v(" "),t("p",[n._v("Нам требуется инициализировать "),t("a",{attrs:{href:"https://golangs.org/struct",title:"создать структуру в Golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("новую структуру"),t("OutboundLink")],1),n._v(" "),t("strong",[n._v("http.Server")]),n._v(", содержащую параметры конфигурации для сервера, вместо использования "),t("code",[n._v("http.ListenAndServe()")]),n._v(".")]),n._v(" "),t("p",[n._v("Проще всего будет показать это на примере:")]),n._v(" "),t("p",[n._v("cmd/web/main.go")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package main\n\nimport (\n\n"flag"\n\n"log"\n\n"net/http"\n\n"os"\n\n)\n\nfunc main() {\n\naddr := flag.String("addr", ":4000", "Сетевой адрес веб-сервера")\n\nflag.Parse()\n\ninfoLog := log.New(os.Stdout, "INFO\\t", log.Ldate|log.Ltime)\n\nerrorLog := log.New(os.Stderr, "ERROR\\t", log.Ldate|log.Ltime|log.Lshortfile)\n\nmux := http.NewServeMux()\n\nmux.HandleFunc("/", home)\n\nmux.HandleFunc("/snippet", showSnippet)\n\nmux.HandleFunc("/snippet/create", createSnippet)\n\nfileServer := http.FileServer(http.Dir("./ui/static/"))\n\nmux.Handle("/static/", http.StripPrefix("/static", fileServer))\n\n// Инициализируем новую структуру http.Server. Мы устанавливаем поля Addr и Handler, так\n\n// что сервер использует тот же сетевой адрес и маршруты, что и раньше, и назначаем\n\n// поле ErrorLog, чтобы сервер использовал наш логгер\n\n// при возникновении проблем.\n\nsrv := &http.Server{\n\nAddr:     *addr,\n\nErrorLog: errorLog,\n\nHandler:  mux,\n\n}\n\ninfoLog.Printf("Запуск сервера на %s", *addr)\n\n// Вызываем метод ListenAndServe() от нашей новой структуры http.Server\n\nerr := srv.ListenAndServe()\n\nerrorLog.Fatal(err)\n\n}\n')])])]),t("h3",{attrs:{id:"дополнительные-методы-логирования"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#дополнительные-методы-логирования"}},[n._v("#")]),n._v(" Дополнительные методы логирования")]),n._v(" "),t("p",[n._v("До сих пор мы использовали "),t("a",{attrs:{href:"https://golangs.org/methods",title:"методы в golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("методы"),t("OutboundLink")],1),n._v(" "),t("code",[n._v("Println()")]),n._v(", "),t("code",[n._v("Printf()")]),n._v(" и "),t("code",[n._v("Fatal()")]),n._v(" для записи логов. Однако Go предоставляет "),t("a",{attrs:{href:"https://golang.org/pkg/log/#Logger",target:"_blank",rel:"noopener noreferrer"}},[n._v("ряд других методов"),t("OutboundLink")],1),n._v(", с которыми стоит ознакомиться.")]),n._v(" "),t("p",[n._v("Как правило, лучше избегать использования методов "),t("code",[n._v("Panic()")]),n._v(" и "),t("code",[n._v("Fatal()")]),n._v(" за пределами "),t("a",{attrs:{href:"https://golangs.org/func",title:"функции в golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("функции"),t("OutboundLink")],1),n._v(" "),t("code",[n._v("main()")]),n._v(". Вместо этого рекомендуется возвращать возникшие ошибки, а "),t("a",{attrs:{href:"https://golangs.org/errors#using-panic",title:"panic golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("паниковать"),t("OutboundLink")],1),n._v(" или принудительно завершать приложение непосредственно из самого "),t("code",[n._v("main()")]),n._v(".")]),n._v(" "),t("h3",{attrs:{id:"конкурентное-логирование-в-golang"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#конкурентное-логирование-в-golang"}},[n._v("#")]),n._v(" Конкурентное логирование в Golang")]),n._v(" "),t("p",[n._v("Новые логгеры, созданные с помощью "),t("code",[n._v("log.New()")]),n._v(", "),t("strong",[n._v("конкурентно-безопасны")]),n._v(". Вы можете делиться одним логгером и использовать его в нескольких "),t("a",{attrs:{href:"https://golangs.org/goroutines",title:"горутины в голанг",target:"_blank",rel:"noopener noreferrer"}},[n._v("горутинах"),t("OutboundLink")],1),n._v(", не беспокоясь об возможных конфликтах между ними из за записи сообщений в одном и том же логгере.")]),n._v(" "),t("p",[n._v("Если у вас есть несколько логгеров, использующих для записи одно и то же место назначения, вам требуется убедиться, что базовый метод  "),t("code",[n._v("Write()")]),n._v(" также безопасен для "),t("strong",[n._v("конкурентного использования")]),n._v(".")]),n._v(" "),t("h2",{attrs:{id:"логирование-сообщении-в-фаил"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#логирование-сообщении-в-фаил"}},[n._v("#")]),n._v(" Логирование сообщений в файл")]),n._v(" "),t("p",[n._v("Как было сказано выше, лучше записывать вывод в стандартные потоки и перенаправлять вывод в файл при запуске приложения из командной строки. Но, если вы не хотите этого делать, всегда можно "),t("a",{attrs:{href:"https://golangs.org/open-file",title:"работа с файлами в Golang",target:"_blank",rel:"noopener noreferrer"}},[n._v("открыть файл в Go"),t("OutboundLink")],1),n._v(" и использовать его в качестве места назначения лога. Например:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('f, err := os.OpenFile("info.log", os.O_RDWR|os.O_CREATE, 0666)\n\nif err != nil {\n\n    log.Fatal(err)\n\n}\n\ndefer f.Close()\n\ninfoLog := log.New(f, "INFO\\t", log.Ldate|log.Ltime)\n')])])]),t("h3",{attrs:{id:"скачать-исходныи-код-саита"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#скачать-исходныи-код-саита"}},[n._v("#")]),n._v(" Скачать исходный код сайта")]),n._v(" "),t("p",[n._v("В конце каждой статьи, вы можете скачать готовый код нашего веб-приложения. В каждой статье мы обновляем код добавляя что-то новое.")])])}),[],!1,null,null,null);t.default=o.exports}}]);