(window.webpackJsonp=window.webpackJsonp||[]).push([[314],{582:function(e,n,s){"use strict";s.r(n);var t=s(14),r=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("https://nuancesprog.ru/p/8787/\nhttps://github.com/ukchukx/diesel-sqlite")]),e._v(" "),n("p",[e._v("В этой статье мы рассмотрим, как использовать SQLite (вместе с Diesel) и Rust как в файловом режиме, так и в режиме памяти.")]),e._v(" "),n("h2",{attrs:{id:"необходимые-условия"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#необходимые-условия"}},[e._v("#")]),e._v(" Необходимые условия")]),e._v(" "),n("p",[e._v("Кроме Rust и Diesel CLI, понадобится установить SQLite для вашей платформы:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# Linux\n$ sudo apt install sqlite3 libsqlite3-0 libsqlite3-dev\n\n# OSX\n$ brew install sqlite3\n")])])]),n("h2",{attrs:{id:"создаем-проект-коммит"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#создаем-проект-коммит"}},[e._v("#")]),e._v(" Создаём проект ("),n("a",{attrs:{href:"https://github.com/ukchukx/diesel-sqlite/commit/bd1f5209c522c9df1540cc1806821a4268870e7d",target:"_blank",rel:"noopener noreferrer"}},[e._v("коммит"),n("OutboundLink")],1),e._v(")")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ cargo new diesel-sqlite\n$ cd diesel-sqlite\n")])])]),n("p",[e._v("Добавляем следующие зависимости:")]),e._v(" "),n("ul",[n("li",[e._v("Diesel, предоставляющую средства объектно-реляционного отображения.")]),e._v(" "),n("li",[e._v("Actix web для уровня обработки запросов по протоколу HTTP.")]),e._v(" "),n("li",[e._v("Dotenv для работы с переменными окружения.")]),e._v(" "),n("li",[e._v("Uuid для генерирования ID.")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('[dependencies]\nactix-rt = "1.0"\nactix-web = "2.0"\nchrono = { version = "0.4.11", features = ["serde"] }\ndiesel = { version = "1.4.4", features = ["sqlite", "uuidv07", "chrono"] }\ndotenv = "0.15.0"\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\nuuid = { version = "0.8", features = ["serde", "v4"] }\n')])])]),n("p",[e._v("Далее создаём файл "),n("code",[e._v(".env")]),e._v(" с "),n("code",[e._v("DATABASE_URL")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("DATABASE_URL=users.db\n")])])]),n("h2",{attrs:{id:"инициализируем-diesel-и-создаем-скрипт-миграции-коммит"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#инициализируем-diesel-и-создаем-скрипт-миграции-коммит"}},[e._v("#")]),e._v(" Инициализируем Diesel и создаём скрипт миграции ("),n("a",{attrs:{href:"https://github.com/ukchukx/diesel-sqlite/commit/4c06113bb82a3ac66910f430e4274a154c3c02d2",target:"_blank",rel:"noopener noreferrer"}},[e._v("коммит"),n("OutboundLink")],1),e._v(")")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ diesel setup\n$ diesel migration generate create_users\n")])])]),n("p",[e._v("Добавляем следующие инструкции SQL в сгенерированные файлы миграции "),n("code",[e._v("up")]),e._v(" и "),n("code",[e._v("down")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("-- migrations/xxxx_create_users/up.sql\n\nCREATE TABLE IF NOT EXISTS users (\n  id CHARACTER(36) NOT NULL PRIMARY KEY,\n  email VARCHAR(60),\n  phone VARCHAR(20),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL\n);\n\nCREATE TRIGGER IF NOT EXISTS UpdateTimestamps AFTER UPDATE ON users\n  FOR EACH ROW WHEN NEW.updated_at <= OLD.updated_at \nBEGIN \n  update users set updated_at=CURRENT_TIMESTAMP where id=OLD.id;  \nEND;\n\n-- migrations/xxxx_create_users/down.sql\n\nDROP TRIGGER IF EXISTS UpdateTimestamps;\n\nDROP TABLE IF EXISTS users;\n")])])]),n("p",[e._v("Создаём таблицу "),n("code",[e._v("users")]),e._v(", запустив:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ diesel migration run\n")])])]),n("p",[e._v("После запуска Diesel должен создать для вас схему в "),n("code",[e._v("src/schema.rs")]),e._v(".")]),e._v(" "),n("p",[e._v("Давайте реорганизуем файлы в нашей базе данных:")]),e._v(" "),n("ul",[n("li",[e._v("Создадим каталог "),n("code",[e._v("db")]),e._v(" внутри каталога "),n("code",[e._v("src")]),e._v(".")]),e._v(" "),n("li",[e._v("Переместим "),n("code",[e._v("src/schema.rs")]),e._v(" в каталог "),n("code",[e._v("db")]),e._v(".")]),e._v(" "),n("li",[e._v("Обновим переменную "),n("code",[e._v("file")]),e._v(" в "),n("code",[e._v("diesel.toml")]),e._v(" из "),n("code",[e._v("src/schema.rs")]),e._v(" в "),n("code",[e._v("src/db/schema.rs")]),e._v(".")]),e._v(" "),n("li",[e._v("Создадим файл "),n("code",[e._v("models.rs")]),e._v(" в каталоге "),n("code",[e._v("db")]),e._v(".")])]),e._v(" "),n("p",[e._v("После этого создаём файл "),n("code",[e._v("src/db.rs")]),e._v(" вот с таким содержимым:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// src/db.rs\npub mod models;\npub mod schema;\n")])])]),n("h2",{attrs:{id:"создаем-модель-коммит"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#создаем-модель-коммит"}},[e._v("#")]),e._v(" Создаём модель ("),n("a",{attrs:{href:"https://github.com/ukchukx/diesel-sqlite/commit/537b998b7ce67197f07ab1cd6cc82b55d170d63a",target:"_blank",rel:"noopener noreferrer"}},[e._v("коммит"),n("OutboundLink")],1),e._v(")")]),e._v(" "),n("p",[e._v("Первым делом встроим наши миграции, так как для тестов понадобится использовать режим памяти SQLite. Кроме того, плюсом миграций является то, что они компилируются в наше приложение, создавая один исполняемый файл и удаляя эту зависимость в файловой системе.")]),e._v(" "),n("p",[e._v("Добавим "),n("code",[e._v("diesel_migrations")]),e._v(" к нашим зависимостям:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('# Cargo.toml\n\n[dependencies]\n# ...\ndiesel_migrations = "1.4.0"\n')])])]),n("p",[e._v("Добавим их в начало "),n("code",[e._v("main.rs")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// src/main.rs\n#[macro_use]\nextern crate diesel;\n#[macro_use]\nextern crate diesel_migrations;\n\nmod db;\n// ...\n")])])]),n("p",[e._v("В "),n("code",[e._v("src/db.rs")]),e._v(" вставим:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// src/db.rs\n\n// ...\nembed_migrations!();\n\npub fn establish_connection() -> SqliteConnection {\n    if cfg!(test) {\n        let conn = SqliteConnection::establish(":memory:")\n          .unwrap_or_else(|_| panic!("Error creating test database"));\n        \n        let _result = diesel_migrations::run_pending_migrations(&conn);        conn\n    } else {\n        dotenv().ok();\n    \n        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");\n    \n        SqliteConnection::establish(&database_url)\n          .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))\n    }\n}\n')])])]),n("p",[e._v("В "),n("code",[e._v("establish_connection()")]),e._v(" используем средства условной компиляции Rust для возврата соединения в памяти для тестов и подключения к файлу для обычных запусков.")]),e._v(" "),n("p",[e._v("Вставляем это в "),n("code",[e._v("src/db/models.rs")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('use uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse diesel::prelude::*;\n\nuse super::schema::users;\nuse super::schema::users::dsl::users as user_dsl;\n\n#[derive(Debug, Deserialize, Serialize, Queryable, Insertable)]\n#[table_name = "users"]\npub struct User {\n    pub id: String,\n    pub email: Option<String>,\n    pub phone: Option<String>,\n    pub created_at: chrono::NaiveDateTime,\n    pub updated_at: chrono::NaiveDateTime,\n}\n\nimpl User {\n    pub fn list(conn: &SqliteConnection) -> Vec<Self> {\n        user_dsl.load::<User>(conn).expect("Error loading users")\n    }  \n\n    pub fn by_id(id: &str, conn: &SqliteConnection) -> Option<Self> {\n        if let Ok(record) = user_dsl.find(id).get_result::<User>(conn) {\n            Some(record)\n        } else {\n            None\n        }\n    }   \n\n    pub fn by_email(email_str: &str, conn: &SqliteConnection) -> Option<Self> {\n        use super::schema::users::dsl::email; \n        if let Ok(record) = user_dsl.filter(email.eq(email_str)).first::<User>(conn) {\n            Some(record)\n        } else {\n            None\n        }\n    }\n\n    pub fn by_phone(phone_str: &str, conn: &SqliteConnection) -> Option<Self> {\n        use super::schema::users::dsl::phone;\n\n        if let Ok(record) = user_dsl.filter(phone.eq(phone_str)).first::<User>(conn) {\n            Some(record)\n        } else {\n            None\n        }\n    }\n\n    pub fn create(email: Option<&str>, phone: Option<&str>, conn: &SqliteConnection) -> Option<Self> {\n        let new_id = Uuid::new_v4().to_hyphenated().to_string();\n        \n        if email.is_none() && phone.is_none() {\n            return None\n        } \n                \n        if phone.is_some() {\n            if let Some(user) = Self::by_phone(&phone.unwrap(), conn) {\n                return Some(user)\n            } \n        }\n        \n        if email.is_some() {\n            if let Some(user) = Self::by_email(&email.unwrap(), conn) {\n                return Some(user)\n            } \n        }\n\n        let new_user = Self::new_user_struct(&new_id, phone, email);       \n\n        diesel::insert_into(user_dsl)\n            .values(&new_user)\n            .execute(conn)\n            .expect("Error saving new user");\n \n        Self::by_id(&new_id, conn)\n    }\n\n    fn new_user_struct(id: &str, phone: Option<&str>, email: Option<&str>) -> Self {\n        User {\n            id: id.into(),\n            email: email.map(Into::into),\n            phone: phone.map(Into::into),\n            created_at: chrono::Local::now().naive_local(),\n            updated_at: chrono::Local::now().naive_local(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod user_test;\n')])])]),n("p",[e._v("Сначала объявляем импорт и нашу пользовательскую структуру "),n("code",[e._v("User")]),e._v("."),n("br"),e._v("\nКаждый из методов "),n("code",[e._v("User")]),e._v(" принимает аргумент "),n("code",[e._v("SqliteConnection")]),e._v(", поэтому мы можем передать любое соединение (тестовое или другое), не меняя метода.")]),e._v(" "),n("p",[e._v("Для методов запроса Diesel возвращает "),n("code",[e._v("Result")]),e._v(", который мы преобразуем в "),n("code",[e._v("Option")]),e._v(" с "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/result/enum.Result.html#method.ok",target:"_blank",rel:"noopener noreferrer"}},[e._v(".ok()"),n("OutboundLink")],1),e._v(" для подтверждения нашего возвращаемого типа.")]),e._v(" "),n("p",[e._v("Прежде чем создавать новую запись "),n("code",[e._v("User")]),e._v(" в "),n("code",[e._v("create()")]),e._v(", сначала убеждаемся, что предоставленная электронная почта и/или телефон не существуют в базе данных.")]),e._v(" "),n("p",[e._v("В конце файла объявляем, что тесты объявлены в файле, расположенном в "),n("code",[e._v("src/db/models/user_test.rs")]),e._v(" по соглашению.")]),e._v(" "),n("p",[e._v("Вставляем эти тесты в файл:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('use crate::db::{establish_connection, models::User};\n\n#[test]\nfn create_user_with_phone_and_email() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = Some("123456789");\n\n    let user = User::create(email, phone, &conn).unwrap();\n\n    assert_eq!(user.email.unwrap().as_str(), email.unwrap());\n    assert_eq!(user.phone.unwrap().as_str(), phone.unwrap());\n}\n\n#[test]\nfn create_user_with_phone_only() {\n    let conn = establish_connection();\n    let email = None;\n    let phone = Some("123456789");\n\n    let user = User::create(email, phone, &conn).unwrap();\n\n    assert!(user.email.is_none());\n    assert_eq!(user.phone.unwrap().as_str(), phone.unwrap());\n}\n\n#[test]\nfn create_user_with_email_only() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = None;\n\n    let user = User::create(email, phone, &conn).unwrap();\n\n    assert_eq!(user.email.unwrap().as_str(), email.unwrap());\n    assert!(user.phone.is_none());\n}\n\n#[test]\nfn create_user_with_existing_email() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = None;\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::create(email, phone, &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n\n#[test]\nfn create_user_with_existing_phone() {\n    let conn = establish_connection();\n    let email = None;\n    let phone = Some("123456789");\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::create(email, phone, &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n\n#[test]\nfn list_users() {\n    let conn = establish_connection();\n    let email = None;\n    let phone = Some("123456789");\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::by_phone(&phone.unwrap(), &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n\n#[test]\nfn get_user_by_email() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = None;\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::by_email(&email.unwrap(), &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n\n#[test]\nfn get_user_by_email() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = None;\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::by_email(&email.unwrap(), &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n\n#[test]\nfn get_user_by_id() {\n    let conn = establish_connection();\n    let email = Some("test@email.com");\n    let phone = Some("123456789");\n\n    let user = User::create(email, phone, &conn).unwrap();\n    let existing_user = User::by_id(&user.id, &conn).unwrap();\n\n    assert_eq!(user.id, existing_user.id);\n}\n')])])]),n("h2",{attrs:{id:"добавляем-веб-сервис-коммит"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#добавляем-веб-сервис-коммит"}},[e._v("#")]),e._v(" Добавляем веб-сервис ("),n("a",{attrs:{href:"https://github.com/ukchukx/diesel-sqlite/commit/a987f138b2e9b74d818d09fafe28c7bb76e9357c",target:"_blank",rel:"noopener noreferrer"}},[e._v("коммит"),n("OutboundLink")],1),e._v(")")]),e._v(" "),n("p",[e._v("Обновим нашу зависимость "),n("code",[e._v("actix-web")]),e._v(", чтобы иметь средства тестирования, недоступные в версии 2.0, и добавим "),n("code",[e._v("r2d2")]),e._v(" для организации набора соединений:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('[dependencies]\n# ...\nactix-web = "3.0.0-alpha.1"\ndiesel = { version = "1.4.4", features = ["sqlite", "uuidv07", "r2d2", "chrono"] }\nr2d2 = "0.8.8"\nr2d2-diesel = "1.0.0"\n')])])]),n("p",[e._v("Теперь выполним рефакторинг "),n("code",[e._v("src/db.rs")]),e._v(" для использования набора соединений:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// src/db.rs\n// ...\nuse diesel::sqlite::SqliteConnection;\nuse r2d2_diesel::ConnectionManager;\nuse r2d2::Pool;\n\nembed_migrations!();\n\npub type DbPool = Pool<ConnectionManager<SqliteConnection>>;\n\npub fn run_migrations(conn: &SqliteConnection) {\n  let _ = diesel_migrations::run_pending_migrations(&*conn);\n}\n\npub fn establish_connection() -> DbPool {\n    if cfg!(test) {\n        let manager = ConnectionManager::<SqliteConnection>::new(":memory:");\n        let pool = r2d2::Pool::builder().build(manager).expect("Failed to create DB pool.");\n        \n        run_migrations(&pool.get().unwrap());        pool\n    } else {\n        dotenv().ok();\n    \n        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");\n        let manager = ConnectionManager::<SqliteConnection>::new(&database_url);\n        \n        r2d2::Pool::builder().build(manager).expect("Failed to create DB pool.")\n    }\n}\n\n')])])]),n("p",[e._v("Кроме того, отделим создание набора соединений для тестов от запуска миграций.")]),e._v(" "),n("p",[e._v("В каждом из наших тестов моделей мы меняем способ получения соединений с")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let conn = establish_connection();\n")])])]),n("p",[e._v("на")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let conn = establish_connection().get().unwrap();\n")])])]),n("p",[e._v("Создадим сервисный модуль "),n("code",[e._v("src/services.rs")]),e._v(" и вставим:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// src/services.rs\npub mod user;\n\n#[cfg(test)]\nmod user_test;\n")])])]),n("p",[e._v("Затем создадим сервисный файл пользователя "),n("code",[e._v("src/services/user.rs")]),e._v(" и вставим:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// src/services/user.rs\nuse actix_web::{HttpResponse, web};\nuse serde::{Serialize, Deserialize};\n\nuse crate::db::{DbPool, models::User};\n\n#[derive(Serialize, Deserialize)]\npub struct UserForm {\n    email: Option<String>,\n    phone: Option<String>,\n}\n\npub fn create(user_form: web::Json<UserForm>, pool: web::Data<DbPool>) -> HttpResponse {\n    let conn = pool.get().unwrap();\n\n    match User::create(user_form.email.as_deref(), user_form.phone.as_deref(), &conn) {\n        Some(user) => HttpResponse::Ok().json(user),\n        _ => HttpResponse::InternalServerError().json("Could not create user")\n    }\n}\n\npub fn index(pool: web::Data<DbPool>) -> HttpResponse {\n    let conn = pool.get().unwrap();\n\n    HttpResponse::Ok().json(User::list(&conn))\n}\n\npub fn get(id: web::Path<String>, pool: web::Data<DbPool>) -> HttpResponse {\n    let conn = pool.get().unwrap();\n\n    match User::by_id(&id, &conn) {\n        Some(user) => HttpResponse::Ok().json(user),\n        _ => HttpResponse::NotFound().json("Not Found")\n    }\n}\n\npub fn init_routes(cfg: &mut web::ServiceConfig) {\n    /* \n     * index: curl -i -X GET -H "Content-Type: application/json" http://localhost:5000/users\n     * get: curl -i -X GET -H "Content-Type: application/json" http://localhost:5000/users/<id>\n     * post: curl -i -X POST -H "Content-Type: application/json" -d \'{"email":"xxx", "phone": "yyy"}\' http://localhost:5000/users\n     */\n    \n    cfg.service(\n        web::resource("/users")\n            .route(web::post().to(create))\n            .route(web::get().to(index))\n    )\n    .service(\n        web::scope("/users")\n            .route("/{id}", web::get().to(get)),\n    );\n}\n')])])]),n("p",[n("code",[e._v("create()")]),e._v(", "),n("code",[e._v("index()")]),e._v(" и "),n("code",[e._v("get()")]),e._v(" создают, выводят списком и получают пользователя по id. "),n("code",[e._v("init_routes()")]),e._v(" добавляет наши маршруты на веб-сервер.")]),e._v(" "),n("p",[e._v("Затем обновим "),n("code",[e._v("src/main.rs")]),e._v(", чтобы запустить наш веб-сервер:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// src/main.rs\n\n// ...\n#[macro_use]\nextern crate serde_json;\nextern crate r2d2_diesel;\n\n// ...\nmod services;\n\n#[actix_rt::main]\nasync fn main() -> std::io::Result<()> {\n    use actix_web::{App, HttpServer, web::JsonConfig};\n\n    let conn_pool = db::establish_connection();    \n\n    HttpServer::new(move || {\n        App::new()\n            .data(conn_pool.clone())\n            .data(JsonConfig::default().limit(4096))\n            .configure(services::user::init_routes)\n    })\n    .bind("0.0.0.0:5000")?\n    .run()\n    .await\n}\n')])])]),n("p",[e._v("С этим обновлением наш сервис готов принимать и обслуживать запросы.")]),e._v(" "),n("p",[e._v("Теперь добавим тесты, чтобы убедиться в том, что сервис делает то, для чего он был создан. В "),n("code",[e._v("src/services/user_test.rs")]),e._v(" вставим:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// src/services/user_test.rs\nuse actix_web::{\n    App,\n    test::{read_body_json, read_body, init_service, TestRequest}\n};\n\nuse crate::{db::{models::User, establish_connection}, services::user::init_routes};\n\n#[actix_rt::test]\nasync fn create_user_from_api() {\n    let test_email   = "test@email.com";\n    let test_phone   = "123456789";\n    let request_body = json!({ "email": test_email, "phone": test_phone });\n    let conn_pool    = establish_connection();\n    let mut app      = init_service(App::new().data(conn_pool.clone()).configure(init_routes)).await;\n\n    let resp = TestRequest::post()\n      .uri("/users")\n      .set_json(&request_body)\n      .send_request(&mut app)\n      .await;\n\n    assert!(resp.status().is_success(), "Failed to create user");\n\n    let user: User = read_body_json(resp).await;\n\n    assert_eq!(user.email.unwrap(), test_email);\n    assert_eq!(user.phone.unwrap(), test_phone);\n}\n\n    let user: User = read_body_json(resp).await;\n\n    assert_eq!(user.email.unwrap(), test_email);\n    assert_eq!(user.phone.unwrap(), test_phone);\n}\n\n#[actix_rt::test]\nasync fn get_user_from_api_by_id() {\n    let test_email   = "test@email.com";\n    let test_phone   = "123456789";\n    let request_body = json!({ "email": test_email, "phone": test_phone });\n    let conn_pool    = establish_connection();\n    let mut app      = init_service(App::new().data(conn_pool.clone()).configure(init_routes)).await;\n\n    let create_resp = TestRequest::post()\n      .uri("/users")\n      .set_json(&request_body)\n      .send_request(&mut app)\n      .await;\n\n    assert!(create_resp.status().is_success(), "Failed to create user");\n\n    let created_user: User = read_body_json(create_resp).await;\n    println!("/users/{}", created_user.id);\n    \n    let resp = TestRequest::get()\n      .uri(format!("/users/{}", created_user.id).as_str())\n      .send_request(&mut app)\n      .await;\n\n    assert!(resp.status().is_success(), "Failed to get user");\n\n    let retrieved_user: User = read_body_json(resp).await;\n\n    assert_eq!(created_user.id, retrieved_user.id);\n}\n\n    let retrieved_user: User = read_body_json(resp).await;\n\n    assert_eq!(created_user.id, retrieved_user.id);\n}\n\n#[actix_rt::test]\nasync fn list_users_from_api() {\n    let test_email   = "test@email.com";\n    let test_phone   = "123456789";\n    let request_body = json!({ "email": test_email, "phone": test_phone });\n    let conn_pool    = establish_connection();\n    let mut app      = init_service(App::new().data(conn_pool.clone()).configure(init_routes)).await;\n\n    let mut list_resp = TestRequest::get().uri("/users").send_request(&mut app).await;\n    \n    assert!(list_resp.status().is_success(), "Failed to list users");\n\n    let mut body = read_body(list_resp).await;  \n    let mut retrieved_users: Vec<User> = serde_json::from_slice::<Vec<User>>(&body).unwrap();\n\n    assert_eq!(retrieved_users.len(), 0);\n\n    let create_resp = TestRequest::post()\n      .uri("/users")\n      .set_json(&request_body)\n      .send_request(&mut app)\n      .await;\n\n    assert!(create_resp.status().is_success(), "Failed to create user");\n    \n    list_resp = TestRequest::get().uri("/users").send_request(&mut app).await;\n\n    assert!(list_resp.status().is_success(), "Failed to list users");\n\n    body = read_body(list_resp).await;    \n    retrieved_users = serde_json::from_slice::<Vec<User>>(&body).unwrap();\n\n    assert_eq!(retrieved_users.len(), 1);\n}\n')])])]),n("p",[e._v("Полный код можно найти "),n("a",{attrs:{href:"https://github.com/ukchukx/diesel-sqlite",target:"_blank",rel:"noopener noreferrer"}},[e._v("здесь"),n("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);n.default=r.exports}}]);