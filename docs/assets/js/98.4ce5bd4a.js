(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{371:function(e,t,n){"use strict";n.r(t);var r=n(14),o=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),t("p",[t("strong",[e._v("Linux IP Networking"),t("br"),e._v("\nA Guide to the Implementation and Modification of the Linux Protocol Stack")])]),e._v(" "),t("h3",{attrs:{id:"glenn-herrin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glenn-herrin"}},[e._v("#")]),e._v(" "),t("em",[e._v("Glenn Herrin")])]),e._v(" "),t("p",[t("strong",[e._v("TR 00-04")])]),e._v(" "),t("p",[t("a",{attrs:{href:"http://www.cs.unh.edu/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Department of Computer Science"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"http://www.unh.edu/",target:"_blank",rel:"noopener noreferrer"}},[e._v("University of New Hampshire"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/www.unh.edu",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"may-31-2000"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#may-31-2000"}},[e._v("#")]),e._v(" "),t("em",[e._v("May 31, 2000")])]),e._v(" "),t("p",[t("strong",[e._v("Abstract")])]),e._v(" "),t("p",[e._v("This document is a guide to understanding how the Linux kernel (version 2.2.14 specifically) implements networking protocols, focused primarily on the Internet Protocol (IP). It is intended as a complete reference for experimenters with overviews, walk-throughs, source code explanations, and examples. The first part contains an in-depth examination of the code, data structures, and functionality involved with networking. There are chapters on initialization, connections and sockets, and receiving, transmitting, and forwarding packets. The second part contains detailed instructions for modifiying the kernel source code and installing new modules. There are chapters on kernel installation, modules, the "),t("em",[e._v("proc")]),e._v(" file system, and a complete example.")]),e._v(" "),t("h1",{attrs:{id:"contents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1  Introduction"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1  Background"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.2  Document Conventions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.3  Sample Network Example"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4  Copyright, License, and Disclaimer"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.5  Acknowledgements"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp2",target:"_blank",rel:"noopener noreferrer"}},[e._v("2  Message Traffic Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1  The Network Traffic Path"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2  The Protocol Stack"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.3  Packet Structure"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.4  Internet Routing"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3  Network Initialization"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2  Startup"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.1  The Network Initialization Script"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.2  "),t("em",[e._v("ifconfig")]),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.3  "),t("em",[e._v("route")]),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.4  Dynamic Routing Programs"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3  Examples"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.1  Home Computer"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.2  Host Computer on a LAN"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.3  Network Routing Computer"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4  Linux and Network Program Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4.1  "),t("em",[e._v("ifconfig")]),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4.2  "),t("em",[e._v("route")]),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4  Connections"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.2  Socket Structures"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.3  Sockets and Routing"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4  Connection Processes"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.1  Establishing Connections"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.2  Socket Call Walk-Through"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.3  Connect Call Walk-Through"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.4  Closing Connections"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.5  Close Walk-Through"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.5  Linux Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5  Sending Messages"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2  Sending Walk-Through"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.1  Writing to a Socket"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.2  Creating a Packet with UDP"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.3  Creating a Packet with TCP"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.4  Wrapping a Packet in IP"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.5  Transmitting a Packet"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.3  Linux Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp6",target:"_blank",rel:"noopener noreferrer"}},[e._v("6  Receiving Messages"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2  Receiving Walk-Through"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.1  Reading from a Socket (Part I)"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.2  Receiving a Packet"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.3  Running the Network "),t("code",[e._v("Bottom Half''](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.3)         [6.2.4  Unwrapping a Packet in IP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.4)         [6.2.5  Accepting a Packet in UDP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.5)         [6.2.6  Accepting a Packet in TCP](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.6)         [6.2.7  Reading from a Socket (Part II)](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.7)     [6.3  Linux Functions](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.3) [7  IP Forwarding](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp7)     [7.1  Overview](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.1)     [7.2  IP Forward Walk-Through](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2)         [7.2.1  Receiving a Packet](https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.1)         [7.2.2  Running the Network")]),e._v("Bottom Half''"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.3  Examining a Packet in IP"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.4  Forwarding a Packet in IP"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.5  Transmitting a Packet"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.3  Linux Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp8",target:"_blank",rel:"noopener noreferrer"}},[e._v("8  Basic Internet Protocol Routing"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2  Routing Tables"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.1  The Neighbor Table"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.2  The Forwarding Information Base"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.3  The Routing Cache"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.4  Updating Routing Information"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3  Linux Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp9",target:"_blank",rel:"noopener noreferrer"}},[e._v("9  Dynamic Routing with "),t("em",[e._v("routed")]),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2  How "),t("em",[e._v("routed")]),e._v(" Works"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2.1  Data Structures"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2.2  Initialization"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2.3  Normal Operations"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.3  "),t("em",[e._v("routed")]),e._v(" Functions"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp10",target:"_blank",rel:"noopener noreferrer"}},[e._v("10  Editing Linux Source Code"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.1  The Linux Source Tree"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2  Using EMACS Tags"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2.1  Referencing with TAGS"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2.2  Constructing TAGS files"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.3  Using vi tags"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.4  Rebuilding the Kernel"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.5  Patching the Kernel Source"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp11",target:"_blank",rel:"noopener noreferrer"}},[e._v("11  Linux Modules"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2  Writing, Installing, and Removing Modules"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2.1  Writing Modules"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2.2  Installing and Removing Modules"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.3  Example"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp12",target:"_blank",rel:"noopener noreferrer"}},[e._v("12  The "),t("em",[e._v("proc")]),e._v(" File System"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.2  Network "),t("em",[e._v("proc")]),e._v(" Files"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3  Registering "),t("em",[e._v("proc")]),e._v(" Files"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.1  Formatting a Function to Provide Information"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.2  Building a "),t("em",[e._v("proc")]),e._v(" Entry"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.3  Registering a "),t("em",[e._v("proc")]),e._v(" Entry"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.4  Unregistering a "),t("em",[e._v("proc")]),e._v(" Entry"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.4  Example"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp13",target:"_blank",rel:"noopener noreferrer"}},[e._v("13  Example - Packet Dropper"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.1  Overview"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.2  Considerations"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.3  Experimental Systems and Benchmarks"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4  Results and Preliminary Analysis"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4.1  Standard Kernel"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4.2  Modified Kernel Dropping Packets"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4.3  Preliminary Analysis"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5  Code"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5.1  Kernel"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5.2  Module"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp14",target:"_blank",rel:"noopener noreferrer"}},[e._v("14  Additional Resources"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("14.1  Internet Sites"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("14.2  Books"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp15",target:"_blank",rel:"noopener noreferrer"}},[e._v("15  Acronyms"),t("OutboundLink")],1)]),e._v(" "),t("h1",{attrs:{id:"chapter-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-1"}},[e._v("#")]),e._v(" Chapter 1")]),e._v(" "),t("p",[e._v("Introduction")]),e._v(" "),t("p",[e._v("This is version 1.0 of this document, dated May 31, 2000, referencing the Linux kernel version 2.2.14.")]),e._v(" "),t("h2",{attrs:{id:"_1-1-background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-background"}},[e._v("#")]),e._v(" 1.1  Background")]),e._v(" "),t("p",[e._v("Linux is becoming more and more popular as an alternative operating system. Since it is freely available to everyone as part of the open source movement, literally thousands of programmers are constantly working on the code to implement new features, improve existing ones, and fix bugs and inefficiencies in the code. There are many sources for learning more about Linux, from the source code itself (downloadable from the Internet) to books to ``HOW-TOs'' and message boards maintained on many different subjects.")]),e._v(" "),t("p",[e._v("This document is an effort to bring together many of these sources into one coherent reference on and guide to modifying the networking code within the Linux kernel. It presents the internal workings on four levels: a general overview, more specific examinations of network activities, detailed function walk-throughs, and references to the actual code and data structures. It is designed to provide as much or as little detail as the reader desires. This guide was written specifically about the Linux 2.2.14 kernel (which has already been superseded by 2.2.15) and many of the examples come from the Red Hat 6.1 distribution; hopefully the information provided is general enough that it will still apply across distributions and new kernels. It also focuses almost exclusively on TCP/UDP, IP, and Ethernet - which are the most common but by no means the only networking protocols available for Linux platforms.")]),e._v(" "),t("p",[e._v("As a reference for kernel programmers, this document includes information and pointers on editing and recompiling the kernel, writing and installing modules, and working with the "),t("em",[e._v("/proc")]),e._v(" file system. It also presents an example of a program that drops packets for a selected host, along with analysis of the results. Between the descriptions and the examples, this should answer most questions about how Linux performs networking operations and how you can modify it to suit your own purposes.")]),e._v(" "),t("p",[e._v("This project began in a Computer Science Department networking lab at the University of New Hampshire as an effort to institute changes in the Linux kernel to experiment with different routing algorithms. It quickly became apparent that blindly hacking the kernel was not a good idea, so this document was born as a research record and a reference for future programmers. Finally it became large enough (and hopefully useful enough) that we decided to generalize it, formalize it, and release it for public consumption.")]),e._v(" "),t("p",[e._v("As a final note, Linux is an ever-changing system and truly mastering it, if such a thing is even possible, would take far more time than has been spent putting this reference together. If you notice any misstatements, omissions, glaring errors, or even typos (!) within this document, please contact the person who is currently maintaining it. The goal of this project has been to create a freely available and useful reference for Linux programmers.")]),e._v(" "),t("h2",{attrs:{id:"_1-2-document-conventions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-document-conventions"}},[e._v("#")]),e._v(" 1.2  Document Conventions")]),e._v(" "),t("p",[e._v("It is assumed that the reader understands the C programming language and is acquainted with common network protocols. This is not vital for the more general information but the details within this document are intended for experienced programmers and may be incomprehensible to casual Linux users.")]),e._v(" "),t("p",[e._v("Almost all of the code presented requires superuser access to implement. Some of the examples can create security holes where none previously existed; programmers should be careful to restore their systems to a normal state after experimenting with the kernel.")]),e._v(" "),t("p",[e._v("File references and program names are written in a "),t("em",[e._v("slanted")]),e._v(" font.")]),e._v(" "),t("p",[e._v("Code, command line entries, and machine names are written in a typewriter font.")]),e._v(" "),t("p",[e._v("Generic entries or variables (such as an output filename) and comments are written in an "),t("em",[e._v("italic")]),e._v(" font.")]),e._v(" "),t("h2",{attrs:{id:"_1-3-sample-network-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-sample-network-example"}},[e._v("#")]),e._v(" 1.3  Sample Network Example")]),e._v(" "),t("p",[e._v("There are numerous examples in this document that help clarify the presented material. For the sake of consistency and familiarity, most of them reference the sample network shown in Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#i_example",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/i_example.gif",alt:"i_example.gif"}})]),e._v(" "),t("p",[e._v("Figure 1.1: Sample network structure.")]),e._v(" "),t("p",[e._v("This network represents the computer system at a fictional unnamed University (U!). It has a router connected to the Internet at large (chrysler). That machine is connected (through the jeep interface) to the campus-wide network, u.edu, consisting of computers named for Chrysler owned car companies (dodge, eagle, etc.). There is also a LAN subnet for the computer science department, cs.u.edu, whose hosts are named after Dodge vehicle models (stealth, neon, etc.). They are connected to the campus network by the dodge/viper computer. Both the u.edu and cs.u.edu networks use Ethernet hardware and protocols.")]),e._v(" "),t("p",[e._v("This is obviously not a real network. The IP addresses are all taken from the block reserved for class B private networks (that are not guaranteed to be unique). Most real class B networks would have many more computers, and a network with only eight computers would probably not have a subnet. The connection to the Internet (through chrysler) would usually be via a T1 or T3 line, and that router would probably be a ``real'' router (i.e. a Cisco Systems hardware router) rather than a computer with two network cards. However, this example is realistic enough to serve its purpose: to illustrate the the Linux network implementation and the interactions between hosts, subnets, and networks.")]),e._v(" "),t("h2",{attrs:{id:"_1-4-copyright-license-and-disclaimer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-copyright-license-and-disclaimer"}},[e._v("#")]),e._v(" 1.4  Copyright, License, and Disclaimer")]),e._v(" "),t("p",[e._v("Copyright (c) 2000 by Glenn Herrin. This document may be freely reproduced in whole or in part provided credit is given to the author with a line similar to the following:")]),e._v(" "),t("blockquote",[t("p",[e._v("Copied from Linux IP Networking, available at "),t("em",[t("a",{attrs:{href:"http://www.cs.unh.edu/cnrg/gherrin",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.cs.unh.edu/cnrg/gherrin"),t("OutboundLink")],1)]),e._v(".")])]),e._v(" "),t("p",[e._v("(The visibility of the credit should be proportional to the amount of the document reproduced!) Commercial redistribution is permitted and encouraged. All modifications of this document, including translations, anthologies, and partial documents, must meet the following requirements:")]),e._v(" "),t("ol",[t("li",[e._v("Modified versions must be labeled as such.")]),e._v(" "),t("li",[e._v("The person making the modifications must be identified.")]),e._v(" "),t("li",[e._v("Acknowledgement of the original author must be retained.")]),e._v(" "),t("li",[e._v("The location of the original unmodified document be identified.")]),e._v(" "),t("li",[e._v("The original author's name may not be used to assert or imply endorsement of the resulting document without the original author's permission.")])]),e._v(" "),t("p",[e._v("Please note any modifications including deletions.")]),e._v(" "),t("p",[e._v("This is a variation (changes are intentional) of the Linux Documentaion Project (LDP) License available at:")]),e._v(" "),t("blockquote",[t("p",[t("em",[t("a",{attrs:{href:"http://www.linuxdoc.org/COPYRIGHT.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.linuxdoc.org/COPYRIGHT.html"),t("OutboundLink")],1)])])]),e._v(" "),t("p",[e._v("This document is not currently part of the LDP, but it may be submitted in the future.")]),e._v(" "),t("p",[e._v("This document is distributed in the hope that it will be useful but (of course)without any given or implied warranty of fitness for any purpose whatsoever. Use it at your own risk.")]),e._v(" "),t("h2",{attrs:{id:"_1-5-acknowledgements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-acknowledgements"}},[e._v("#")]),e._v(" 1.5  Acknowledgements")]),e._v(" "),t("p",[e._v("I wrote this document as part of my Master's project for the Computer Science Department of the University of New Hampshire. I would like to thank Professor Pilar de la Torre for setting up the project and Professor Radim Bartos for being both a sponsor and my advisor - giving me numerous pointers, much encouragement, and a set of computers on which to experiment. I would also like to credit the United States Army, which has been my home for 11 years and paid for my attendance at UNH.")]),e._v(" "),t("p",[e._v("Glenn Herrin"),t("br"),e._v("\nMajor, United States Army"),t("br"),e._v("\nPrimary Documenter and Researcher, Version 1.0"),t("br"),e._v("\ngherrin@cs.unh.edu")]),e._v(" "),t("h1",{attrs:{id:"chapter-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2"}},[e._v("#")]),e._v(" Chapter 2")]),e._v(" "),t("p",[e._v("Message Traffic Overview")]),e._v(" "),t("p",[e._v("This chapter presents an overview of the entire Linux messaging system. It provides a discussion of configurations, introduces the data structures involved, and describes the basics of IP routing.")]),e._v(" "),t("h2",{attrs:{id:"_2-1-the-network-traffic-path"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-the-network-traffic-path"}},[e._v("#")]),e._v(" 2.1  The Network Traffic Path")]),e._v(" "),t("p",[e._v("The Internet Protocol (IP) is the heart of the Linux messaging system. While Linux (more or less) strictly adheres to the layering concept - and it is possible to use a different protocol (like ATM) - IP is almost always the nexus through which packets flow. The IP implementation of the network layer performs routing and forwarding as well as encapsulating data. See Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_path",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1"),t("OutboundLink")],1),e._v(" for a simplified diagram of how network packets move through the Linux kernel.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/o_path.gif",alt:"o_path.gif"}})]),e._v(" "),t("p",[e._v("Figure 2.1: Abstraction of the Linux message traffic path.")]),e._v(" "),t("p",[e._v("When an application generates traffic, it sends packets through sockets to a transport layer (TCP or UDP) and then on to the network layer (IP). In the IP layer, the kernel looks up the route to the host in either the routing cache or its Forwarding Information Base (FIB). If the packet is for another computer, the kernel addresses it and then sends it to a link layer output interface (typically an Ethernet device) which ultimately sends the packet out over the physical medium.")]),e._v(" "),t("p",[e._v("When a packet arrives over the medium, the input interface receives it and checks to see if the packet is indeed for the host computer. If so, it sends the packet up to the IP layer, which looks up the route to the packet's destination. If the packet has to be forwarded to another computer, the IP layer sends it back down to an output interface. If the packet is for an application, it sends it up through the transport layer and sockets for the application to read when it is ready.")]),e._v(" "),t("p",[e._v("Along the way, each socket and protocol performs various checks and formatting functions, detailed in later chapters. The entire process is implemented with references and jump tables that isolate each protocol, most of which are set up during initialization when the computer boots. See Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#initialization",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),t("OutboundLink")],1),e._v(" for details of the initialization process.")]),e._v(" "),t("h2",{attrs:{id:"_2-2-the-protocol-stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-the-protocol-stack"}},[e._v("#")]),e._v(" 2.2  The Protocol Stack")]),e._v(" "),t("p",[e._v("Network devices form the bottom layer of the protocol stack; they use a link layer protocol (usually Ethernet) to communicate with other devices to send and receive traffic. Input interfaces copy packets from a medium, perform some error checks, and then forward them to the network layer. Output interfaces receive packets from the network layer, perform some error checks, and then send them out over the medium.")]),e._v(" "),t("p",[e._v("IP is the standard network layer protocol. It checks incoming packets to see if they are for the host computer or if they need to be forwarded. It defragments packets if necessary and delivers them to the transport protocols. It maintains a database of routes for outgoing packets; it addresses and fragments them if necessary before sending them down to the link layer.")]),e._v(" "),t("p",[e._v("TCP and UDP are the most common transport layer protocols. UDP simply provides a framework for addressing packets to ports within a computer, while TCP allows more complex connection based operations, including recovery mechanisms for packet loss and traffic management implementations. Either one copies the packet's payload between user and kernel space. However, both are just part of the intermediate layer between the applications and the network.")]),e._v(" "),t("p",[e._v("IP Specific INET Sockets are the data elements and implementations of generic sockets. They have associated queues and code that executes socket operations such as reading, writing, and making connections. They act as the intermediary between an application's generic socket and the transport layer protocol.")]),e._v(" "),t("p",[e._v("Generic BSD Sockets are more abstract structures that contain INET sockets. Applications read from and write to BSD sockets; the BSD sockets translate the operations into INET socket operations. See Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#connect",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),t("OutboundLink")],1),e._v(" for more on sockets.")]),e._v(" "),t("p",[e._v("Applications, run in user space, form the top level of the protocol stack; they can be as simple as two-way chat connection or as complex as the Routing Information Protocol (RIP - see Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),t("OutboundLink")],1),e._v(").")]),e._v(" "),t("h2",{attrs:{id:"_2-3-packet-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-packet-structure"}},[e._v("#")]),e._v(" 2.3  Packet Structure")]),e._v(" "),t("p",[e._v("The key to maintaining the strict layering of protocols without wasting time copying parameters and payloads back and forth is the common packet data structure (a socket buffer, or sk_buff - Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_skbuff",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2"),t("OutboundLink")],1),e._v("). Throughout all of the various function calls as the data makes it way through the protocols, the payload data is copied only twice; once from user to kernel space and once from kernel space to output medium (for an outbound packet).")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/o_skbuff.gif",alt:"o_skbuff.gif"}})]),e._v(" "),t("p",[e._v("Figure 2.2: Packet (sk_buff) structure.")]),e._v(" "),t("p",[e._v("This structure contains pointers to all of the information about a packet - its socket, device, route, data locations, etc. Transport protocols create these packet structures from output buffers, while device drivers create them for incoming data. Each layer then fills in the information that it needs as it processes the packet. All of the protocols - transport (TCP/UDP), internet (IP), and link level (Ethernet) - use the same socket buffer.")]),e._v(" "),t("h2",{attrs:{id:"_2-4-internet-routing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-internet-routing"}},[e._v("#")]),e._v(" 2.4  Internet Routing")]),e._v(" "),t("p",[e._v("The IP layer handles routing between computers. It keeps two data structures; a Forwarding Information Base (FIB) that keeps track of all of the details for every known route, and a faster routing cache for destinations that are currently in use. (There is also a third structure - the neighbor table - that keeps track of computers that are physically connected to a host.)")]),e._v(" "),t("p",[e._v("The FIB is the primary routing reference; it contains up to 32 zones (one for each bit in an IP address) and entries for every known destination. Each zone contains entries for networks or hosts that can be uniquely identified by a certain number of bits - a network with a netmask of 255.0.0.0 has 8 significant bits and would be in zone 8, while a network with a netmask of 255.255.255.0 has 24 significant bits and would be in zone 24. When IP needs a route, it begins with the most specific zones and searches the entire table until it finds a match (there should always be at least one default entry). The file "),t("em",[e._v("/proc/net/route")]),e._v(" has the contents of the FIB.")]),e._v(" "),t("p",[e._v("The routing cache is a hash table that IP uses to actually route packets. It contains up to 256 chains of current routing entries, with each entry's position determined by a hash function. When a host needs to send a packet, IP looks for an entry in the routing cache. If there is none, it finds the appropriate route in the FIB and inserts a new entry into the cache. (This entry is what the various protocols use to route, not the FIB entry.) The entries remain in the cache as long as they are being used; if there is no traffic for a destination, the entry times out and IP deletes it. The file "),t("em",[e._v("/proc/net/rt_cache")]),e._v(" has the contents of the routing cache.")]),e._v(" "),t("p",[e._v("These tables perform all the routing on a normal system. Even other protocols (such as RIP) use the same structures; they just modify the existing tables within the kernel using the ioctl() function. See Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#routing",target:"_blank",rel:"noopener noreferrer"}},[e._v("8"),t("OutboundLink")],1),e._v(" for routing details.")]),e._v(" "),t("h1",{attrs:{id:"chapter-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-3"}},[e._v("#")]),e._v(" Chapter 3")]),e._v(" "),t("p",[e._v("Network Initialization")]),e._v(" "),t("p",[e._v("This chapter presents network initialization on startup. It provides an overview of what happens when the Linux operating system boots, shows how the kernel and supporting programs "),t("em",[e._v("ifconfig")]),e._v(" and "),t("em",[e._v("route")]),e._v(" establish network links, shows the differences between several example configurations, and summarizes the implementation code within the kernel and network programs.")]),e._v(" "),t("h2",{attrs:{id:"_3-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-overview"}},[e._v("#")]),e._v(" 3.1  Overview")]),e._v(" "),t("p",[e._v("Linux initializes routing tables on startup only if a computer is configured for networking. (Almost all Linux machines do implement networking, even stand-alone machines, if only to use the loopback device.) When the kernel finishes loading itself, it runs a set of common but system specific utility programs and reads configuration files, several of which establish the computer's networking capabilities. These determine its own address, initialize its interfaces (such as Ethernet cards), and add critical and known static routes (such as one to a router that connects it with the rest of the Internet). If the computer is itself a router, it may also execute a program that allows it to update its routing tables dynamically (but this is NOT run on most hosts).")]),e._v(" "),t("p",[e._v("The entire configuration process can be static or dynamic. If addresses and names never (or infrequently) change, the system administrator must define options and variables in files when setting up the system. In a more mutable environment, a host will use a protocol like the Dynamic Hardware Configuration Protocol (DHCP) to ask for an address, router, and DNS server information with which to configure itself when it boots. (In fact, in either case, the administrator will almost always use a GUI interface - like Red Hat's Control Panel - which automatically writes the configuration files shown below.)")]),e._v(" "),t("p",[e._v("An important point to note is that while most computers running Linux start up the same way, the programs and their locations are not by any means standardized; they may vary widely depending on distribution, security concerns, or whim of the system administrator. This chapter presents as generic a description as possible but assumes a Red Hat Linux 6.1 distribution and a generally static network environment.")]),e._v(" "),t("h2",{attrs:{id:"_3-2-startup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-startup"}},[e._v("#")]),e._v(" 3.2  Startup")]),e._v(" "),t("p",[e._v("When Linux boots as an operating system, it loads its image from the disk into memory, unpacks it, and establishes itself by installing the file systems and memory management and other key systems. As the kernel's last (initialization) task, it executes the "),t("em",[e._v("init")]),e._v(" program. This program reads a configuration file ("),t("em",[e._v("/etc/inittab")]),e._v(") which directs it to execute a startup script (found in "),t("em",[e._v("/etc/rc.d")]),e._v(" on Red Hat distributions). This in turn executes more scripts, eventually including the network script ("),t("em",[e._v("/etc/rc.d/init.d/network")]),e._v("). (See Section "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_i_examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3"),t("OutboundLink")],1),e._v(" for examples of the script and file interactions.)")]),e._v(" "),t("h3",{attrs:{id:"_3-2-1-the-network-initialization-script"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-the-network-initialization-script"}},[e._v("#")]),e._v(" 3.2.1  The Network Initialization Script")]),e._v(" "),t("p",[e._v("The network initialization script sets environment variables to identify the host computer and establish whether or not the computer will use a network. Depending on the values given, the network script turns on (or off) IP forwarding and IP fragmentation. It also establishes the default router for all network traffic and the device to use to send such traffic. Finally, it brings up any network devices using the "),t("em",[e._v("ifconfig")]),e._v(" and "),t("em",[e._v("route")]),e._v(" programs. (In a dynamic environment, it would query the DHCP server for its network information instead of reading its own files.)")]),e._v(" "),t("p",[e._v("The script(s) involved in establishing networking can be very straightforward; it is entirely possible to have one big script that simply executes a series of commands that will set up a single machine properly. However, most Linux distributions come with a large number of generic scripts that work for a wide variety of machine setups. This leaves a lot of indirection and conditional execution in the scripts, but actually makes setting up any one machine much easier. For example, on Red Hat distributions, the "),t("em",[e._v("/etc/rc.d/init.d/network")]),e._v(" script runs several other scripts and sets up variables like interfaces_boot to keep track of which "),t("em",[e._v("/etc/sysconfig/network-scripts/ifup")]),e._v(" scripts to run. Tracing the process manually is very complicated, but simple modifications of only two configuration files (putting the proper names and IP addresses in the "),t("em",[e._v("/etc/sysconfig/network")]),e._v(" and "),t("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-eth0")]),e._v(" files) sets up the entire system properly (and a GUI makes the process even simpler).")]),e._v(" "),t("p",[e._v("When the network script finishes, the FIB contains the specified routes to given hosts or networks and the routing cache and neighbor tables are empty. When traffic begins to flow, the kernel will update the neighbor table and routing cache as part of the normal network operations. (Network traffic may begin during initialization if a host is dynamically configured or consults a network clock, for example.)")]),e._v(" "),t("h3",{attrs:{id:"_3-2-2-ifconfig"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-ifconfig"}},[e._v("#")]),e._v(" 3.2.2  "),t("em",[e._v("ifconfig")])]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("ifconfig")]),e._v(" program configures interface devices for use. (This program, while very widely used, is not part of the kernel.) It provides each device with its (IP) address, netmask, and broadcast address. The device in turn will run its own initialization functions (to set any static variables) and register its interrupts and service routines with the kernel. The "),t("em",[e._v("ifconfig")]),e._v(" commands in the network script look like this:")]),e._v(" "),t("blockquote",[t("p",[e._v("ifconfig ${DEVICE} ${IPADDR} netmask ${NMASK} broadcast ${BCAST}")])]),e._v(" "),t("p",[e._v("(where the variables are either written directly in the script or are defined in other scripts).")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("ifconfig")]),e._v(" program can also provide information about currently configured network devices (calling with no arguments displays all the active interfaces; calling with the -a option displays all interfaces, active or not):")]),e._v(" "),t("blockquote",[t("p",[e._v("ifconfig")])]),e._v(" "),t("p",[e._v("This provides all the information available about each working interface; addresses, status, packet statistics, and operating system specifics. Usually there will be at least two interfaces - a network card and the loopback device. The information for each interface looks like this (this is the viper interface):")]),e._v(" "),t("blockquote",[t("p",[e._v("eth0  Link encap:Ethernet  HWaddr 00:C1:4E:7D:9E:25\ninet addr:172.16.1.1  Bcast:172.16.1.255  Mask:255.255.255.0\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:389016 errors:16534 dropped:0 overruns:0 frame:24522\nTX packets:400845 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:100\nInterrupt:11 Base address:0xcc00")])]),e._v(" "),t("p",[e._v("A superuser can use "),t("em",[e._v("ifconfig")]),e._v(" to change interface settings from the command line; here is the syntax:")]),e._v(" "),t("blockquote",[t("p",[e._v("ifconfig "),t("em",[e._v("interface [aftype] options | address ...")])])]),e._v(" "),t("p",[e._v("... and some of the more useful calls:")]),e._v(" "),t("blockquote",[t("p",[e._v("ifconfig eth0 down - shut down eth0"),t("br"),e._v("\nifconfig eth1 up - activate eth1"),t("br"),e._v("\nifconfig eth0 arp - enable ARP on eth0"),t("br"),e._v("\nifconfig eth0 -arp - disable ARP on eth0"),t("br"),e._v("\nifconfig eth0 netmask 255.255.255.0 - set the eth0 netmask"),t("br"),e._v("\nifconfig lo mtu 2000 - set the loopback maximum transfer unit"),t("br"),e._v("\nifconfig eth1 172.16.0.7 - set the eth1 IP address")])]),e._v(" "),t("p",[e._v("Note that modifying an interface configuration can indirectly change the routing tables. For example, changing the netmask may make some routes moot (including the default or even the route to the host itself) and the kernel will delete them.")]),e._v(" "),t("h3",{attrs:{id:"_3-2-3-route"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-route"}},[e._v("#")]),e._v(" 3.2.3  "),t("em",[e._v("route")])]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("route")]),e._v(" program simply adds predefined routes for interface devices to the Forwarding Information Base (FIB). This is not part of the kernel, either; it is a user program whose command in the script looks like this:")]),e._v(" "),t("blockquote",[t("p",[e._v("route add -net ${NETWORK} netmask ${NMASK} dev ${DEVICE} -or-"),t("br"),e._v("\nroute add -host ${IPADDR} ${DEVICE}")])]),e._v(" "),t("p",[e._v("(where the variables are again spelled out or defined in other scripts).")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("route")]),e._v(" program can also delete routes (if run with the del option) or provide information about the routes that are currently defined (if run with no options):")]),e._v(" "),t("blockquote",[t("p",[e._v("route")])]),e._v(" "),t("p",[e._v("This displays the Kernel IP routing table (the FIB, not the routing cache). For example (the stealth computer):")]),e._v(" "),t("blockquote",[t("p",[e._v("Kernel IP routing table\nDestination   Gateway        Genmask         Flags Metric Ref Use Iface\n172.16.1.4    *              255.255.255.255 UH    0      0     0 eth0\n172.16.1.0    *              255.255.255.0   U     0      0     0 eth0\n127.0.0.0     *              255.0.0.0       U     0      0     0 lo\ndefault       viper.u.edu    0.0.0.0         UG    0      0     0 eth0")])]),e._v(" "),t("p",[e._v("A superuser can use "),t("em",[e._v("route")]),e._v(" to add and delete IP routes from the command line; here is the basic syntax:")]),e._v(" "),t("blockquote",[t("p",[e._v("route add "),t("em",[e._v("[-net|-host] target [option arg]")]),t("br"),e._v("\nroute del "),t("em",[e._v("[-net|-host] target [option arg]")])])]),e._v(" "),t("p",[e._v("... and some useful examples:")]),e._v(" "),t("blockquote",[t("p",[e._v("route add -host 127.16.1.0 eth1 - adds a route to a host"),t("br"),e._v("\nroute add -net 172.16.1.0 netmask 255.255.255.0 eth0 - adds a network"),t("br"),e._v("\nroute add default gw jeep - sets the default route through jeep"),t("br"),e._v("\n(Note that a route to jeep must already be set up)"),t("br"),e._v("\nroute del -host 172.16.1.16 - deletes entry for host 172.16.1.16")])]),e._v(" "),t("h3",{attrs:{id:"_3-2-4-dynamic-routing-programs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-dynamic-routing-programs"}},[e._v("#")]),e._v(" 3.2.4  Dynamic Routing Programs")]),e._v(" "),t("p",[e._v("If the computer is a router, the network script will run a routing program like "),t("em",[e._v("routed")]),e._v(" or "),t("em",[e._v("gated")]),e._v(". Since most computers are always on the same hard-wired network with the same set of addresses and limited routing options, most computers do not run one of these programs. (If an Ethernet cable is cut, traffic simply will not flow; there is no need to try to reroute or adjust routing tables.) See Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),t("OutboundLink")],1),e._v(" for more information about "),t("em",[e._v("routed")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"_3-3-examples"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-examples"}},[e._v("#")]),e._v(" 3.3  Examples")]),e._v(" "),t("p",[e._v("The following are examples of files for systems set up in three different ways and explanations of how they work. Typically every computer will execute a network script that reads configuration files, even if the files tell the computer not to implement any networking.")]),e._v(" "),t("h3",{attrs:{id:"_3-3-1-home-computer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-home-computer"}},[e._v("#")]),e._v(" 3.3.1  Home Computer")]),e._v(" "),t("p",[e._v("These files would be on a computer that is not permanently connected to a network, but has a modem for ppp access. (This section does not reference a computer from the general example.)")]),e._v(" "),t("p",[e._v("This is the first file the network script will read; it sets several environment variables. The first two variables set the computer to run networking programs (even though it is not on a network) but not to forward packets (since it has nowhere to send them). The last two variables are generic entries.")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network")])]),e._v(" "),t("blockquote",[t("p",[e._v("NETWORKING=yes"),t("br"),e._v("\nFORWARD_IPV4=false"),t("br"),e._v("\nHOSTNAME=localhost.localdomain"),t("br"),e._v("\nGATEWAY=")])]),e._v(" "),t("p",[e._v("After setting these variables, the network script will decide that it needs to configure at least one network device in order to be part of a network. The next file (which is almost exactly the same on all Linux computers) sets up environment variables for the loopback device. It names it and gives it its (standard) IP address, network mask, and broadcast address as well as any other device specific variables. (The ONBOOT variable is a flag for the script program that tells it to configure this device when it boots.) Most computers, even those that will never connect to the Internet, install the loopback device for inter-process communication.")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-lo")])]),e._v(" "),t("blockquote",[t("p",[e._v("DEVICE=lo"),t("br"),e._v("\nIPADDR=127.0.0.1"),t("br"),e._v("\nNMASK=255.0.0.0"),t("br"),e._v("\nNETWORK=127.0.0.0"),t("br"),e._v("\nBCAST=127.255.255.255"),t("br"),e._v("\nONBOOT=yes"),t("br"),e._v("\nNAME=loopback"),t("br"),e._v("\nBOOTPROTO=none")])]),e._v(" "),t("p",[e._v("After setting these variables, the script will run the "),t("em",[e._v("ifconfig")]),e._v(" program and stop, since there is nothing else to do at the moment. However, when the ppp program connects to an Internet Service Provider, it will establish a ppp device and addressing and routes based on the dynamic values assigned by the ISP. The DNS server and other connection information should be in an "),t("em",[e._v("ifcfg-ppp")]),e._v(" file.")]),e._v(" "),t("h3",{attrs:{id:"_3-3-2-host-computer-on-a-lan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-host-computer-on-a-lan"}},[e._v("#")]),e._v(" 3.3.2  Host Computer on a LAN")]),e._v(" "),t("p",[e._v("These files would be on a computer that is connected to a LAN; it has one Ethernet card that should come up whenever the computer boots. These files reflect entries on the stealth computer from the general example.")]),e._v(" "),t("p",[e._v("This is the first file the network script will read; again the first variables simply determine that the computer will do networking but that it will not forward packets. The last four variables identify the computer and its link to the rest of the Internet (everything that is not on the LAN).")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network")])]),e._v(" "),t("blockquote",[t("p",[e._v("NETWORKING=yes"),t("br"),e._v("\nFORWARD_IPV4=false"),t("br"),e._v("\nHOSTNAME=stealth.cs.u.edu"),t("br"),e._v("\nDOMAINNAME=cs.u.edu"),t("br"),e._v("\nGATEWAY=172.16.1.1"),t("br"),e._v("\nGATEWAYDEV=eth0")])]),e._v(" "),t("p",[e._v("After setting these variables, the network script will configure the network devices. This file sets up environment variables for the Ethernet card. It names the device and gives it its IP address, network mask, and broadcast address as well as any other device specific variables. This kind of computer would also have a loopback configuration file exactly like the one for a non-networked computer.")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-eth0")])]),e._v(" "),t("blockquote",[t("p",[e._v("DEVICE=eth0"),t("br"),e._v("\nIPADDR=172.16.1.4"),t("br"),e._v("\nNMASK=255.255.255.0"),t("br"),e._v("\nNETWORK=172.16.1.0"),t("br"),e._v("\nBCAST=172.16.1.255"),t("br"),e._v("\nONBOOT=yes"),t("br"),e._v("\nBOOTPROTO=none")])]),e._v(" "),t("p",[e._v("After setting these variables, the network script will run the "),t("em",[e._v("ifconfig program")]),e._v(" to start the device. Finally, the script will run the "),t("em",[e._v("route")]),e._v(" program to add the default route (GATEWAY) and any other specified routes (found in the "),t("em",[e._v("/etc/sysconfig/static-routes file")]),e._v(", if any). In this case only the default route is specified, since all traffic either stays on the LAN (where the computer will use ARP to find other hosts) or goes through the router to get to the outside world.")]),e._v(" "),t("h3",{attrs:{id:"_3-3-3-network-routing-computer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-network-routing-computer"}},[e._v("#")]),e._v(" 3.3.3  Network Routing Computer")]),e._v(" "),t("p",[e._v("These files would be on a computer that serves as a router between two networks; it has two Ethernet cards, one for each network. One card is on a large network (WAN) connected to the Internet (through yet another router) while the other is on a subnetwork (LAN). Computers on the LAN that need to communicate with the rest of the Internet send traffic through this computer (and vice versa). These files reflect entries on the dodge/viper computer from the general example.")]),e._v(" "),t("p",[e._v("This is the first file the network script will read; it sets several environment variables. The first two simply determine that the computer will do networking (since it is on a network) and that this one will forward packets (from one network to the other). IP Forwarding is built into most kernels, but it is not active unless there is a 1 ``written'' to the "),t("em",[e._v("/proc/net/ipv4/ip_forward")]),e._v(" file. (One of the network scripts performs an echo 1 > /proc/net/ipv4/ip_forward if FORWARD_IPV4 is true.) The last four variables identify the computer and its link to the rest of the Internet (everything that is not on one of its own networks).")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network")])]),e._v(" "),t("blockquote",[t("p",[e._v("NETWORKING=yes"),t("br"),e._v("\nFORWARD_IPV4=true"),t("br"),e._v("\nHOSTNAME=dodge.u.edu"),t("br"),e._v("\nDOMAINNAME=u.edu"),t("br"),e._v("\nGATEWAY=172.16.0.1"),t("br"),e._v("\nGATEWAYDEV=eth1")])]),e._v(" "),t("p",[e._v("After setting these variables, the network script will configure the network devices. These files set up environment variables for two Ethernet cards. They name the devices and give them their IP addresses, network masks, and broadcast addresses. (Note that the BOOTPROTO variable remains defined for the second card.) Again, this computer would have the standard loopback configuration file.")]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-eth0")])]),e._v(" "),t("blockquote",[t("p",[e._v("DEVICE=eth0"),t("br"),e._v("\nIPADDR=172.16.1.1"),t("br"),e._v("\nNMASK=255.255.255.0"),t("br"),e._v("\nNETWORK=172.16.1.0"),t("br"),e._v("\nBCAST=172.16.1.255"),t("br"),e._v("\nONBOOT=yes"),t("br"),e._v("\nBOOTPROTO=static")])]),e._v(" "),t("p",[t("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-eth1")])]),e._v(" "),t("blockquote",[t("p",[e._v("DEVICE=eth1"),t("br"),e._v("\nIPADDR=172.16.0.7"),t("br"),e._v("\nNMASK=255.255.0.0"),t("br"),e._v("\nNETWORK=172.16.0.0"),t("br"),e._v("\nBCAST=172.16.255.255"),t("br"),e._v("\nONBOOT=yes")])]),e._v(" "),t("p",[e._v("After setting these variables, the network script will run the "),t("em",[e._v("ifconfig")]),e._v(" program to start each device. Finally, the script will run the "),t("em",[e._v("route")]),e._v(" program to add the default route (GATEWAY) and any other specified routes (found in the "),t("em",[e._v("/etc/sysconfig/static-routes file")]),e._v(", if any). In this case again, the default route is the only specified route, since all traffic will go on the network indicated by the network masks or through the default router to reach the rest of the Internet.")]),e._v(" "),t("h2",{attrs:{id:"_3-4-linux-and-network-program-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-linux-and-network-program-functions"}},[e._v("#")]),e._v(" 3.4  Linux and Network Program Functions")]),e._v(" "),t("p",[e._v("The following are alphabetic lists of the Linux kernel and network program functions that are most important to initialization, where they are in the source code, and what they do. The "),t("em",[e._v("SOURCES")]),e._v(" directory shown represents the directory that contains the source code for the given network file. The executable files should come with any Linux distrbution, but the source code probably does not.")]),e._v(" "),t("p",[e._v("These sources are available as a package separate from the kernel source (Red Hat Linux uses the "),t("em",[e._v("rpm")]),e._v(" package manager). The code below is from the "),t("em",[e._v("net-tools-1.53-1")]),e._v(" source code package, 29 August 1999. The packages are available from the "),t("em",[e._v("www.redhat.com/apps/download")]),e._v(" web page. Once downloaded, "),t("em",[e._v("root")]),e._v(" can install the package with the following commands (starting from the directory with the package):")]),e._v(" "),t("blockquote",[t("p",[e._v("rpm -i net-tools-1.53-1.src.rpm"),t("br"),e._v("\ncd /usr/src/redhat/SOURCES"),t("br"),e._v("\ntar xzf net-tools-1.53.tar.gz")])]),e._v(" "),t("p",[e._v("This creates a "),t("em",[e._v("/usr/src/redhat/SOURCES/net-tools-1.53")]),e._v(" directory and fills it with the source code for the "),t("em",[e._v("ifconfig")]),e._v(" and "),t("em",[e._v("route")]),e._v(" programs (among others). This process should be similar (but is undoubtably not exactly the same) for other Linux distributions.")]),e._v(" "),t("h3",{attrs:{id:"_3-4-1-ifconfig"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-ifconfig"}},[e._v("#")]),e._v(" 3.4.1  "),t("em",[e._v("ifconfig")])]),e._v(" "),t("p",[e._v("devinet_ioctl() - net/ipv4/devinet.c (398)\ncreates an info request (ifreq) structure and copies data from\nuser to kernel space\nif it is an INET level request or action, executes it\nif it is a device request or action, calls a device function\ncopies ifreq back into user memory\nreturns 0 for success")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("ifconfig main() - SOURCES/ifconfig.c (478)\nopens a socket (only for use with ioctl function)\nsearches command line arguments for options\ncalls if_print() if there were no arguments or the only argument\nis an interface name\nloops through remaining arguments, setting or clearing flags or\ncalling ioctl() to set variables for the interface")])])])]),e._v(" "),t("p",[e._v("if_fetch() - SOURCES/lib/interface.c (338)\nfills in an interface structure with multiple calls to ioctl() for\nflags, hardware address, metric, MTU, map, and address information")]),e._v(" "),t("p",[e._v("if_print() - SOURCES/ifconfig.c (121)\ncalls ife_print() for given (or all) interface(s)\n(calls if_readlist() to fill structure list if necessary and\nthen displays information about each interface)")]),e._v(" "),t("p",[e._v("if_readlist() - SOURCES/lib/interface.c (261)\nopens /proc/net/dev and parses data into interface structures\ncalls add_interface() for each device to put structures into a list")]),e._v(" "),t("p",[e._v("inet_ioctl() - net/ipv4/af_inet.c (855)\nexecutes a switch based on the command passed\n[for ifconfig, calls devinet_ioctl()]")]),e._v(" "),t("p",[e._v("ioctl() -\njumps to appropriate handler routine [= inet_ioctl()]")]),e._v(" "),t("h3",{attrs:{id:"_3-4-2-route"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-route"}},[e._v("#")]),e._v(" 3.4.2  "),t("em",[e._v("route")])]),e._v(" "),t("p",[e._v("INET_rinput() - SOURCES/lib/inet_sr.c (305)\nchecks for errors (cannot flush table or modify routing cache)\ncalls INET_setroute()")]),e._v(" "),t("p",[e._v("INET_rprint() - SOURCES/lib/inet_gr.c (442)\nif the FIB flag is set, calls rprint_fib()\n(reads, parses, and displays contents of /proc/net/route)\nif the CACHE flag is set, calls rprint_cache()\n(reads, parses, and displays contents of /proc/net/rt_cache)")]),e._v(" "),t("p",[e._v("INET_setroute() - SOURCE/lib/inet_sr.c (57)\nestablishes whether route is to a network or a host\nchecks to see if address is legal\nloops through arguments, filling in rtentry structure\nchecks for netmask conflicts\ncreates a temporary socket\ncalls ioctl() with rtentry to add or delete route\ncloses socket and returns 0")]),e._v(" "),t("p",[e._v("ioctl() -\njumps to appropriate handler routine [= ip_rt_ioctl()]")]),e._v(" "),t("p",[e._v("ip_rt_ioctl() - net/ipv4/fib_frontend.c (246)\nconverts passed parameters to routing table entry (struct rtentry)\nif deleting a route:\ncalls fib_get_table() to find the appropriate table\ncalls the table->tb_delete() function to remove it\nif adding a route\ncalls fib_net_table() to find an entry point\ncalls the table->tb_insert() function to add the entry\nreturns 0 for success")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("route main() - SOURCES/route.c (106)\ncalls initialization routines that set print and edit functions\ngets and parses the command line options (acts on some options\ndirectly by setting flags or displaying information)\nchecks the options (prints a usage message if there is an error)\nif there are no options, calls route_info()\nif the option is to add, delete, or flush routes,\ncalls route_edit() with the passed parameters\nif the option is invalid, prints a usage message\nreturns result of")])])])]),e._v(" "),t("p",[e._v("route_edit() - SOURCES/lib/setroute.c (69)\ncalls get_aftype() to translate address family from text to a pointer\nchecks for errors (unsupported or nonexistent family)\ncalls the address family rinput() function [= INET_rinput()]")]),e._v(" "),t("p",[e._v("route_info() - SOURCES/lib/getroute.c (72)\ncalls get_aftype() to translate address family from text to a pointer\nchecks for errors (unsupported or nonexistent family)\ncalls the address family rprint() function [= INET_rprint()]")]),e._v(" "),t("h1",{attrs:{id:"chapter-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-4"}},[e._v("#")]),e._v(" Chapter 4")]),e._v(" "),t("p",[e._v("Connections")]),e._v(" "),t("p",[e._v("This chapter presents the connection process. It provides an overview of the connection process, a description of the socket data structures, an introduction to the routing system, and summarizes the implementation code within the kernel.")]),e._v(" "),t("h2",{attrs:{id:"_4-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-overview"}},[e._v("#")]),e._v(" 4.1  Overview")]),e._v(" "),t("p",[e._v("The simplest form of networking is a connection between two hosts. On each end, an application gets a socket, makes the transport layer connection, and then sends or receives packets. In Linux, a socket is actually composed of two socket structures (one that contains the other). When an application creates a socket, it is initialized but empty. When the socket makes a connection (whether or not this involves traffic with the other end) the IP layer determines the route to the distant host and stores that information in the socket. From that point on, all traffic using that connection uses that route - sent packets will travel through the correct device and the proper routers to the distant host, and received packets will appear in the socket's queue.")]),e._v(" "),t("h2",{attrs:{id:"_4-2-socket-structures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-socket-structures"}},[e._v("#")]),e._v(" 4.2  Socket Structures")]),e._v(" "),t("p",[e._v("There are two main socket structures in Linux: general BSD sockets and IP specific INET sockets. They are strongly interrelated; a BSD socket has an INET socket as a data member and an INET socket has a BSD socket as its owner.")]),e._v(" "),t("p",[e._v("BSD sockets are of type struct socket as defined in "),t("em",[e._v("include/linux/socket.h")]),e._v(". BSD socket variables are usually named sock or some variation thereof. This structure has only a few entries, the most important of which are described below.")]),e._v(" "),t("ul",[t("li",[e._v("struct proto_ops *ops - this structure contains pointers to protocol specific functions for implementing general socket behavior. For example, ops- > sendmsg points to the inet_sendmsg() function.")]),e._v(" "),t("li",[t("em",[e._v("struct inode *inode")]),e._v(" - this structure points to the file inode that is associated with this socket.")]),e._v(" "),t("li",[e._v("struct sock *sk - this is the INET socket that is associated with this socket.")])]),e._v(" "),t("p",[e._v("INET sockets are of type struct sock as defined in "),t("em",[e._v("include/net/sock.h")]),e._v(". INET socket variables are usually named sk or some variation thereof. This structure has many entries related to a wide variety of uses; there are many hacks and configuration dependent fields. The most important data members are described below:")]),e._v(" "),t("ul",[t("li",[e._v("struct sock *next, *pprev - all sockets are linked by various protocols, so these pointers allow the protocols to traverse them.")]),e._v(" "),t("li",[e._v("struct dst_entry *dst_cache - this is a pointer to the route to the socket's other side (the destination for sent packets).")]),e._v(" "),t("li",[e._v("struct sk_buff_head receive_queue - this is the head of the receive queue.")]),e._v(" "),t("li",[e._v("struct sk_buff_head write_queue - this is the head of the send queue.")]),e._v(" "),t("li",[e._v("__u32 saddr - the (Internet) source address for this socket.")]),e._v(" "),t("li",[e._v("struct sk_buff_head back_log,error_queue - extra queues for a backlog of packets (not to be confused with the main backlog queue) and erroneous packets for this socket.")]),e._v(" "),t("li",[e._v("struct proto *prot - this structure contains pointers to transport layer protocol specific functions. For example, prot- > recvmsg may point to the tcp_v4_recvmsg() function.")]),e._v(" "),t("li",[e._v("union struct tcp_op af_tcp; tp_pinfo - TCP options for this socket.")]),e._v(" "),t("li",[e._v("struct socket *sock - the parent BSD socket.")]),e._v(" "),t("li",[e._v("Note that there are many more fields within this structure; these are only the most critical and non-obvious. The rest are either not very important or have self-explanatory names (e.g., ip_ttl is the IP Time-To-Live counter).")])]),e._v(" "),t("h2",{attrs:{id:"_4-3-sockets-and-routing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-sockets-and-routing"}},[e._v("#")]),e._v(" 4.3  Sockets and Routing")]),e._v(" "),t("p",[e._v("Sockets only go through the routing lookup process once for each destination (at connection time). Because Linux sockets are so closely related to IP, they contain routes to the other end of a connection (in the sock- > sk- > dst_cache variable). The transport protocols call the ip_route_connect() function to determine the route from host to host during the connection process; after that, the route is presumed not to change (though the path pointed to by the dst_cache may indeed change). The socket does not need to do continuous routing table look-ups for each packet it sends or receives; it only tries again if something unexpected happens (such as a neighboring computer going down). This is the benefit of using connections.")]),e._v(" "),t("h2",{attrs:{id:"_4-4-connection-processes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-connection-processes"}},[e._v("#")]),e._v(" 4.4  Connection Processes")]),e._v(" "),t("h3",{attrs:{id:"_4-4-1-establishing-connections"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-establishing-connections"}},[e._v("#")]),e._v(" 4.4.1  Establishing Connections")]),e._v(" "),t("p",[e._v("Application programs establish sockets with a series of system calls that look up the distant address, establish a socket, and then connect to the machine on the other end.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/* look up host */\nserver = gethostbyname(SERVER_NAME);\n/* get socket */\nsockfd = socket(AF_INET, SOCK_STREAM, 0);\n/* set up address */\naddress.sin_family = AF_INET;\naddress.sin_port = htons(PORT_NUM);\nmemcpy(&address.sin_addr,server->h_addr,server->h_length);\n/* connect to server */\nconnect(sockfd, &address, sizeof(address));\n")])])]),t("p",[e._v("The gethostbyname() function simply looks up a host (such as ``viper.cs.u.edu'') and returns a structure that contains an Internet (IP) address. This has very little to do with routing (only inasmuch as the host may have to query the network to look up an address) and is simply a translation from a human readable form (text) to a computer compatible one (an unsigned 4 byte integer).")]),e._v(" "),t("p",[e._v("The socket() call is more interesting. It creates a socket object, with the appropriate data type (a sock for INET sockets) and initializes it. The socket contains inode information and protocol specific pointers for various network functions. It also establishes defaults for queues (incoming, outgoing, error, and backlog), a dummy header info for TCP sockets, and various state information.")]),e._v(" "),t("p",[e._v("Finally, the connect() call goes to the protocol dependent connection routine (e.g., tcp_v4_connect() or udp_connect()). UDP simply establishes a route to the destination (since there is no virtual connection). TCP establishes the route and then begins the TCP connection process, sending a packet with appropriate connection and window flags set.")]),e._v(" "),t("h3",{attrs:{id:"_4-4-2-socket-call-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-socket-call-walk-through"}},[e._v("#")]),e._v(" 4.4.2  Socket Call Walk-Through")]),e._v(" "),t("ul",[t("li",[e._v("Check for errors in call")]),e._v(" "),t("li",[e._v("Create (allocate memory for) socket object")]),e._v(" "),t("li",[e._v("Put socket into INODE list")]),e._v(" "),t("li",[e._v("Establish pointers to protocol functions (INET)")]),e._v(" "),t("li",[e._v("Store values for socket type and protocol family")]),e._v(" "),t("li",[e._v("Set socket state to closed")]),e._v(" "),t("li",[e._v("Initialize packet queues")])]),e._v(" "),t("h3",{attrs:{id:"_4-4-3-connect-call-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-3-connect-call-walk-through"}},[e._v("#")]),e._v(" 4.4.3  Connect Call Walk-Through")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Check for errors")])]),e._v(" "),t("li",[t("p",[e._v("Determine route to destination:")]),e._v(" "),t("ul",[t("li",[e._v("Check routing table for existing entry (return that if one exists)")]),e._v(" "),t("li",[e._v("Look up destination in FIB")]),e._v(" "),t("li",[e._v("Build new routing table entry")]),e._v(" "),t("li",[e._v("Put entry in routing table and return it")])])]),e._v(" "),t("li",[t("p",[e._v("Store pointer to routing entry in socket")])]),e._v(" "),t("li",[t("p",[e._v("Call protocol specific connection function (e.g., send a TCP connection packet)")])]),e._v(" "),t("li",[t("p",[e._v("Set socket state to established")])])]),e._v(" "),t("h3",{attrs:{id:"_4-4-4-closing-connections"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-4-closing-connections"}},[e._v("#")]),e._v(" 4.4.4  Closing Connections")]),e._v(" "),t("p",[e._v("Closing a socket is fairly straightforward. An application calls close() on a socket, which becomes a sock_close() function call. This changes the socket state to disconnecting and calls the data member's (INET socket's) release function. The INET socket in turn cleans up its queues and calls the transport protocol's close function, tcp_v4_close() or udp_close(). These perform any necessary actions (the TCP functions may send out packets to end the TCP connection) and then clean up any data structures they have remaining. Note that no changes are made for routing; the (now-empty) socket no longer has a reference to the destination and the entry in the routing cache will remain until it is freed for lack of use.")]),e._v(" "),t("h3",{attrs:{id:"_4-4-5-close-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-5-close-walk-through"}},[e._v("#")]),e._v(" 4.4.5  Close Walk-Through")]),e._v(" "),t("ul",[t("li",[e._v("Check for errors (does the socket exist?)")]),e._v(" "),t("li",[e._v("Change the socket state to disconnecting to prevent further use")]),e._v(" "),t("li",[e._v("Do any protocol closing actions (e.g., send a TCP packet with the FIN bit set)")]),e._v(" "),t("li",[e._v("Free memory for socket data structures (TCP/UDP and INET)")]),e._v(" "),t("li",[e._v("Remove socket from INODE list")])]),e._v(" "),t("h2",{attrs:{id:"_4-5-linux-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-linux-functions"}},[e._v("#")]),e._v(" 4.5  Linux Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the Linux kernel functions that are most important to connections, where they are in the source code, and what they do. To follow function calls for creating a socket, begin with sock_create(). To follow function calls for closing a socket, begin with sock_close().")]),e._v(" "),t("p",[e._v("destroy_sock - net/ipv4/af_inet.c (195)\ndeletes any timers\ncalls any protocols specific destroy functions\nfrees the socket's queues\nfrees the socket structure itself")]),e._v(" "),t("p",[e._v("fib_lookup() - include/net/ip_fib.h (153)\ncalls tb_lookup() [= fn_hash_lookup()] on local and main tables\nreturns route or unreachable error")]),e._v(" "),t("p",[e._v("fn_hash_lookup() - net/ipv4/fib_hash.c (261)\nlooks up and returns route to an address")]),e._v(" "),t("p",[e._v("inet_create() - net/ipv4/af_inet.c (326)\ncalls sk_alloc() to get memory for sock\ninitializes sock structure:\nsets proto structure to appropriate values for TCP or UDP\ncalls sock_init_data()\nsets family,protocol,etc. variables\ncalls the protocol init function (if any)")]),e._v(" "),t("p",[e._v("inet_release() - net/ipv4/af_inet.c (463)\nchanges socket state to disconnecting\ncalls ip_mc_drop_socket to leave multicast group (if necessary)\nsets owning socket's data member to NULL\ncalls sk->prot->close() [=TCP/UDP_close()]")]),e._v(" "),t("p",[e._v("ip_route_connect() - include/net/route.h (140)\ncalls ip_route_output() to get a destination address\nreturns if the call works or generates an error\notherwise clears the route pointer and try again")]),e._v(" "),t("p",[e._v("ip_route_output() - net/ipv4/route.c (1664)\ncalculates hash value for address\nruns through table (starting at hash) to match addresses and TOS\nif there is a match, updates stats and return route entry\nelse calls ip_route_output_slow()")]),e._v(" "),t("p",[e._v("ip_route_output_slow() - net/ipv4/route.c (1421)\nif source address is known, looks up output device\nif destination address is unknown, sets up loopback\ncalls fib_lookup() to find route in FIB\nallocates memory new routing table entry\ninitializes table entry with source, destination, TOS, output device,\nflags\ncalls rt_set_nexthop() to find next destination\nreturns rt_intern_hash(), which installs route in routing table")]),e._v(" "),t("p",[e._v("rt_intern_hash() - net/ipv4/route.c (526)\nloops through rt_hash_table (starting at hash value)\nif keys match, put rtable entry in front bucket\nelse put rtable entry into hash table at hash")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("sock_close() - net/socket.c (476)\nchecks if socket exists (could be null)\ncalls sock_fasync() to remove socket from async list\ncalls sock_release()")])])])]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("sock_create() - net/socket.c (571)\nchecks parameters\ncalls sock_alloc() to get an available inode for the socket and\ninitialize it\nsets socket->type (to SOCK_STREAM, SOCK_DGRAM...)\ncalls net_family->create() [= inet_create()] to build sock structure\nreturns established socket")])])])]),e._v(" "),t("p",[e._v("sock_init_data() - net/core/sock.c (1018)\ninitializes all generic sock values")]),e._v(" "),t("p",[e._v("sock_release() - net/socket.c (309)\nchanges state to disconnecting\ncalls sock->ops->release() [= inet_release()]\ncalls iput() to remove socket from inode list")]),e._v(" "),t("p",[e._v("sys_socket() - net/socket.c (639)\ncalls sock_create() to get and initialize socket\ncalls get_fd() to assign an fd to the socket\nsets socket->file to fcheck() (pointer to file)\ncalls sock_release() if anything fails")]),e._v(" "),t("p",[e._v("tcp_close() - net/ipv4/tcp.c (1502)\ncheck for errors\npops and discards all packets off incoming queue\nsends messages to destination to close connection (if required)")]),e._v(" "),t("p",[e._v("tcp_connect() - net/ipv4/tcp_output.c (910)\ncompletes connection packet with appropriate bits and window sizes set\nputs packet on socket output queue\ncalls tcp_transmit_skb() to send packet, initiating TCP connection")]),e._v(" "),t("p",[e._v("tcp_v4_connect() - net/ipv4/tcp_ipv4.c (571)\nchecks for errors\ncalls ip_route_connect() to find route to destination\ncreates connection packet"),t("br"),e._v("\ncalls tcp_connect() to send packet")]),e._v(" "),t("p",[e._v("udp_close() - net/ipv4/udp.c (954)\ncalls udp_v4_unhash() to remove socket from socket list\ncalls destroy_sock()")]),e._v(" "),t("p",[e._v("udp_connect() - net/ipv4/udp.c (900)\ncalls ip_route_connect() to find route to destination\nupdates socket with source and destination addresses and ports\nchanges socket state to established\nsaves the destination route in sock->dst_cache")]),e._v(" "),t("h1",{attrs:{id:"chapter-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-5"}},[e._v("#")]),e._v(" Chapter 5")]),e._v(" "),t("p",[e._v("Sending Messages")]),e._v(" "),t("p",[e._v("This chapter presents the sending side of message trafficking. It provides an overview of the process, examines the layers packets travel through, details the actions of each layer, and summarizes the implementation code within the kernel.")]),e._v(" "),t("h2",{attrs:{id:"_5-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-overview"}},[e._v("#")]),e._v(" 5.1  Overview")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/s_tx.gif",alt:"s_tx.gif"}})]),e._v(" "),t("p",[e._v("Figure 5.1: Message transmission.")]),e._v(" "),t("p",[e._v("An outgoing message begins with an application system call to write data to a socket. The socket examines its own connection type and calls the appropriate send routine (typically INET). The send function verifies the status of the socket, examines its protocol type, and sends the data on to the transport layer routine (such as TCP or UDP). This protocol creates a new buffer for the outgoing packet (a socket buffer, or struct sk_buff skb), copies the data from the application buffer, and fills in its header information (such as port number, options, and checksum) before passing the new buffer to the network layer (usually IP). The IP send functions fill in more of the buffer with its own protocol headers (such as the IP address, options, and checksum). It may also fragment the packet if required. Next the IP layer passes the packet to the link layer function, which moves the packet onto the sending device's xmit queue and makes sure the device knows that it has traffic to send. Finally, the device (such as a network card) tells the bus to send the packet.")]),e._v(" "),t("h2",{attrs:{id:"_5-2-sending-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-sending-walk-through"}},[e._v("#")]),e._v(" 5.2  Sending Walk-Through")]),e._v(" "),t("h3",{attrs:{id:"_5-2-1-writing-to-a-socket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-writing-to-a-socket"}},[e._v("#")]),e._v(" 5.2.1  Writing to a Socket")]),e._v(" "),t("ul",[t("li",[e._v("Write data to a socket (application)")]),e._v(" "),t("li",[e._v("Fill in message header with location of data (socket)")]),e._v(" "),t("li",[e._v("Check for basic errors - is socket bound to a port? can the socket send messages? is there something wrong with the socket?")]),e._v(" "),t("li",[e._v("Pass the message header to appropriate transport protocol (INET socket)")])]),e._v(" "),t("h3",{attrs:{id:"_5-2-2-creating-a-packet-with-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-creating-a-packet-with-udp"}},[e._v("#")]),e._v(" 5.2.2  Creating a Packet with UDP")]),e._v(" "),t("ul",[t("li",[e._v("Check for errors - is the data too big? is it a UDP connection?")]),e._v(" "),t("li",[e._v("Make sure there is a route to the destination (call the IP routing routines if the route is not already established; fail if there is no route)")]),e._v(" "),t("li",[e._v("Create a UDP header (for the packet)")]),e._v(" "),t("li",[e._v("Call the IP build and transmit function")])]),e._v(" "),t("h3",{attrs:{id:"_5-2-3-creating-a-packet-with-tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-3-creating-a-packet-with-tcp"}},[e._v("#")]),e._v(" 5.2.3  Creating a Packet with TCP")]),e._v(" "),t("ul",[t("li",[e._v("Check connection - is it established? is it open? is the socket working?")]),e._v(" "),t("li",[e._v("Check for and combine data with partial packets if possible")]),e._v(" "),t("li",[e._v("Create a packet buffer")]),e._v(" "),t("li",[e._v("Copy the payload from user space")]),e._v(" "),t("li",[e._v("Add the packet to the outbound queue")]),e._v(" "),t("li",[e._v("Build current TCP header into packet (with ACKs, SYN, etc.)")]),e._v(" "),t("li",[e._v("Call the IP transmit function")])]),e._v(" "),t("h3",{attrs:{id:"_5-2-4-wrapping-a-packet-in-ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-4-wrapping-a-packet-in-ip"}},[e._v("#")]),e._v(" 5.2.4  Wrapping a Packet in IP")]),e._v(" "),t("ul",[t("li",[e._v("Create a packet buffer (if necessary - UDP)")]),e._v(" "),t("li",[e._v("Look up route to destination (if necessary - TCP)")]),e._v(" "),t("li",[e._v("Fill in the packet IP header")]),e._v(" "),t("li",[e._v("Copy the transport header and the payload from user space")]),e._v(" "),t("li",[e._v("Send the packet to the destination route's device output funtion")])]),e._v(" "),t("h3",{attrs:{id:"_5-2-5-transmitting-a-packet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-5-transmitting-a-packet"}},[e._v("#")]),e._v(" 5.2.5  Transmitting a Packet")]),e._v(" "),t("ul",[t("li",[e._v("Put the packet on the device output queue")]),e._v(" "),t("li",[e._v("Wake up the device")]),e._v(" "),t("li",[e._v("Wait for the scheduler to run the device driver")]),e._v(" "),t("li",[e._v("Test the medium (device)")]),e._v(" "),t("li",[e._v("Send the link header")]),e._v(" "),t("li",[e._v("Tell the bus to transmit the packet over the medium")])]),e._v(" "),t("h2",{attrs:{id:"_5-3-linux-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-linux-functions"}},[e._v("#")]),e._v(" 5.3  Linux Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the Linux kernel functions that are most important to message traffic, where they are in the source code, and what they do. To follow function calls, begin with sock_write().")]),e._v(" "),t("p",[e._v("dev_queue_xmit() - net/core/dev.c (579)\ncalls start_bh_atomic()\nif device has a queue\ncalls enqueue() to add packet to queue\ncalls qdisc_wakeup() [= qdisc_restart()] to wake device\nelse calls hard_start_xmit()\ncalls end_bh_atomic()")]),e._v(" "),t("p",[e._v("DEVICE->hard_start_xmit() - device dependent, drivers/net/DEVICE.c\ntests to see if medium is open\nsends header\ntells bus to send packet\nupdates status")]),e._v(" "),t("p",[e._v("inet_sendmsg() - net/ipv4/af_inet.c (786)\nextracts pointer to socket sock\nchecks socket to make sure it is working\nverifies protocol pointer\nreturns sk->prot[tcp/udp]->sendmsg()")]),e._v(" "),t("p",[e._v("ip_build_xmit - net/ipv4/ip_output.c (604)\ncalls sock_alloc_send_skb() to establish memory for skb\nsets up skb header\ncalls getfrag() [= udp_getfrag()]  to copy buffer from user space\nreturns rt->u.dst.output() [= dev_queue_xmit()]")]),e._v(" "),t("p",[e._v("ip_queue_xmit() - net/ipv4/ip_output.c (234)\nlooks up route\nbuilds IP header\nfragments if required\nadds IP checksum\ncalls skb->dst->output() [= dev_queue_xmit()]")]),e._v(" "),t("p",[e._v("qdisc_restart() - net/sched/sch_generic.c (50)\npops packet off queue\ncalls dev->hard_start_xmit()\nupdates status\nif there was an error, requeues packet")]),e._v(" "),t("p",[e._v("sock_sendmsg() - net/socket.c (325)\ncalls scm_sendmsg() [socket control message]\ncalls sock->ops[inet]->sendmsg() and destroys scm")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("sock_write() - net/socket.c (399)\ncalls socki_lookup() to associate socket with fd/file inode\ncreates and fills in message header with data size/addresses\nreturns sock_sendmsg()")])])])]),e._v(" "),t("p",[e._v("tcp_do_sendmsg() - net/ipv4/tcp.c  (755)\nwaits for connection, if necessary\ncalls skb_tailroom() and adds data to waiting packet if possible\nchecks window status\ncalls sock_wmalloc() to get memory for skb\ncalls csum_and_copy_from_user() to copy packet and do checksum\ncalls tcp_send_skb()")]),e._v(" "),t("p",[e._v("tcp_send_skb() - net/ipv4/tcp_output.c (160)\ncalls __skb_queue_tail() to add packet to queue\ncalls tcp_transmit_skb() if possible")]),e._v(" "),t("p",[e._v("tcp_transmit_skb() - net/ipv4/tcp_output.c (77)\nbuilds TCP header and adds checksum\ncalls tcp_build_and_update_options()\nchecks ACKs,SYN\ncalls tp->af_specific[ip]->queue_xmit()")]),e._v(" "),t("p",[e._v("tcp_v4_sendmsg() - net/ipv4/tcp_ipv4.c (668)\nchecks for IP address type, opens connection, port addresses\nreturns tcp_do_sendmsg()")]),e._v(" "),t("p",[e._v("udp_getfrag() - net/ipv4/udp.c (516)\ncopies and checksums a buffer from user space")]),e._v(" "),t("p",[e._v("udp_sendmsg() - net/ipv4/udp.c (559)\nchecks length, flags, protocol\nsets up UDP header and address info\nchecks multicast\nfills in route\nfills in remainder of header\ncalls ip_build_xmit()\nupdates UDP status\nreturns err")]),e._v(" "),t("h1",{attrs:{id:"chapter-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-6"}},[e._v("#")]),e._v(" Chapter 6")]),e._v(" "),t("p",[e._v("Receiving Messages")]),e._v(" "),t("p",[e._v("This chapter presents the receiving side of message trafficking. It provides an overview of the process, examines the layers packets travel through, details the actions of each layer, and summarizes the implementation code within the kernel.")]),e._v(" "),t("h2",{attrs:{id:"_6-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-overview"}},[e._v("#")]),e._v(" 6.1  Overview")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_rx.gif",alt:"r_rx.gif"}})]),e._v(" "),t("p",[e._v("Figure 6.1: Receiving messages.")]),e._v(" "),t("p",[e._v("An incoming message begins with an interrupt when the system notifies the device that a message is ready. The device allocates storage space and tells the bus to put the message into that space. It then passes the packet to the link layer, which puts it on the backlog queue, and marks the network flag for the next ``bottom-half'' run.")]),e._v(" "),t("p",[e._v("The bottom-half is a Linux system that minimizes the amount of work done during an interrupt. Doing a lot of processing during an interrupt is not good precisely because it interrupts a running process; instead, interrupt handlers have a "),t("code",[e._v("top-half'' and a")]),e._v("bottom-half''. When the interrupt arrives, the top-half runs and takes care of any critical operations, such as moving data from a device queue into kernel memory. It then marks a flag that tells the kernel that there is more work to do - when the processor has time - and returns control to the current process. The next time the process scheduler runs, it sees the flag, does the extra work, and only then schedules any normal processes.")]),e._v(" "),t("p",[e._v("When the process scheduler sees that there are networking tasks to do it runs the network bottom-half. This function pops packets off of the backlog queue, matches them to a known protocol (typically IP), and passes them to that protocol's receive function. The IP layer examines the packet for errors and routes it; the packet will go into an outgoing queue (if it is for another host) or up to the transport layer (such as TCP or UDP). This layer again checks for errors, looks up the socket associated with the port specified in the packet, and puts the packet at the end of that socket's receive queue.")]),e._v(" "),t("p",[e._v("Once the packet is in the socket's queue, the socket will wake up the application process that owns it (if necessary). That process may then make or return from a read system call that copies the data from the packet in the queue into its own buffer. (The process may also do nothing for the time being if it was not waiting for the packet, and get the data off the queue when it needs it.)")]),e._v(" "),t("h2",{attrs:{id:"_6-2-receiving-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-receiving-walk-through"}},[e._v("#")]),e._v(" 6.2  Receiving Walk-Through")]),e._v(" "),t("h3",{attrs:{id:"_6-2-1-reading-from-a-socket-part-i"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-reading-from-a-socket-part-i"}},[e._v("#")]),e._v(" 6.2.1  Reading from a Socket (Part I)")]),e._v(" "),t("ul",[t("li",[e._v("Try to read data from a socket (application)")]),e._v(" "),t("li",[e._v("Fill in message header with location of buffer (socket)")]),e._v(" "),t("li",[e._v("Check for basic errors - is the socket bound to a port? can the socket accept messages? is there something wrong with the socket?")]),e._v(" "),t("li",[e._v("Pass the message header with to the appropriate transport protocol (INET socket)")]),e._v(" "),t("li",[e._v("Sleep until there is enough data to read from the socket (TCP/UDP)")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-2-receiving-a-packet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-receiving-a-packet"}},[e._v("#")]),e._v(" 6.2.2  Receiving a Packet")]),e._v(" "),t("ul",[t("li",[e._v("Wake up the receiving device (interrupt)")]),e._v(" "),t("li",[e._v("Test the medium (device)")]),e._v(" "),t("li",[e._v("Receive the link header")]),e._v(" "),t("li",[e._v("Allocate space for the packet")]),e._v(" "),t("li",[e._v("Tell the bus to put the packet into the buffer")]),e._v(" "),t("li",[e._v("Put the packet on the backlog queue")]),e._v(" "),t("li",[e._v("Set the flag to run the network bottom half when possible")]),e._v(" "),t("li",[e._v("Return control to the current process")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-3-running-the-network-bottom-half"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-3-running-the-network-bottom-half"}},[e._v("#")]),e._v(" 6.2.3  Running the Network ``Bottom Half''")]),e._v(" "),t("ul",[t("li",[e._v("Run the network bottom half (scheduler)")]),e._v(" "),t("li",[e._v("Send any packets that are waiting to prevent interrupts (bottom half)")]),e._v(" "),t("li",[e._v("Loop through all packets in the backlog queue and pass the packet up to its Internet reception protocol - IP")]),e._v(" "),t("li",[e._v("Flush the sending queue again")]),e._v(" "),t("li",[e._v("Exit the bottom half")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-4-unwrapping-a-packet-in-ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-4-unwrapping-a-packet-in-ip"}},[e._v("#")]),e._v(" 6.2.4  Unwrapping a Packet in IP")]),e._v(" "),t("ul",[t("li",[e._v("Check packet for errors - too short? too long? invalid version? checksum error?")]),e._v(" "),t("li",[e._v("Defragment the packet if necessary")]),e._v(" "),t("li",[e._v("Get the route for the packet (could be for this host or could need to be forwarded)")]),e._v(" "),t("li",[e._v("Send the packet to its destination handling routine (TCP or UDP reception, or possibly retransmission to another host)")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-5-accepting-a-packet-in-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-5-accepting-a-packet-in-udp"}},[e._v("#")]),e._v(" 6.2.5  Accepting a Packet in UDP")]),e._v(" "),t("ul",[t("li",[e._v("Check UDP header for errors")]),e._v(" "),t("li",[e._v("Match destination to socket")]),e._v(" "),t("li",[e._v("Send an error message back if there is no such socket")]),e._v(" "),t("li",[e._v("Put packet into appropriate socket receive queue")]),e._v(" "),t("li",[e._v("Wake up any processes waiting for data from that socket")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-6-accepting-a-packet-in-tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-6-accepting-a-packet-in-tcp"}},[e._v("#")]),e._v(" 6.2.6  Accepting a Packet in TCP")]),e._v(" "),t("ul",[t("li",[e._v("Check sequence and flags; store packet in correct space if possible")]),e._v(" "),t("li",[e._v("If already received, send immediate ACK and drop packet")]),e._v(" "),t("li",[e._v("Determine which socket packet belongs to")]),e._v(" "),t("li",[e._v("Put packet into appropriate socket receive queue")]),e._v(" "),t("li",[e._v("Wake up and processes waiting for data from that socket")])]),e._v(" "),t("h3",{attrs:{id:"_6-2-7-reading-from-a-socket-part-ii"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-7-reading-from-a-socket-part-ii"}},[e._v("#")]),e._v(" 6.2.7  Reading from a Socket (Part II)")]),e._v(" "),t("ul",[t("li",[e._v("Wake up when data is ready (socket)")]),e._v(" "),t("li",[e._v("Call transport layer receive function")]),e._v(" "),t("li",[e._v("Move data from receive queue to user buffer (TCP/UDP)")]),e._v(" "),t("li",[e._v("Return data and control to application (socket)")])]),e._v(" "),t("h2",{attrs:{id:"_6-3-linux-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-linux-functions"}},[e._v("#")]),e._v(" 6.3  Linux Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the Linux kernel functions that are most important to receiving traffic, where they are in the source code, and what they do. To follow functions calls from the network up, start with DEVICE_rx(). To follow functions calls from the application down, start with sock_read().")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("DEVICE_rx() - device dependent, drivers/net/DEVICE.c\n(gets control from interrupt)\nperforms status checks to make sure it should be receiving\ncalls dev_alloc_skb() to reserve space for packet\ngets packet off of system bus\ncalls eth_type_trans() to determine protocol type\ncalls netif_rx()\nupdates card status\n(returns from interrupt)")])])])]),e._v(" "),t("p",[e._v("inet_recvmsg() - net/ipv4/af_inet.c (764)\nextracts pointer to socket sock\nchecks socket to make sure it is accepting\nverifies protocol pointer\nreturns sk->prot[tcp/udp]->recvmsg()")]),e._v(" "),t("p",[e._v("ip_rcv() - net/ipv4/ip_input.c (395)\nexamines packet for errors:\ninvalid length (too short or too long)\nincorrect version (not 4)\ninvalid checksum\ncalls __skb_trim() to remove padding\ndefrags packet if necessary\ncalls ip_route_input() to route packet\nexamines and handle IP options\nreturns skb->dst->input() [= tcp_rcv,udp_rcv()]")]),e._v(" "),t("p",[e._v("net_bh() - net/core/dev.c (835)\n(run by scheduler)\nif there are packets waiting to go out, calls qdisc_run_queues()\n(see sending section)\nwhile the backlog queue is not empty\nlet other bottom halves run\ncall skb_dequeue() to get next packet\nif the packet is for someone else (FASTROUTED) put onto send queue\nloop through protocol lists (taps and main) to match protocol type\ncall pt_prev->func() [= ip_rcv()] to pass packet to appropriate\nprotocol\ncall qdisc_run_queues() to flush output (if necessary)")]),e._v(" "),t("p",[e._v("netif_rx() - net/core/dev.c (757)\nputs time in skb->stamp\nif backlog queue is too full, drops packet\nelse\ncalls skb_queue_tail() to put packet into backlog queue\nmarks bottom half for later execution")]),e._v(" "),t("p",[e._v("sock_def_readable() - net/core/sock.c (989)\ncalls wake_up_interruptible() to put waiting process on run queue\ncalls sock_wake_async() to send SIGIO to socket process")]),e._v(" "),t("p",[e._v("sock_queue_rcv_skb() - include/net/sock.h (857)\ncalls skb_queue_tail() to put packet in socket receive queue\ncalls sk->data_ready() [= sock_def_readable()]")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("sock_read() - net/socket.c (366)\nsets up message headers\nreturns sock_recvmsg() with result of read")])])])]),e._v(" "),t("p",[e._v("sock_recvmsg() - net/socket.c (338)\nreads socket management packet (scm) or packet by\ncalling sock->ops[inet]->recvmsg()")]),e._v(" "),t("p",[e._v("tcp_data() - net/ipv4/tcp_input.c (1507)\nshrinks receive queue if necessary\ncalls tcp_data_queue() to queue packet\ncalls sk->data_ready() to wake socket")]),e._v(" "),t("p",[e._v("tcp_data_queue() - net/ipv4/tcp_input.c (1394)\nif packet is out of sequence:\nif old, discards immediately\nelse calculates appropriate storage location\ncalls __skb_queue_tail() to put packet in socket receive queue\nupdates connection state")]),e._v(" "),t("p",[e._v("tcp_rcv_established() - net/ipv4/tcp_input.c (1795)\nif fast path\nchecks all flags and header info\nsends ACK\ncalls _skb_queue_tail() to put packet in socket receive queue\nelse (slow path)\nif out of sequence, sends ACK and drops packet\ncheck for FIN, SYN, RST, ACK\ncalls tcp_data() to queue packet\nsends ACK")]),e._v(" "),t("p",[e._v("tcp_recvmsg() - net/ipv4/tcp.c (1149)\nchecks for errors\nwait until there is at least one packet available\ncleans up socket if connection closed\ncalls memcpy_toiovec() to copy payload from the socket buffer into\nthe user space\ncalls cleanup_rbuf() to release memory and send ACK if necessary\ncalls remove_wait_queue() to wake process (if necessary)")]),e._v(" "),t("p",[e._v("udp_queue_rcv_skb() - net/ipv4/udp.c (963)\ncalls sock_queue_rcv_skb()\nupdates UDP status (frees skb if queue failed)")]),e._v(" "),t("p",[e._v("udp_rcv() - net/ipv4/udp.c (1062)\ngets UDP header, trims packet, verifies checksum (if required)\nchecks multicast\ncalls udp_v4_lookup() to match packet to socket\nif no socket found, send ICMP message back, free skb, and stop\ncalls udp_deliver() [= udp_queue_rcv_skb()]")]),e._v(" "),t("p",[e._v("udp_recvmsg() - net/ipv4/udp.c (794)\ncalls skb_recv_datagram() to get packet from queue\ncalls skb_copy_datagram_iovec() to move the payload from the socket buffer\ninto the user space\nupdates the socket timestamp\nfills in the source information in the message header\nfrees the packet memory")]),e._v(" "),t("h1",{attrs:{id:"chapter-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-7"}},[e._v("#")]),e._v(" Chapter 7")]),e._v(" "),t("p",[e._v("IP Forwarding")]),e._v(" "),t("p",[e._v("This chapter presents the pure routing side (by IP forwarding) of message traffic. It provides an overview of the process, examines the layers packets travel through, details the actions of each layer, and summarizes the implementation code within the kernel.")]),e._v(" "),t("h2",{attrs:{id:"_7-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-overview"}},[e._v("#")]),e._v(" 7.1  Overview")]),e._v(" "),t("p",[e._v("See Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#f_fwd",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.1"),t("OutboundLink")],1),e._v(" for an abstract diagram of the the forwarding process. (It is essentially a combination of the receiving and sending processes.)")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/f_fwd.gif",alt:"f_fwd.gif"}})]),e._v(" "),t("p",[e._v("Figure 7.1: IP forwarding.")]),e._v(" "),t("p",[e._v("A forwarded packet arrives with an interrupt when the system notifies the device that a message is ready. The device allocates storage space and tells the bus to put the message into that space. It then passes the packet to the link layer, which puts it on the backlog queue, marks the network flag for the next ``bottom-half'' run, and returns control to the current process.")]),e._v(" "),t("p",[e._v("When the process scheduler next runs, it sees that there are networking tasks to do and runs the network ``bottom-half''. This function pops packets off of the backlog queue, matches them to IP, and passes them to the receive function. The IP layer examines the packet for errors and routes it; the packet will go up to the transport layer (such as TCP or UDP if it is for this host) or sideways to the IP forwarding function. Within the forwarding function, IP checks the packet and sends an ICMP message back to the sender if anything is wrong. It then copies the packet into a new buffer and fragments it if necessary.")]),e._v(" "),t("p",[e._v("Finally the IP layer passes the packet to the link layer function, which moves the packet onto the sending device's xmit queue and makes sure the device knows that it has traffic to send. Finally, the device (such as a network card) tells the bus to send the packet.")]),e._v(" "),t("h2",{attrs:{id:"_7-2-ip-forward-walk-through"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-ip-forward-walk-through"}},[e._v("#")]),e._v(" 7.2  IP Forward Walk-Through")]),e._v(" "),t("h3",{attrs:{id:"_7-2-1-receiving-a-packet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-1-receiving-a-packet"}},[e._v("#")]),e._v(" 7.2.1  Receiving a Packet")]),e._v(" "),t("ul",[t("li",[e._v("Wake up the receiving device (interrupt)")]),e._v(" "),t("li",[e._v("Test the medium (device)")]),e._v(" "),t("li",[e._v("Receive the link header")]),e._v(" "),t("li",[e._v("Allocate space for the packet")]),e._v(" "),t("li",[e._v("Tell the bus to put the packet into the buffer")]),e._v(" "),t("li",[e._v("Put the packet on the backlog queue")]),e._v(" "),t("li",[e._v("Set the flag to run the network bottom half when possible")]),e._v(" "),t("li",[e._v("Return control to the current process")])]),e._v(" "),t("h3",{attrs:{id:"_7-2-2-running-the-network-bottom-half"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-2-running-the-network-bottom-half"}},[e._v("#")]),e._v(" 7.2.2  Running the Network ``Bottom Half''")]),e._v(" "),t("ul",[t("li",[e._v("Run the network bottom half (scheduler)")]),e._v(" "),t("li",[e._v("Send any packets that are waiting to prevent interrupts (net_bh)")]),e._v(" "),t("li",[e._v("Loop through all packets in the backlog queue and pass the packet up to its Internet reception protocol - IP")]),e._v(" "),t("li",[e._v("Flush the sending queue again")]),e._v(" "),t("li",[e._v("Exit the bottom half")])]),e._v(" "),t("h3",{attrs:{id:"_7-2-3-examining-a-packet-in-ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-3-examining-a-packet-in-ip"}},[e._v("#")]),e._v(" 7.2.3  Examining a Packet in IP")]),e._v(" "),t("ul",[t("li",[e._v("Check packet for errors - too short? too long? invalid version? checksum error?")]),e._v(" "),t("li",[e._v("Defragment the packet if necessary")]),e._v(" "),t("li",[e._v("Get the route for the packet (could be for this host or could need to be forwarded)")]),e._v(" "),t("li",[e._v("Send the packet to its destination handling routine (retransmission to another host in this case)")])]),e._v(" "),t("h3",{attrs:{id:"_7-2-4-forwarding-a-packet-in-ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-4-forwarding-a-packet-in-ip"}},[e._v("#")]),e._v(" 7.2.4  Forwarding a Packet in IP")]),e._v(" "),t("ul",[t("li",[e._v("Check TTL field (and decrement it)")]),e._v(" "),t("li",[e._v("Check packet for improper (undesired) routing")]),e._v(" "),t("li",[e._v("Send ICMP back to sender if there are any problems")]),e._v(" "),t("li",[e._v("Copy packet into new buffer and free old one")]),e._v(" "),t("li",[e._v("Set any IP options")]),e._v(" "),t("li",[e._v("Fragment packet if it is too big for new destination")]),e._v(" "),t("li",[e._v("Send the packet to the destination route's device output function")])]),e._v(" "),t("h3",{attrs:{id:"_7-2-5-transmitting-a-packet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-5-transmitting-a-packet"}},[e._v("#")]),e._v(" 7.2.5  Transmitting a Packet")]),e._v(" "),t("ul",[t("li",[e._v("Put the packet on the device output queue")]),e._v(" "),t("li",[e._v("Wake up the device")]),e._v(" "),t("li",[e._v("Wait for the scheduler to run the device driver")]),e._v(" "),t("li",[e._v("Test the medium (device)")]),e._v(" "),t("li",[e._v("Send the link header")]),e._v(" "),t("li",[e._v("Tell the bus to transmit the packet over the medium")])]),e._v(" "),t("h2",{attrs:{id:"_7-3-linux-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-linux-functions"}},[e._v("#")]),e._v(" 7.3  Linux Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the Linux kernel functions that are most important to IP forwarding, where they are in the source code, and what they do. To follow the functions calls, start with DEVICE_rx().")]),e._v(" "),t("p",[e._v("dev_queue_xmit() - net/core/dev.c (579)\ncalls start_bh_atomic()\nif device has a queue\ncalls enqueue() to add packet to queue\ncalls qdisc_wakeup() [= qdisc_restart()] to wake device\nelse calls hard_start_xmit()\ncalls end_bh_atomic()")]),e._v(" "),t("p",[e._v("DEVICE->hard_start_xmit() - device dependent, drivers/net/DEVICE.c\ntests to see if medium is open\nsends header\ntells bus to send packet\nupdates status")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("DEVICE_rx() - device dependent, drivers/net/DEVICE.c\n(gets control from interrupt)\nperforms status checks to make sure it should be receiving\ncalls dev_alloc_skb() to reserve space for packet\ngets packet off of system bus\ncalls eth_type_trans() to determine protocol type\ncalls netif_rx()\nupdates card status\n(returns from interrupt)")])])])]),e._v(" "),t("p",[e._v("ip_finish_output() - include/net/ip.h (140)\nsets sending device to output device for given route\ncalls output function for destination [= dev_queue_xmit()]")]),e._v(" "),t("p",[e._v("ip_forward() - net/ipv4/ip_forward.c (72)\nchecks for router alert\nif packet is not meant for any host, drops it\nif TTL has expired, drops packet and sends ICMP message back\nif strict route cannot be followed, drops packet and sends ICMP\nmessage back to sender\nif necessary, sends ICMP message telling sender packet is redirected\ncopies and releases old packet\ndecrements TTL\nif there are options, calls ip_forward_options() to set them\ncalls ip_send()")]),e._v(" "),t("p",[e._v("ip_rcv() - net/ipv4/ip_input.c (395)\nexamines packet for errors:\ninvalid length (too short or too long)\nincorrect version (not 4)\ninvalid checksum\ncalls __skb_trim() to remove padding\ndefrags packet if necessary\ncalls ip_route_input() to route packet\nexamines and handle IP options\nreturns skb->dst->input() [= ip_forward()]")]),e._v(" "),t("p",[e._v("ip_route_input() - net/ipv4/route.c (1366)\ncalls rt_hash_code() to get index for routing table\nloops through routing table (starting at hash) to find match for packet\nif it finds match:\nupdates stats for route (time and usage)\nsets packet destination to routing table entry\nreturns success\nelse\nchecks for multicasting addresses\nreturns result of ip_route_input_slow() (attempted routing)")]),e._v(" "),t("p",[e._v("ip_route_output_slow() - net/ipv4/route.c (1421)\nif source address is known, looks up output device\nif destination address is unknown, set up loopback\ncalls fib_lookup() to find route\nallocates memory new routing table entry\ninitializes table entry with source, destination, TOS, output device,\nflags\ncalls rt_set_nexthop() to find next destination\nreturns rt_intern_hash(), which installs route in routing table")]),e._v(" "),t("p",[e._v("ip_send() - include/net/ip.h (162)\ncalls ip_fragment() if packet is too big for device\ncalls ip_finish_output()")]),e._v(" "),t("p",[e._v("net_bh() - net/core/dev.c (835)\n(run by scheduler)\nif there are packets waiting to go out, calls qdisc_run_queues()\n(see sending section)\nwhile the backlog queue is not empty\nlet other bottom halves run\ncall skb_dequeue() to get next packet\nif the packet is for someone else (FASTROUTED) put onto send queue\nloop through protocol lists (taps and main) to match protocol type\ncall pt_prev->func() [= ip_rcv()] to pass packet to appropriate\nprotocol\ncall qdisc_run_queues() to flush output (if necessary)")]),e._v(" "),t("p",[e._v("netif_rx() - net/core/dev.c (757)\nputs time in skb->stamp\nif backlog queue is too full, drops packet\nelse\ncalls skb_queue_tail() to put packet into backlog queue\nmarks bottom half for later execution")]),e._v(" "),t("p",[e._v("qdisc_restart() - net/sched/sch_generic.c (50)\npops packet off queue\ncalls dev->hard_start_xmit()\nupdates status\nif there was an error, requeues packet")]),e._v(" "),t("p",[e._v("rt_intern_hash() - net/ipv4/route.c (526)\nputs new route in routing table")]),e._v(" "),t("h1",{attrs:{id:"chapter-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-8"}},[e._v("#")]),e._v(" Chapter 8")]),e._v(" "),t("p",[e._v("Basic Internet Protocol Routing")]),e._v(" "),t("p",[e._v("This chapter presents the basics of IP Routing. It provides an overview of how routing works, examines how routing tables are established and updated, and summarizes the implementation code within the kernel.")]),e._v(" "),t("h2",{attrs:{id:"_8-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-overview"}},[e._v("#")]),e._v(" 8.1  Overview")]),e._v(" "),t("p",[e._v("Linux maintains three sets of routing data - one for computers that are directly connected to the host (via a LAN, for example) and two for computers that are only indirectly connected (via IP networking). Examine Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.1"),t("OutboundLink")],1),e._v(" to see how entries for a computer in the general example might look.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_overview.gif",alt:"r_overview.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.1: General routing table example.")]),e._v(" "),t("p",[e._v("The neighbor table contains address information for computers that are physically connected to the host (hence the name ``neighbor''). It includes information on which device connects to which neighbor and what protocols to use in exchanging data. Linux uses the Address Resolution Protocol (ARP) to maintain and update this table; it is dynamic in that entries are added when needed but eventually disappear if not used again within a certain time. (However, administrators can set up entries to be permanent if doing so makes sense.)")]),e._v(" "),t("p",[e._v("Linux uses two complex sets of routing tables to maintain IP addresses: an all-purpose Forwarding Information Base (FIB) with directions to every possible address, and a smaller (and faster) routing cache with data on frequently used routes. When an IP packet needs to go to a distant host, the IP layer first checks the routing cache for an entry with the appropriate source, destination, and type of service. If there is such an entry, IP uses it. If not, IP requests the routing information from the more complete (but slower) FIB, builds a new cache entry with that data, and then uses the new entry. While the FIB entries are semi-permanent (they usually change only when routers come up or go down) the cache entries remain only until they become obsolete (they are unused for a ``long'' period).")]),e._v(" "),t("h2",{attrs:{id:"_8-2-routing-tables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-routing-tables"}},[e._v("#")]),e._v(" 8.2  Routing Tables")]),e._v(" "),t("p",[e._v("Note: within these tables, there are references to variables of types such as u32 (host byte order) and __u32 (network byte order). On the Intel architecture they are both equivalent to unsigned ints and in point of fact they are translated (using the ntohl function) anyway; the type merely gives an indication of the order in which the value it contains is stored.")]),e._v(" "),t("h3",{attrs:{id:"_8-2-1-the-neighbor-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-the-neighbor-table"}},[e._v("#")]),e._v(" 8.2.1  The Neighbor Table")]),e._v(" "),t("p",[e._v("The Neighbor Table (whose structure is shown in Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_neigh_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2"),t("OutboundLink")],1),e._v(") contains information about computers that are physically linked with the host computer. (Note that the source code uses the European spelling, ``neighbour''.) Entries are not (usually) persistent; this table may contain no entries (if the computer has not passed any network traffic recently) or may contain as many entries as there are computers physically connected to its network (if it has communicated with all of them recently). Entries in the table are actually other table structures which contain addressing, device, protocol, and statistical information.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_neigh_struct.gif",alt:"r_neigh_struct.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.2: Neighbor Table data structure relationships.")]),e._v(" "),t("p",[e._v("struct neigh_table *neigh_tables - this global variable is a pointer to a list of neighbor tables; each table contains a set of general functions and data and a hash table of specific information about a set of neighbors. This is a very detailed, low level table containing specific information such as the approximate transit time for messages, queue sizes, device pointers, and pointers to device functions.")]),e._v(" "),t("p",[e._v("Neighbor Table (struct neigh_table) Structure - this structure (a list element) contains common neighbor information and table of neighbor data and pneigh data. All computers connected through a single type of connection (such as a single Ethernet card) will be in the same table.")]),e._v(" "),t("ul",[t("li",[e._v("struct neigh_table *next - pointer to the next table in the list.")]),e._v(" "),t("li",[e._v("struct neigh_parms parms - structure containing message travel time, queue length, and statistical information; this is actually the head of a list.")]),e._v(" "),t("li",[e._v("struct neigh_parms *parms_list - pointer to a list of information structures.")]),e._v(" "),t("li",[e._v("struct neighbour *hash_buckets[] - hash table of neighbors associated with this table; there are NEIGH_HASHMASK+1 (32) buckets.")]),e._v(" "),t("li",[e._v("struct pneigh_entry *phash_buckets[] - hash table of structures containing device pointers and keys; there are PNEIGH_HASHMASK+1 (16) buckets.")]),e._v(" "),t("li",[e._v("Other fields include timer information, function pointers, locks, and statistics.")])]),e._v(" "),t("p",[e._v("Neighbor Data (struct neighbour) Structure - these structures contain the specific information about each neighbor.")]),e._v(" "),t("ul",[t("li",[e._v("struct device *dev - pointer to the device that is connected to this neighbor.")]),e._v(" "),t("li",[e._v("__u8 nud_state - status flags; values can be incomplete, reachable, stale, etc.; also contains state information for permanence and ARP use.")]),e._v(" "),t("li",[e._v("struct hh_cache *hh - pointer to cached hardware header for transmissions to this neighbor.")]),e._v(" "),t("li",[e._v("struct sk_buff_head arp_queue - pointer to ARP packets for this neighbor.")]),e._v(" "),t("li",[e._v("Other fields include list pointers, function (table) pointers, and statistical information.")])]),e._v(" "),t("h3",{attrs:{id:"_8-2-2-the-forwarding-information-base"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-2-the-forwarding-information-base"}},[e._v("#")]),e._v(" 8.2.2  The Forwarding Information Base")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_gen.gif",alt:"r_fib_gen.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.3: Forwarding Information Base (FIB) conceptual organization.")]),e._v(" "),t("p",[e._v("The Forwarding Information Base (FIB) is the most important routing structure in the kernel; it is a complex structure that contains the routing information needed to reach any valid IP address by its network mask. Essentially it is a large table with general address information at the top and very specific information at the bottom. The IP layer enters the table with the destination address of a packet and compares it to the most specific netmask to see if they match. If they do not, IP goes on to the next most general netmask and again compares the two. When it finally finds a match, IP copies the ``directions'' to the distant host into the routing cache and sends the packet on its way. See Figures "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3"),t("OutboundLink")],1),e._v(" and "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.4"),t("OutboundLink")],1),e._v(" for the organization and data structures used in the FIB - note that Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3"),t("OutboundLink")],1),e._v(" shows some different FIB capabilities, like two sets of network information for a single zone, and so does not follow the general example.)")]),e._v(" "),t("p",[e._v("struct fib_table *local_table, *main_table - these global variables are the access points to the FIB tables; they point to table structures that point to hash tables that point to zones. The contents of the main_table variable are in "),t("em",[e._v("/proc/net/route")]),e._v(".")]),e._v(" "),t("p",[e._v("FIB Table fib_table Structure - "),t("em",[e._v("include/net/ip_fib.h")]),e._v(" - these structures contain function jump tables and each points to a hash table containing zone information. There are usually only one or two of these.")]),e._v(" "),t("ul",[t("li",[e._v("int (*tb__functions_)() - pointers to table functions (lookup, delete, insert, etc.) that are set during initialization to fn_hash__function_().")]),e._v(" "),t("li",[e._v("unsigned char tb_data[0] - pointer to the associated FIB hash table (despite its declaration as a character array).")]),e._v(" "),t("li",[e._v("unsigned char tb_id - table identifier; 255 for local_table, 254 for main_table.")]),e._v(" "),t("li",[e._v("unsigned tb_stamp")])]),e._v(" "),t("p",[e._v("Netmask Table fn_hash Structure - "),t("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" - these structures contain pointers to the individual zones, organized by netmask. (Each zone corresponds to a uniquely specific network mask.) There is one of these for each FIB table (unless two tables point to the same hash table).")]),e._v(" "),t("ul",[t("li",[e._v("struct fn_zone *fn_zones[33] - pointers to zone entries (one zone for each bit in the mask; fn_zone[0] points to the zone for netmask 0x0000, fn_zone[1] points to the zone for 0x8000, and fn_zone[32] points to the zone for 0xFFFF.")]),e._v(" "),t("li",[e._v("struct fn_zone *fn_zone_list - pointer to first (most specific) non-empty zone in the list; if there is an entry for netmask 0xFFFF it will point to that zone, otherwise it may point to zone 0xFFF0 or 0xFF00 or 0xF000 etc.")])]),e._v(" "),t("p",[e._v("Network Zone fn_zone Structure - "),t("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" - these structures contain some hashing information and pointers to hash tables of nodes. There is one of these for each known netmask.")]),e._v(" "),t("ul",[t("li",[e._v("struct fn_zone *fz_next - pointer to the next non-empty zone in the hash structure (the next most general netmask; e.g., fn_hash- > fn_zone[28]- > fz_next might point to fn_hash- > fn_zone[27]).")]),e._v(" "),t("li",[e._v("struct fib_node **fz_hash - pointer to a hash table of nodes for this zone.")]),e._v(" "),t("li",[e._v("int fz_nent - the number of entries (nodes) in this zone.")]),e._v(" "),t("li",[e._v("int fx_divisor - the number of buckets in the hash table associated with this zone; there are 16 buckets in the table for most zones (except the first zone - 0000 - the loopback device).")]),e._v(" "),t("li",[e._v("u32 fz_hashmask - a mask for entering the hash table of nodes; 15 (0x0F) for most zones, 0 for zone 0).")]),e._v(" "),t("li",[e._v("int fz_order - the index of this zone in the parent fn_hash structure (0 to 32).")]),e._v(" "),t("li",[e._v("u32 fz_mask - the zone netmask defined as ~((1<<(32-fz_order))-1); for example, the first (zero) element is 1 shifted left 32 minus 0 times (0x10000), minus 1 (0xFFFF), and complemented (0x0000). The second element has a netmask of 0x8000, the next 0xC000, the next 0xE000, 0xF000, 0xF800, and so on to the last (32d) element whose mask is 0xFFFF.")])]),e._v(" "),t("p",[e._v("Network Node Information fib_node Structure - "),t("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" - these structures contain the information unique to each set of addresses and a pointer to information about common features (such as device and protocols); there is one for each known network (unique source/destination/TOS combination).")]),e._v(" "),t("ul",[t("li",[e._v("struct fib_node *fn_next - pointer to the next node.")]),e._v(" "),t("li",[e._v("struct fib_info *fn_info - pointer to more information about this node (that is shared by many nodes).")]),e._v(" "),t("li",[e._v("fn_key_t fn_key - hash table key - the least significant 8 bits of the destination address (or 0 for the loopback device).")]),e._v(" "),t("li",[e._v("Other fields include specific information about this node (like fn_tos and fn_state).")])]),e._v(" "),t("p",[e._v("Network Protocol Information (fib_info) Structure - "),t("em",[e._v("include/net/ip_fib.h")]),e._v(" - these structures contain protocol and hardware information that are specific to an interface and therefore common to many potential zones; several networks may be addressable through the same interface (like the one that leads to the rest of the Internet). There is one of these for each interface.")]),e._v(" "),t("ul",[t("li",[e._v("fib_protocol - index to a network protocol (e.g., IP) used for this route.")]),e._v(" "),t("li",[e._v("struct fib_nh fib_nh[0] - contains a pointer to the device used for sending or receiving traffic for this route.")]),e._v(" "),t("li",[e._v("Other fields include list pointers and statistical and reference data (like fib_refcnt and fib_flags.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_struct.gif",alt:"r_fib_struct.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.4: Forwarding Information Base (FIB) data relationships.")]),e._v(" "),t("p",[t("strong",[e._v("FIB Traversal Example:")])]),e._v(" "),t("ol",[t("li",[e._v("ip_route_output_slow() (called because the route is not in the routing cache) sets up an rt_key structure with a source address of 172.16.0.7, a destination address of 172.16.0.34, and a TOS of 2.")]),e._v(" "),t("li",[e._v("ip_route_output_slow() calls fib_lookup() and passes it the key to search for.")]),e._v(" "),t("li",[e._v("fib_lookup() calls local_table- > tb_lookup() (which is a reference to the fn_hash_lookup function) to make the local table find the key.")]),e._v(" "),t("li",[e._v("fn_hash_lookup() searches the local table's hash table, starting in the most specific zone - 24 (netmask 255.255.255.0 dotted decimal) (pointed to by the fn_zone_list variable).")]),e._v(" "),t("li",[e._v("fz_key() builds a test key by ANDing the destination address with the zone netmask, resulting in a key value 172.16.0.0.")]),e._v(" "),t("li",[e._v("fz_chain() performs the hash function (see fn_hash()) and ANDs this value with the zone's fz_hashmask (15) to get an index (6) into the zone's hash table of nodes. Unfortunately, this node is empty; there are no possible matches in this zone.")]),e._v(" "),t("li",[e._v("fn_hash_lookup() moves to the next non-empty zone - 16 (netmask 255.255.0.0 dotted decimal) (pointed to by the current zone's fz_next variable).")]),e._v(" "),t("li",[e._v("fz_key() builds a new test key by ANDing the destination address with this zone's netmask, resulting in a key value of 172.16.0.0.")]),e._v(" "),t("li",[e._v("fz_chain() performs the hash function and ANDs this value with the zone's fz_hashmask (15) to get an index (10) into the zone's hash table of nodes. There is a node in that slot.")]),e._v(" "),t("li",[e._v("fn_hash_lookup() compares its search key to the node's key. They do not match, but the search key value is less than that of the node key, so it moves on to the next node.")]),e._v(" "),t("li",[e._v("fn_hash_lookup() compares its search key to the new node's key. These do match, so it does some error checking and tests for an exact match with the node and its associated info variable.")]),e._v(" "),t("li",[e._v("Since everything matches, fn_hash_lookup() fills in a fib_result structure with all the information about this route. (Otherwise it would continue checking more nodes and more zones until it finds a match or fails completely.)")]),e._v(" "),t("li",[e._v("ip_route_output_slow() takes the fib_result structure and, assuming everything is in order, creates a new routing cache entry from it.")])]),e._v(" "),t("h3",{attrs:{id:"_8-2-3-the-routing-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-3-the-routing-cache"}},[e._v("#")]),e._v(" 8.2.3  The Routing Cache")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_gen.gif",alt:"r_cache_gen.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.5: Routing Cache conceptual organization.")]),e._v(" "),t("p",[e._v("The routing cache is the fastest method Linux has to find a route; it keeps every route that is currently in use or has been used recently in a hash table. When IP needs a route, it goes to the appropriate hash bucket and searches the chain of cached routes until finds a match, then sends the packet along that path. (See Section "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_the_FIB",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.2"),t("OutboundLink")],1),e._v(" for what happens when the route is not yet in the cache.) Routes are chained in order, most frequently used first, and have timers and counters that remove them from the table when they are no longer in use. See Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.5"),t("OutboundLink")],1),e._v(" for an abstract overview and Figures "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.6"),t("OutboundLink")],1),e._v(" and "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_dst_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.7"),t("OutboundLink")],1),e._v(" for detailed diagrams of the data structures.")]),e._v(" "),t("p",[e._v("struct rtable *rt_hash_table[RT_HASH_DIVISOR] - this global variable contains 256 buckets of (pointers to) chains of routing cache (rtable) entries; the hash function combines the source address, destination address, and TOS to get an entry point to the table (between 0 and 255). The contents of this table are listed in "),t("em",[e._v("/proc/net/rt_cache")]),e._v(".")]),e._v(" "),t("p",[e._v("Routing Table Entry (rtable) Structure - "),t("em",[e._v("include/net/route.h")]),e._v(" - these structures contain the destination cache entries and identification information specific to each route.")]),e._v(" "),t("ul",[t("li",[e._v("union < struct dst_entry dst; struct rtable* rt_next) > u - this is an entry in the table; the union structure allows quick access to the next entry in the table by overusing the rtable's next field to point to the next cache entry if required.")]),e._v(" "),t("li",[e._v("__u32 rt_dst - the destination address.")]),e._v(" "),t("li",[e._v("__u32 rt_src - the source address.")]),e._v(" "),t("li",[e._v("rt_int iif - the input interface.")]),e._v(" "),t("li",[e._v("__u32 rt_gateway - the address of the neighbor to route through to get to a destination.")]),e._v(" "),t("li",[e._v("struct rt_key key - a structure containing the cache lookup key (with src, dst, iif, oif, tos, and scope fields)")]),e._v(" "),t("li",[e._v("Other fields contain flags, type, and other miscellaneous information.")])]),e._v(" "),t("p",[e._v("Destination Cache (dst_entry) Structure - "),t("em",[e._v("include/net/dst.h")]),e._v(" - these structures contain pointers to specific input and output functions and data for a route.")]),e._v(" "),t("ul",[t("li",[e._v("struct device *dev - the input/output device for this route.")]),e._v(" "),t("li",[e._v("unsigned pmtu - the maximum packet size for this route.")]),e._v(" "),t("li",[e._v("struct neighbor *neighbor - a pointer to the neighbor (next link) for this route.")]),e._v(" "),t("li",[e._v("struct hh_cache *hh - a pointer to the hardware header cache; since this is the same for every outgoing packet on a physical link, it is kept for quick access and reuse.")]),e._v(" "),t("li",[e._v("int ("),t("em",[e._v("input)(struct sk_buff")]),e._v(") - a pointer to the input function for this route (typically tcp_recv()).")]),e._v(" "),t("li",[e._v("int ("),t("em",[e._v("output)(struct sk_buff")]),e._v(") - a pointer to the output function for this route (typically dev_queue_xmit()).")]),e._v(" "),t("li",[e._v("struct dst_ops *ops - a pointer to a structure containing the family, protocol, and check, reroute, and destroy functions for this route.")]),e._v(" "),t("li",[e._v("Other fields hold statistical and state information and links to other routing table entries.")])]),e._v(" "),t("p",[e._v("Neighbor Link (neighbor) Structure - "),t("em",[e._v("include/net/neighbor.h")]),e._v(" - these structures, one for each host that is exactly one hop away, contain pointers to their access functions and information.")]),e._v(" "),t("ul",[t("li",[e._v("struct device *dev - a pointer to device that is physically connected to this neighbor.")]),e._v(" "),t("li",[e._v("struct hh_cache *hh - a pointer to the hardware header that always precedes traffic sent to this neighbor.")]),e._v(" "),t("li",[e._v("int ("),t("em",[e._v("output)(struct sk_buff")]),e._v(") - a pointer to the output function for this neighbor (typically dev_queue_xmit()?).")]),e._v(" "),t("li",[e._v("struct sk_buff_head arp_queue - the first element in the ARP queue for traffic concerning this neighbor - incoming or outgoing?")]),e._v(" "),t("li",[e._v("struct neigh_ops *ops - a pointer to a structure that containing family data and and output functions for this link.")]),e._v(" "),t("li",[e._v("Other fields hold statistical and state information and references to other neighbors.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_struct.gif",alt:"r_cache_struct.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.6: Routing Cache data structure relationships.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_dst_struct.gif",alt:"r_dst_struct.gif"}})]),e._v(" "),t("p",[e._v("Figure 8.7: Destination Cache data structure relationships.")]),e._v(" "),t("p",[t("strong",[e._v("Routing Cache Traversal Example:")])]),e._v(" "),t("ol",[t("li",[e._v("ip_route_output() (called to find a route) calls rt_hash_code() with a source address of 172.16.1.1, a destination address of 172.16.1.6, and a TOS of 2.")]),e._v(" "),t("li",[e._v("rt_hash_code() performs a hash function on the source, destination, and TOS and ANDs the result with 255 to get an entry into the hash table (5).")]),e._v(" "),t("li",[e._v("ip_route_output() enters the hash table at index 5. There is an entry there, but the destination addresses do not match.")]),e._v(" "),t("li",[e._v("ip_route_output() moves to the next entry (pointed to by the u.rt_next field of the last entry). This one matches in every case - destination address, source address, iif of 0, matching oif, and acceptable TOS.")]),e._v(" "),t("li",[e._v("ip_route_output() updates the statistics in the newfound dst_cache structure of the table entry, sets a pointer for the calling function to refer to the route, and returns a 0 indicating success.")])]),e._v(" "),t("h3",{attrs:{id:"_8-2-4-updating-routing-information"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-4-updating-routing-information"}},[e._v("#")]),e._v(" 8.2.4  Updating Routing Information")]),e._v(" "),t("p",[e._v("Linux only updates routing information when necessary, but the tables change in different manners. The routing cache is the most volatile, while the FIB usually does not change at all.")]),e._v(" "),t("p",[e._v("The neighbor table changes as network traffic is exchanged. If a host needs to send something to an address that is on the local subnet but not already in the neighbor table, it simply broadcasts an ARP request and adds a new entry in the neighbor table when it gets a reply. Periodically entries time out and disappear; this cycle continues indefinitely (unless a route has been specifically marked as ARP permanent). The kernel handles most changes automatically.")]),e._v(" "),t("p",[e._v("The FIB on most hosts and even routers remains static; it is filled in during initialization with every possible zone to route through all connected routers and never changes unless one of the routers goes down. (See Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),t("OutboundLink")],1),e._v(" for details on IP routing daemons). Changes have to come through external ioctl() calls to add or delete zones.")]),e._v(" "),t("p",[e._v("The routing cache changes frequently depending on message traffic. If a host needs to send packets to a remote address, it looks up the address in the routing cache (and FIB if necessary) and sends the packet off through the appropriate router. On a host connected to a LAN with one router to the Internet, every entry will point to either a neighbor or the router, but there may be many entries that point to the router (one for each distant address). The entries are created as connections are made and time out quickly when traffic to that address stops flowing. Everything is done with IP level calls to create routes and kernel timers to delete them.")]),e._v(" "),t("h2",{attrs:{id:"_8-3-linux-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-linux-functions"}},[e._v("#")]),e._v(" 8.3  Linux Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the Linux kernel functions that are most important to routing, where they are in the source code, and what they do.")]),e._v(" "),t("p",[e._v("arp_rcv() - net/ipv4/arp.c (542)\nchecks for errors (non-ARP device, no device, packet not for host,\ndevice type does not match, etc.)\ncheck for operation - only understands REPLY and REQUEST\nextracts data from packet\ncheck for bad requests - loopback or multicast addresses\nchecks for duplicate address detection packet (sends reply if necessary)\nif the message is a request and ip_route_input() is true:\nif the packet is a local one:\ncalls neigh_event_ns() to look up and update neighbor that sent packet\nchecks for hidden device (does not reply if hidden)\nsends reply with the device address\notherwise:\ncalls neigh_event_ns() to look up and update neighbor that sent packet\ncalls neigh_release()\nif necessary, calls arp_send() with the address\notherwise calls pneigh_enqueue() and returns 0\nif the message is a reply:\ncalls __neigh_lookup()\nchecks to see if multiple ARP replies have come in; keeps only the\nfastest (first) one\ncalls neigh_update() to update ARP entry\ncalls neigh_release()\nfrees the skbuffer and returns 0")]),e._v(" "),t("p",[e._v("arp_send() - net/ipv4/arp.c (434)\nchecks to make sure device supports ARP\nallocates an skbuffer\nfills in buffer header information\nfills in the ARP information\ncalls dev_queue_xmit() with the finished packet")]),e._v(" "),t("p",[e._v("arp_req_get() - net/ipv4/arp.c (848)\ncalls __neigh_lookup() to find entry for given address\ncopies data from neighbor entry to arpreq entry\nreturns 0 if found or ENXIO if address not in ARP table")]),e._v(" "),t("p",[e._v("fib_get_procinfo() - net/ipv4/fib_frontend.c (109)\nprints header and results of main_table->fn_hash_get_info() for proc FS")]),e._v(" "),t("p",[e._v("fib_lookup() - include/net/ip_fib.h (153)\ncalls tb_lookup() [= fn_hash_lookup()] on local_table and main_table\nif either one has an entry, it fills in fib_result and returns 0\nelse returns unreachable error")]),e._v(" "),t("p",[e._v("fib_node_get_info() - net/ipv4/fib_semantics.c (971)\nprints fib_node and fib_info contents for proc FS")]),e._v(" "),t("p",[e._v("fib_validate_source() - net/ipv4/fib_frontend.c (191)\ntests incoming packet's device and address\nreturns error code if something is wrong\nreturns 0 if packet seems legal")]),e._v(" "),t("p",[e._v("fn_hash() - net/ipv4/fib_hash.c (108)\nperforms a hash function on a destination address:\nu32 h = ntohl(daddr)>>(32 - fib_zone->fz_order);\nh ^= (h>>20);\nh ^= (h>>10);\nh ^= (h>>5);\nh &= FZ_HASHMASK(fz);   // FZ_HASHMASK is 15 for almost all zones")]),e._v(" "),t("p",[e._v("fn_hash_get_info() - net/ipv4/fib_hash.c (723)\nloops through zones in a FIB table printing fib_node_get_info() for\nproc FS")]),e._v(" "),t("p",[e._v("fn_hash_lookup() - net/ipv4/fib_hash.c (261)\nloops through the zones in the given table\nloops through the nodes in each zone (starting at the hash entry)\nif the netmasks (node and destination) match\nchecks the TOS and node status\ncalls fib_semantic_match() to check packet type\nfills in fib_result with success data and returns 0\nreturns 1 if nothing matched")]),e._v(" "),t("p",[e._v("fn_new_zone() - net/ipv4/fib_hash.c (220)\nallocates memory (in kernel) for new zone\nallocates space for 16 node buckets for zone (except first zone -\n0.0.0.0 [loopback] - which only gets one)\nstores netmask (leftmost n bits on, where n is the position of the\nzone in the table)\nsearches for more specific zone in parent table\ninserts zone into zone list (most specific zone is head)\ninstalls new zone into parent table\nreturns new zone")]),e._v(" "),t("p",[e._v("fz_chain() - net/ipv4/fib_hash.c (133)\ncalls fn_hash() to get a hash value\nreturns the fib_node in the fib_zone at the hash index")]),e._v(" "),t("p",[e._v("ip_dev_find() - net/ipv4/fib_frontend.c (147)\nlooks up and returns the device with a given address in the local table")]),e._v(" "),t("p",[e._v("ip_route_connect() - include/net/route.h (140)\ncalls ip_route_output() to get a destination address\nreturns if the call works or generates an error\notherwise clears the route pointer and try again")]),e._v(" "),t("p",[e._v("ip_route_input() - net/ipv4/route.c (1366)\ncalculates hash value for address\nruns through table (starting at hash) to find connection match\n(source, destination, TOS, and IIF/OIF)\nif there is a match, updates stats and returns routing entry\nelse calls ip_route_input_slow()")]),e._v(" "),t("p",[e._v("ip_route_input_slow() - net/ipv4/route.c (1097)\ncreates a routing table cache key\nchecks for special addresses (like loopback, broadcast, or errors)\ncalls fib_lookup() to find route\nallocates memory for new routing table entry\ninitializes table entry with source, destination, TOS, output device,\nflags\ncalls fib_validate_source() to test packet source\nprintks message and returns error if source is bad\ncalls rt_set_nexthop() to find next destination (neighbor)\nreturns rt_intern_hash(), which installs route in routing table")]),e._v(" "),t("p",[e._v("ip_route_output() - net/ipv4/route.c (1664)\ncalculates hash value for address\nruns through table (starting at hash) to find connection match\n(source, destination, TOS, and IIF/OIF)\nif there is a match, updates stats and returns routing entry\nelse calls ip_route_output_slow()")]),e._v(" "),t("p",[e._v("ip_route_output_slow() - net/ipv4/route.c (1421)\ncreates a routing table cache key\nif source address is known, calls ip_dev_find to determine output device\nif destination address is unknown, set up loopback\ncalls fib_lookup() to find route\nallocates memory for new routing table entry\ninitializes table entry with source, destination, TOS, output device,\nflags\ncalls rt_set_nexthop() to find next destination (neighbor)\nreturns rt_intern_hash(), which installs route in routing table")]),e._v(" "),t("p",[e._v("ip_rt_ioctl() - net/ipv4/fib_frontend.c (250)\nswitches on SIOCADDRT or SIOCDELRT (returns EINVAL otherwise)\nverifies permission and copies argument to kernel space\nconverts copied argument to an rtentry structure\nif deleting a route, calls fib_get_table() and table->delete()\nelse calls fib_new_table() and table->insert()\nfrees argument space and returns 0 for success")]),e._v(" "),t("p",[e._v("neigh_event_ns() - net/core/neighbour.c (760)\ncalls __neigh_lookup() to find up address in neighbor table\ncalls neigh_update()\nreturns pointer to designated neighbor")]),e._v(" "),t("p",[e._v("neigh_update() - net/core/neighbour.c (668)\nchecks permissions to modify table\nchecks neighbor status if this is not a new entry\ncompares given address to cached one:\nif null or device has no address, uses current address\nif different, check override flag\ncalls neigh_sync() to verify neighbor is still up\nupdates neighbor contact time\nif old entry was valid and new one does not change address, returns 0\nif new address is different from old, replaces old with new\nif new and old states match, returns 0\ncalls neigh_connect() or neigh_suspect() to make/check connection\nif old state was invalid:\ngoes through packets in ARP queue, calling the neighbor output()\nfunction on each\npurges the ARP queue\nreturns 0")]),e._v(" "),t("p",[e._v("rt_cache_get_info() - net/ipv4/route.c (191)\nprints header and all elements of rt_hash_table for proc FS")]),e._v(" "),t("p",[e._v("rt_hash_code() - net/ipv4/route.c (18)\nuses source address, destination address, and type of service to\ndetermine (and return) a hash value:\nhash = ((daddr&0xF0F0F0F0)>>4)|((daddr&0x0F0F0F0F)<<4);\nhash = hash^saddr^tos;\nhash = hash^(hash>>16);\nhash = (hash^(hash>>8)) & 0xFF;")]),e._v(" "),t("p",[e._v("rt_intern_hash() - net/ipv4/route.c (526)\nputs new route in routing table")]),e._v(" "),t("h1",{attrs:{id:"chapter-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-9"}},[e._v("#")]),e._v(" Chapter 9")]),e._v(" "),t("p",[e._v("Dynamic Routing with "),t("em",[e._v("routed")])]),e._v(" "),t("p",[e._v("This chapter presents dynamic routing as performed by a router (as opposed to an end host computer). It provides an overview of how the "),t("em",[e._v("routed")]),e._v(" program implements routing protocols under Linux, examines how it modifies the kernel routing tables, and summarizes the implementation code.")]),e._v(" "),t("h2",{attrs:{id:"_9-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-overview"}},[e._v("#")]),e._v(" 9.1  Overview")]),e._v(" "),t("p",[e._v("A normal host computer has very limited options for routing packets; a message is either for itself or another computer, and if it is for another computer there are a very limited number of options for sending it on. Usually such a host needs only to put a packet out on a LAN for a "),t("code",[e._v("gateway'' computer (router) to pick up and send on its way. Linux usually does not maintain any metric (distance) information about routes, even though there are variables for storing it in the FIB. For simple end-host routing, the only important question is")]),e._v("can I get there from here'', not ``which way is best?''")]),e._v(" "),t("p",[e._v("However, a router must make decisions on where to send traffic. There may be several routes to a destination, and the router must select one (based on distance, measured in hops or some other metric such as the nebulous quality of service). The Routing Information Protocol (RIP) is a simple protocol that allows routing computers to track the distance to various destinations and to share this information amongst themselves.")]),e._v(" "),t("p",[e._v("Using RIP, each node maintains a table that contains the distance from itself to other networks and the route along which it will send packets to that destination. Periodically the routers update each other; when shorter routes becomes apparent, the node updates its table. Updates are simply RIP messages with the destination address and metric components of this table. See Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#d_rip",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.1"),t("OutboundLink")],1),e._v(" for a diagram of an RIP routing table and an RIP packet.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/d_rip.gif",alt:"d_rip.gif"}})]),e._v(" "),t("p",[e._v("Figure 9.1: Routing Information Protocol packet and table.")]),e._v(" "),t("h2",{attrs:{id:"_9-2-how-routed-works"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-how-routed-works"}},[e._v("#")]),e._v(" 9.2  How "),t("em",[e._v("routed")]),e._v(" Works")]),e._v(" "),t("p",[t("em",[e._v("routed")]),e._v(" is a widely available program for implementing RIP via UDP messages on POSIX computers. It is essentially a stand-alone program which uses ioctl() calls to get information from and update routing tables on the host machine.")]),e._v(" "),t("h3",{attrs:{id:"_9-2-1-data-structures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-1-data-structures"}},[e._v("#")]),e._v(" 9.2.1  Data Structures")]),e._v(" "),t("p",[t("em",[e._v("routed")]),e._v(" maintains two identical data tables - one for hosts and one for networks. Each is a hash table with ROUTEHASHSIZ (32) buckets of chains of routing entries. The entries contain the RIP information (but can also line up with a struct rtentry so that "),t("em",[e._v("routed")]),e._v(" can pass them to the kernel through ioctl() calls). Along with the basic destination, router, and metric information the entries store flags, state, and timer information.")]),e._v(" "),t("h3",{attrs:{id:"_9-2-2-initialization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-2-initialization"}},[e._v("#")]),e._v(" 9.2.2  Initialization")]),e._v(" "),t("p",[e._v("When "),t("em",[e._v("routed")]),e._v(" begins, it performs various initialization actions and calls ioctl() to get interface information from the kernel. Next it sends out a RIP/UDP message requesting routing information from all neighboring routers. Finally it enters an infinite loop in which it waits for traffic or timers to make it do something.")]),e._v(" "),t("h3",{attrs:{id:"_9-2-3-normal-operations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-3-normal-operations"}},[e._v("#")]),e._v(" 9.2.3  Normal Operations")]),e._v(" "),t("p",[e._v("When RIP messages arrive (via a UDP socket), "),t("em",[e._v("routed")]),e._v(" parses them and either modifies its table (for response messages) or sends information back to the requesting router (for requests). Sending information is simply a matter of looking up a destination in its own table, putting that information into a RIP packet, and sending it out through a UDP socket. Updating its table may have no impact (if there is no change or the change makes no difference) or it may result in a routing change. If the update reveals a shorter route to a destination, "),t("em",[e._v("routed")]),e._v(" will update its own table and then call ioctl() to update the kernel's routing tables (the FIB).")]),e._v(" "),t("p",[e._v("When the update timer expires, every TIMER_RATE seconds, "),t("em",[e._v("routed")]),e._v(" goes through every entry in both tables and updates their timers. Entries which are out of date are set to a distance of infinity (HOPCNT_INFINITY) and entries which are too old are deleted (only from the RIP table, not from the kernel's FIB). Finally, it sends an update to its neighboring routers. This update contains the new table information (response messages) for any entries which have changed since the last update.")]),e._v(" "),t("p",[t("em",[e._v("routed")]),e._v(" leaves the actual routing to the normal kernel routing mechanisms; all it does is update the kernel's tables based on information from other routers and pass on its own routing information. The updates then change how the kernel routes packets, but "),t("em",[e._v("routed")]),e._v(" itself does not actually do any routing.")]),e._v(" "),t("h2",{attrs:{id:"_9-3-routed-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-routed-functions"}},[e._v("#")]),e._v(" 9.3  "),t("em",[e._v("routed")]),e._v(" Functions")]),e._v(" "),t("p",[e._v("The following is an alphabetic list of the "),t("em",[e._v("routed")]),e._v(" program functions that are most important to routing, where they are in the source code, and what they do. The "),t("em",[e._v("SOURCES")]),e._v(" directory shown represents the directory that contains the source code for the given network file.")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("routed")]),e._v(" source is available as a package separate from the kernel source (Red Hat Linux uses the "),t("em",[e._v("rpm")]),e._v(" package manager). The code below is from the "),t("em",[e._v("netkit-routed-0.10")]),e._v(" source code package, 8 March 1997. This package is available from the "),t("em",[e._v("www.redhat.com/apps/download")]),e._v(" web page; specifically this came from "),t("em",[e._v("www.redhat.com/swt/src/netkit-routed-0.10.src.html")]),e._v(". Once downloaded, "),t("em",[e._v("root")]),e._v(" can install the package with the following commands (starting from the directory with the package):")]),e._v(" "),t("blockquote",[t("p",[e._v("rpm -i netkit-routed-0.10.src.rpm"),t("br"),e._v("\ncd /usr/src/redhat/SOURCES"),t("br"),e._v("\ntar xzf netkit-routed-0.10.tar.gz")])]),e._v(" "),t("p",[e._v("This creates a "),t("em",[e._v("/usr/src/redhat/SOURCES/netkit-routed-0.10")]),e._v(" directory and fills it with the source code for the "),t("em",[e._v("routed")]),e._v(" program. This process should be similar (but is undoubtably not exactly the same) for other Linux distributions.")]),e._v(" "),t("p",[e._v("ifinit() - SOURCES/routed/startup.c (88)\nopens a UDP socket\ncalls ioctl(SIOCFIGCONF) to get interface configuration\nloops through interfaces:\ncalls ioctl() to get flags, broadcast address, metric, and netmask\ncreates a new interface structure\ncopies info into interface structure\ncalls addrouteforif() to add routing entry for interface\nsets supplier variable if necessary\ncloses socket")]),e._v(" "),t("p",[e._v("process() - SOURCES/routed/main.c (298)\nstarts a continuous loop:\nreceives a packet (waits)\nverifies that packet is correct size\ncalls rip_input() to handle (RIP) packet")]),e._v(" "),t("p",[e._v("rip_input() - SOURCES/routed/input.c (60)\ntraces input if necessary\nchecks packet to make sure protocol and address are supported\nchecks for RIP version (cannot be 0)\nswitch based on packet content -\nif packet is a request:\nchecks request for validity\nif request is for all entries, calls supply()\nelse looks up requested address, builds and sends response packet\nif packet is a trace on or off:\nverifies request came from a valid port\nif all is in order, sets trace to on or off\nif packet is a response:\nverifies response came from a router\nupdates timer for interface\nloops through each entry in received packet:\nparses route information\nvalidates address family, host, and metric information\nupdates hop count (adds metric in message to hop count to router\nthat send message, subject to HOPCNT_INFINITY maximum)\ncalls rtlookup() to find address in routing table\nif this seems to be a new route:\ncalls rtfind() to look for an equivalent route\nif it really is new, calls rtadd() and returns\ncalls rtchange() to modify route if necessary (new route or\nhopcount change)\nupdates route timers\nif there were changes:\nsends an update if neccessary\nupdates general update timer information")]),e._v(" "),t("blockquote",[t("blockquote",[t("blockquote",[t("p",[e._v("routed main() - SOURCES/routed/main.c (78)\nopens routed log file\ncalls getservbyname() to get UDP router\nsets up a UDP socket for RIP message traffic\nruns through command line arguments to set flags\nif not debugging, forks and runs program in new session (parent dies)\ncalls rtinit() to initialize data tables\ncalls ifinit() to fill in interface information\ncalls toall() to request info from all other routers\ninstalls signal handlers for ALRM,HUP,TERM,INT,USR1,and USR2\nstarts a continuous loop:\nif in need of update, sets up timer variables\ncalls select() to wait for traffic\nif select() returns an error (other than EINTR), logs it\nif select() times out (time for update)\ncalls toall() to broadcast update\nresets timer variables\nif there is traffic waiting on the socket, calls process()")])])])]),e._v(" "),t("p",[e._v("rtadd() - SOURCES/routed/tables.c (138)\nverifies address family is in proper range\ncalls family af_rtflags() function to set routing flags\ndetermines hash value for appropriate table (host or net)\ncreates and fills in new rt_entry structure\ncalls insque() to add entry to table\ncalls rtioctl() to add entry to kernel table\nif call fails:\nif route should work, calls family af_format() to add destination\nand gateway to kernel tables\nif host is unreachable, removes and frees entry")]),e._v(" "),t("p",[e._v("rtchange() - SOURCES/routed/tables.c (207)\ndetermines if change necessitates adding or deleting gateways\ncalls rtioctl() to add and/or delete routes")]),e._v(" "),t("p",[e._v("rtfind() - SOURCES/routed/tables.c (100)\ndetermines hash value for host table\nloops through table; returns entry if addresses are equal\ndetermines hash value for net table\ngoes back to loop through table, this time returning entry if a call\nto family af_netmatch() function returns true\nreturns null (0) if no match")]),e._v(" "),t("p",[e._v("rtinit() - SOURCES/routed/tables.c (336)\nloops through the net hash table, setting forward and back pointers\nloops through the host hash table, setting forward and back pointers")]),e._v(" "),t("p",[e._v("rtioctl() - SOURCES/routed/tables.c (346)\nfills in rtentry structure from parameters\noutputs trace actions if necessary\ncalls ioctl(SIOCADDRT or SIOCDELRT) to update kernel table\nreturns result of ioctl() call (or -1 for erroneous parameter)")]),e._v(" "),t("p",[e._v("rtlookup() - SOURCES/routed/tables.c (65)\ndetermines hash value for address\nruns through host table looking for match\nif unsuccessful at first, tries again with net table\nreturns pointer to entry or null (0)")]),e._v(" "),t("p",[e._v("sndmsg() - SOURCES/routed/output.c (77)\ncalls the appropriate family output function\ntraces the packet if necessary")]),e._v(" "),t("p",[e._v("supply() - SOURCES/routed/ouput.c (91)\ncreates an RIP response message\nloops through the routing host table\nloops through the routing entries\nchecks to see if routing host needs the entry\nif so, puts routing info into packet and sends it\ngoes back and does it again with the routing net table")]),e._v(" "),t("p",[e._v("timer() - SOURCES/routed/timer.c (56)\nupdates timer variables\nloops through the host table\nupdates timer information for each entry\ndeletes entry if it is too old\nchanges metric to infinity if it is getting old\ngoes back and does it again with net table\ncalls toall() if update is due")]),e._v(" "),t("p",[e._v("toall() - SOURCES/routed/output.c (55)\nloops through interfaces:\nsets destination address to broadcast or specific address\ncalls passed function [sndmsg() or supply()] with address")]),e._v(" "),t("h1",{attrs:{id:"chapter-10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-10"}},[e._v("#")]),e._v(" Chapter 10")]),e._v(" "),t("p",[e._v("Editing Linux Source Code")]),e._v(" "),t("h2",{attrs:{id:"_10-1-the-linux-source-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-the-linux-source-tree"}},[e._v("#")]),e._v(" 10.1  The Linux Source Tree")]),e._v(" "),t("p",[e._v("Linux source code is usually in the /usr/src directory (if installed). There may be many versions in different directory trees (such as "),t("em",[e._v("linux-2.2.5")]),e._v(" or "),t("em",[e._v("linux-2.2.14")]),e._v("). There should be one soft link ("),t("em",[e._v("linux")]),e._v(") to the most current version of the code (i.e. "),t("em",[e._v("linux ® linux-2.2.14")]),e._v(").")]),e._v(" "),t("p",[e._v("This is an overview of the Linux source directory structure (not all branches are shown:")]),e._v(" "),t("p",[t("em",[e._v("/usr/src/linux/")])]),e._v(" "),t("ul",[t("li",[t("p",[t("em",[e._v("arch")]),e._v(" - architecture specific code, by processor")]),e._v(" "),t("ul",[t("li",[t("p",[t("em",[e._v("i386")]),e._v(" - code for Intel processors (including 486 and Pentium lines)")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("boot")]),e._v(" - location of newly compiled kernels")])])])])]),e._v(" "),t("li",[t("p",[t("em",[e._v("drivers")]),e._v(" - code for drivers of all sorts")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("block")]),e._v(" - block device drivers (e.g., hard drives)")]),e._v(" "),t("li",[t("em",[e._v("cdrom")]),e._v(" - CD ROM device drivers")]),e._v(" "),t("li",[t("em",[e._v("net")]),e._v(" - network device drivers")]),e._v(" "),t("li",[t("em",[e._v("pci")]),e._v(" - PCI bus drivers")])])]),e._v(" "),t("li",[t("p",[t("em",[e._v("fs")]),e._v(" - code for different file systems (EXT2, MS-DOS, etc.)")])]),e._v(" "),t("li",[t("p",[t("em",[e._v("include")]),e._v(" - header files used throughout the code")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("asm ® asm-i386")]),e._v(" - processor dependent headers")]),e._v(" "),t("li",[t("em",[e._v("config")]),e._v(" - general configuration headers")]),e._v(" "),t("li",[t("em",[e._v("linux")]),e._v(" - common headers")]),e._v(" "),t("li",[t("em",[e._v("net")]),e._v(" - networking headers")])])]),e._v(" "),t("li",[t("p",[t("em",[e._v("kernel")]),e._v(" - code for the kernel specific routines")])]),e._v(" "),t("li",[t("p",[t("em",[e._v("lib")]),e._v(" - code for errors, strings, and printf")])]),e._v(" "),t("li",[t("p",[t("em",[e._v("mm")]),e._v(" - code for memory management")])]),e._v(" "),t("li",[t("p",[t("em",[e._v("modules")]),e._v(" - object files and references for the kernel to load as required")])]),e._v(" "),t("li",[t("p",[t("em",[e._v("net")]),e._v(" - code for networking")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("core")]),e._v(" - protocol independent code")]),e._v(" "),t("li",[t("em",[e._v("ipv4")]),e._v(" - code specific to IPv4")]),e._v(" "),t("li",[t("em",[e._v("packet")]),e._v(" - protocol independent packet code")]),e._v(" "),t("li",[t("em",[e._v("sched")]),e._v(" - code for scheduling network actions")])])])]),e._v(" "),t("h2",{attrs:{id:"_10-2-using-emacs-tags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-using-emacs-tags"}},[e._v("#")]),e._v(" 10.2  Using EMACS Tags")]),e._v(" "),t("p",[e._v("The Linux source is obviously very large and spread throughout many files. A "),t("em",[e._v("TAGS")]),e._v(" file allows you to quickly maneuver to a specific file in search of a reference.")]),e._v(" "),t("h3",{attrs:{id:"_10-2-1-referencing-with-tags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-1-referencing-with-tags"}},[e._v("#")]),e._v(" 10.2.1  Referencing with TAGS")]),e._v(" "),t("p",[e._v("Inside a file, move the cursor to a keyword you would like to look up (e.g., "),t("code",[e._v("sock''). Press")]),e._v("ESC'' "),t("code",[e._v(".'' - EMACS will prompt for the tag to find (defaulting to the word your cursor is on); hit")]),e._v("ENTER''. The first time you use it, you will have to specify which TAGS file to use (e.g., "),t("em",[e._v("/usr/src/TAGS")]),e._v("). Next EMACS will automatically open the appropriate file (e.g., "),t("em",[e._v("/usr/src/linux/include/linux/sock.h")]),e._v(") in a new buffer and put the cursor on the definition of that struct, #define, or function. If the definition it brings up is not the one you were looking for, press "),t("code",[e._v("CTRL-U''")]),e._v("ESC'' ``.'' to bring up alternate references.")]),e._v(" "),t("p",[e._v("These tags work even as you make changes to the source files, though they will run slower as more and more changes are made. EMACS stores the tags in a file (defaulted to "),t("em",[e._v("TAGS")]),e._v(") with each reference, filename, and line number. If the tag is not at the stored line number, EMACS will search the file to find the new location.")]),e._v(" "),t("h3",{attrs:{id:"_10-2-2-constructing-tags-files"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-2-constructing-tags-files"}},[e._v("#")]),e._v(" 10.2.2  Constructing TAGS files")]),e._v(" "),t("p",[e._v("If you need to start from scratch, follow the steps below.")]),e._v(" "),t("p",[e._v("The command to make a tags file is:")]),e._v(" "),t("blockquote",[t("p",[e._v("etags "),t("em",[e._v("filename")])])]),e._v(" "),t("p",[e._v("The command to append new information onto a tags file is:")]),e._v(" "),t("blockquote",[t("p",[e._v("etags -a "),t("em",[e._v("filename")])])]),e._v(" "),t("p",[e._v("These put the new tags into the file "),t("em",[e._v("TAGS")]),e._v(" in the current directory. Filenames are stored as given, so absolute references will always refer to the same files while relative references depend on the position of the "),t("em",[e._v("TAGS")]),e._v(" file. (Read the man page for "),t("em",[e._v("etags")]),e._v(" for more information).")]),e._v(" "),t("p",[e._v("For example, to create a tags file for the "),t("em",[e._v("ipv4")]),e._v(" source files, enter:")]),e._v(" "),t("blockquote",[t("p",[e._v("etags /usr/src/linux/net/ipv4/*.c")])]),e._v(" "),t("p",[e._v("To add the header files, enter:")]),e._v(" "),t("blockquote",[t("p",[e._v("etags -a /usr/src/include/net/*.h")])]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("TAGS")]),e._v(" file will now contain quick references to all the C source code and header information in those directories.")]),e._v(" "),t("h2",{attrs:{id:"_10-3-using-vi-tags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-using-vi-tags"}},[e._v("#")]),e._v(" 10.3  Using vi tags")]),e._v(" "),t("p",[e._v("The vi editor also supports the use of tags files (and creates them with the "),t("em",[e._v("gctags")]),e._v(" command, which works almost exactly like the "),t("em",[e._v("etags")]),e._v(" command shown above).")]),e._v(" "),t("h2",{attrs:{id:"_10-4-rebuilding-the-kernel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-rebuilding-the-kernel"}},[e._v("#")]),e._v(" 10.4  Rebuilding the Kernel")]),e._v(" "),t("p",[e._v("(See the Linux-kernel-HOWTO for more detailed instructions.)")]),e._v(" "),t("p",[e._v("This is a quick step-by-step guide to recompiling and installing a kernel from scratch.")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Go to the top of the source directory ("),t("em",[e._v("/usr/src/linux")]),e._v("). If there is not already a historical copy of a working "),t("em",[e._v(".config")]),e._v(" file (such as the current one), MAKE ONE. Until you have enough experience that you no longer need this guide, do not overwrite anything until you have made sure there is a copy to which you can revert. (On the other hand, once you have a stable kernel version, there is no reason to keep old ones around. Even a development system should probably only have an original working version, a last known stable version, and a current version.")])]),e._v(" "),t("li",[t("p",[e._v("Run make xconfig (make config and make menuconfig also work, but xconfig is by far the user-friendliest). Configure the system as desired; there is help available for most options. The config file should default to the current settings, so you should only have to change the things you want to add or take out. As a general rule, select "),t("code",[e._v("Y'' for essential or frequently used features (like the ext2 file system),")]),e._v("M'' for things that are sometimes useful (like sound drivers), and ``N'' for things that do not apply (like amateur radio support). If in doubt, consult the help text or include something as a module.")])]),e._v(" "),t("li",[t("p",[e._v("Run make dep to make sure the options you heve selected will compile properly. This make take a few minutes as the computer checks all of the dependencies. If all goes well, the make program will simply exit; if there is a problem, it will display error messages and stop.")])]),e._v(" "),t("li",[t("p",[e._v("Run make clean to remove old object files IF you want to recompile everything. This obviously will make the compilation process take longer.")])]),e._v(" "),t("li",[t("p",[e._v("Run make bzImage to build the new kernel. (make zImage and make boot also build kernel images, but the bzImage will compile into the most compact file. If you are using one of these two methods for some reason, you may get a ``kernel too big'' error when you run "),t("em",[e._v("lilo")]),e._v(" - try again with a bzImage.) This will take quite some time, depending on available memory.")])]),e._v(" "),t("li",[t("p",[e._v("Run make modules to build any modules (not included in the main kernel image).")])]),e._v(" "),t("li",[t("p",[e._v("Rename the old modules if necessary:")]),e._v(" "),t("blockquote",[t("p",[e._v("mv /lib/modules/2.2.xx /lib/modules/2.2.xx-old")])]),e._v(" "),t("p",[e._v("(Note that you will not have to do this if you are compiling a completely new version; the old ones will still be in "),t("em",[e._v("/lib/modules/2.2.xx")]),e._v(" when you build version 2.2."),t("em",[e._v("yy")]),e._v(".)")])]),e._v(" "),t("li",[t("p",[e._v("Run make modules_install to install the new modules. You must do this even if you built a monolithic kernel (one with no modules). (Note that there may be a Red Hat "),t("em",[e._v("module-info")]),e._v(" text file or link in the boot directory; it is not terribly important and this does not update it.)")])]),e._v(" "),t("li",[t("p",[e._v("Copy the new kernel to the "),t("em",[e._v("/boot")]),e._v(" directory and change the kernel link (usually "),t("em",[e._v("vmlinuz")]),e._v("):")]),e._v(" "),t("blockquote",[t("p",[e._v("cp arch/i386/boot/bzImage /boot/vmlinuz-2.2.xx"),t("br"),e._v("\nln -sf /boot/vmlinuz-2.2.xx /boot/vmlinuz")])])]),e._v(" "),t("li",[t("p",[e._v("Copy the new "),t("em",[e._v("System.map")]),e._v(" file to the "),t("em",[e._v("/boot")]),e._v(" directory and change the map link:")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("> cp System.map /boot/System.map-2.2.xx  \n> ln -sf /boot/System.map-2.2.xx /boot/System.map\n")])])]),t("ol",{attrs:{start:"11"}},[t("li",[e._v("Create a new "),t("em",[e._v("initrd")]),e._v(" file if there are any SCSI devices on the computer:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("> /sbin/mkinitrd /boot/initrd-2.2.xx.img 2.2.xx\n")])])]),t("ol",{attrs:{start:"12"}},[t("li",[t("p",[e._v("Edit the file "),t("em",[e._v("/etc/lilo.conf")]),e._v(" to install the new kernel; copy the block for the old kernel (image=vmlinuz) and change the existing one to keep it as an option. For example, rename the image to vmlinuz-2.2.xx-old and change the label to stable. This way you can always reboot to the current (presumably stable) kernel if your changes cause problems.")])]),e._v(" "),t("li",[t("p",[e._v("Run /sbin/lilo to install the new kernel as a boot option.")])]),e._v(" "),t("li",[t("p",[e._v("Reboot the computer with the new kernel.")])]),e._v(" "),t("li",[t("p",[e._v("If the new kernel does not work properly, boot the old kernel and reconfigure the system before trying again.")])])]),e._v(" "),t("h2",{attrs:{id:"_10-5-patching-the-kernel-source"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-5-patching-the-kernel-source"}},[e._v("#")]),e._v(" 10.5  Patching the Kernel Source")]),e._v(" "),t("p",[e._v("Linux is a constantly changing operating system; updates can be released every few months. There are two ways to install a new kernel version: downloading the new source in its entirety or downloading patches and applying them.")]),e._v(" "),t("p",[e._v("Downloading the entire source may be preferable to guarantee everything works properly. To do so, download the latest kernel source and install ("),t("em",[e._v("untar")]),e._v(") it. Note that this will (probably) be a complete distribution, not a machine-specific one, and will contain a lot of extra code. Much of this can be deleted, but the configuration Makefiles rely on some for information. If space is an issue, delete the "),t("em",[e._v("*.c")]),e._v(" and "),t("em",[e._v("*.h")]),e._v(" files in the non-i386 "),t("em",[e._v("arch/")]),e._v(" and "),t("em",[e._v("include/asm-*")]),e._v(" directories, but tread lightly.")]),e._v(" "),t("p",[e._v("Downloading patches may be quicker to do, but is somewhat harder. Because of distribution variations, changes you have made, or other modifications the patches may not quite work properly. You must apply patch files in order (to go from 2.2.12 to 2.2.14, first apply patch 2.2.13 then apply 2.2.14). Nevertheless, patches may be preferable because they work on an existing directory tree.")]),e._v(" "),t("p",[e._v("Once you have downloaded a patch (and unzipped it, if necessary), simply put it in the directory above "),t("em",[e._v("linux")]),e._v(" (e.g., "),t("em",[e._v("/usr/src/")]),e._v(") and run the patch program to install it:")]),e._v(" "),t("blockquote",[t("p",[e._v("patch -Np0 -verbose -r rejfile < patch-2.2.xx "),t("em",[e._v("(where xx is the patch version)")])])]),e._v(" "),t("p",[e._v("The -N option ignores patches that are already applied, and the -p0 assumes the patch wants to apply itself to a source in a "),t("em",[e._v("linux")]),e._v(" directory. The -r rejfile option puts all the patch rejects into one file ("),t("em",[e._v("rejfile")]),e._v(") - which may or may not be what you want to do. If you have not kept the entire source distribution, you will have to skip many changes (for different processor architectures) by simply hitting "),t("code",[e._v("ENTER'' at the")]),e._v("patch which file'' and ``ignore patch'' prompts. Once you are comfortable with the process, run it without the -verbose and -r rejfile options.")]),e._v(" "),t("p",[e._v("Once you have a new kernel version, follow the instructions on rebuilding the kernel to actually start using it. You probably will not have to change any of the configurations options, but you will almost definitely want to run make clean to remove any old object files.")]),e._v(" "),t("h1",{attrs:{id:"chapter-11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-11"}},[e._v("#")]),e._v(" Chapter 11")]),e._v(" "),t("p",[e._v("Linux Modules")]),e._v(" "),t("p",[e._v("This chapter presents the Linux module system. It provides an overview of how modules work, describes how to install and remove them, and presents an example program.")]),e._v(" "),t("h2",{attrs:{id:"_11-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-overview"}},[e._v("#")]),e._v(" 11.1  Overview")]),e._v(" "),t("p",[e._v("Linux kernels more recent than 2.0 can be (and usually) are modularized. There is a portion of the kernel that remains in memory constantly (the most frequently used processes, such as the scheduler) but other processes are only loaded when needed. An MS-DOS file system for reading disks, for example, might be loaded only on mounting such a disk and then unloaded when no longer needed. This keeps the space the kernel requires at any one time small while allowing it to do more and more. It is still possible to put everything into one ``monolithic'' kernel that will not need modules, but that is usually done only for special purpose machines (where all the required processes are known in advance).")]),e._v(" "),t("p",[e._v("Another advantage of modules is that the kernel can load and unload them dynamically (and automatically with the "),t("em",[e._v("kerneld")]),e._v(" daemon). This means that a (super) user can load a module, test it, unload it, and debug it repeatedly without having to reboot the computer. This document assumes that the user has superuser access (you must be root to install and remove modules) and the kernel is configured for modules. (With a monolithic kernel, it is possible to set configuration options not to even allow modules.)")]),e._v(" "),t("h2",{attrs:{id:"_11-2-writing-installing-and-removing-modules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-writing-installing-and-removing-modules"}},[e._v("#")]),e._v(" 11.2  Writing, Installing, and Removing Modules")]),e._v(" "),t("h3",{attrs:{id:"_11-2-1-writing-modules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-1-writing-modules"}},[e._v("#")]),e._v(" 11.2.1  Writing Modules")]),e._v(" "),t("p",[e._v("Modules are just like any other programs except that they run in kernel space. As such, they must define MODULE and include "),t("em",[e._v("module.h")]),e._v(" and any other kernel header files that define functions or variables they use. Modules can be quite simple (as the example shows) but they can also be quite complex, such as device drivers and entire file systems.")]),e._v(" "),t("p",[e._v("This is the general module format:")]),e._v(" "),t("p",[e._v("#define MODULE\n#include <linux/module.h>\n/* ... other required header files ...  */")]),e._v(" "),t("p",[e._v("/*")]),e._v(" "),t("ul",[t("li",[e._v("... module declarations and functions ...\n*/")])]),e._v(" "),t("p",[e._v("int init_module() {\n/* code kernel will call when installing module */\n}")]),e._v(" "),t("p",[e._v("void cleanup_module() {\n/* code kernel will call when removing module */\n}")]),e._v(" "),t("p",[e._v("Modules that use the kernel source must be compiled with "),t("em",[e._v("gcc")]),e._v(" with the option -I/usr/src/linux/include; this ensures that the files included will be from the proper source tree.")]),e._v(" "),t("p",[e._v("Note that not all kernel variables are exported for modules to use, even if the code declares them to be extern. The "),t("em",[e._v("/proc/ksyms")]),e._v(" file or "),t("em",[e._v("ksyms")]),e._v(" program display the exported symbols (not many of which are useful for networking). Recent Linux kernels export both the symbol and its version number using the EXPORT_SYMBOL(x) macro. For user created variables, use the EXPORT_SYMBOL_NOVERS(x) macro instead or the linker will not retain the variable in the kernel symbol table. Module writers may also want to use the EXPORT_NO_SYMBOLS macro; modules export all of their variables by default.")]),e._v(" "),t("h3",{attrs:{id:"_11-2-2-installing-and-removing-modules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-2-installing-and-removing-modules"}},[e._v("#")]),e._v(" 11.2.2  Installing and Removing Modules")]),e._v(" "),t("p",[e._v("Installing and removing modules is as simple as calling a program with the name of the compiled module. (You must be a superuser to install or remove a module.)")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("insmod")]),e._v(" program installs a module; it first links the module with the kernel's exported symbol table to resolve references and then installs the code in kernel space.")]),e._v(" "),t("blockquote",[t("p",[e._v("/sbin/insmod "),t("em",[e._v("module_name")])])]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("rmmod")]),e._v(" program removes an installed module and any references that it has exported.")]),e._v(" "),t("blockquote",[t("p",[e._v("/sbin/rmmod "),t("em",[e._v("module_name")])])]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("lsmod")]),e._v(" program lists all the currently installed modules:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/sbin/lsmod\nModule       Size  Used by\ncdrom       13368   0 (autoclean) [ide-cd]\n3c59x       19112   1 (autoclean)\n")])])]),t("h2",{attrs:{id:"_11-3-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-3-example"}},[e._v("#")]),e._v(" 11.3  Example")]),e._v(" "),t("p",[e._v("This is a complete example of a very simple module.")]),e._v(" "),t("p",[t("em",[e._v("simple_module.c")])]),e._v(" "),t("p",[e._v("/* simple_module.c\n*")]),e._v(" "),t("ul",[t("li",[e._v("This program provides an example of how to install a trivial module")]),e._v(" "),t("li",[e._v("into the Linux kernel.  All the module does is put a message into")]),e._v(" "),t("li",[e._v("the log file when it is installed and removed.")]),e._v(" "),t("li")]),e._v(" "),t("p",[e._v("*/")]),e._v(" "),t("p",[e._v("#define MODULE\n#include <linux/module.h>\n/* kernel.h contains the printk function */\n#include <linux/kernel.h>")]),e._v(" "),t("p",[e._v("/*************************************************************** init_module")]),e._v(" "),t("ul",[t("li",[e._v("the kernel calls this function when it loads the module "),t("em",[e._v('/\nint init_module() {\nprintk("<1>The simple module installed itself properly.\\n");\nreturn 0;\n}  /')]),e._v(" init_module */")])]),e._v(" "),t("p",[e._v("/************************************************************ cleanup_module")]),e._v(" "),t("ul",[t("li",[e._v("the kernel calls this function when it removes the module "),t("em",[e._v('/\nvoid cleanup_module() {\nprintk("<1>The simple module is now uninstalled.\\n");\n}  /')]),e._v(" cleanup_module */")])]),e._v(" "),t("p",[e._v("This is the "),t("em",[e._v("Makefile")]),e._v(":")]),e._v(" "),t("h1",{attrs:{id:"makefile-for-simple-module"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#makefile-for-simple-module"}},[e._v("#")]),e._v(" Makefile for simple_module")]),e._v(" "),t("p",[e._v("CC = gcc -I/usr/src/linux/include/config")]),e._v(" "),t("p",[e._v("CFLAGS = -O2 -D__KERNEL__ -Wall")]),e._v(" "),t("p",[e._v("simple_module.o: simple_module.c")]),e._v(" "),t("p",[e._v("install:\n/sbin/insmod simple_module")]),e._v(" "),t("p",[e._v("remove:\n/sbin/rmmod simple_module")]),e._v(" "),t("p",[e._v("To use (must be root):")]),e._v(" "),t("p",[e._v("root# make\nroot# make install\nroot# make remove\nroot# tail /var/log/messages\n... kernel: The simple module installed itself properly.\n... kernel: The simple module is now uninstalled.")]),e._v(" "),t("h1",{attrs:{id:"chapter-12"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-12"}},[e._v("#")]),e._v(" Chapter 12")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("proc")]),e._v(" File System")]),e._v(" "),t("p",[e._v("This chapter presents the virtual "),t("em",[e._v("proc")]),e._v(" file system. It provides an overview of how the file system works, shows how the existing network code uses the system, and details how to write and use "),t("em",[e._v("proc")]),e._v(" entries from programs.")]),e._v(" "),t("h2",{attrs:{id:"_12-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-overview"}},[e._v("#")]),e._v(" 12.1  Overview")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("proc")]),e._v(" file system is so named because it is found in the "),t("em",[e._v("/proc")]),e._v(" directory on most Linux machines. NOT including the "),t("em",[e._v("proc")]),e._v(" FS is a configuration option, but the system is a powerful tool of which many programs make frequent use. While designed to appear as a file system with directory structures and inodes, it is in fact a construct of registered functions which provide information about important variables.")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("proc")]),e._v(" directory has many subdirectories - one for each running process and others for subsystems such as file systems, interfaces, terminals, and networking ("),t("em",[e._v("/proc/net")]),e._v("). There are also many files in the main "),t("em",[e._v("/proc")]),e._v(" directory itself - "),t("em",[e._v("interrupts")]),e._v(", "),t("em",[e._v("ioports")]),e._v(", "),t("em",[e._v("loadavg")]),e._v(", and "),t("em",[e._v("version")]),e._v(" to name a few. Within each process subdirectory (named for the process number) are files that describe the process' command line, current working directory, status, and so on.")]),e._v(" "),t("p",[e._v("The kernel traps "),t("em",[e._v("proc")]),e._v(" file access and instead of executing "),t("code",[e._v("normal'' file operations on them calls special (individually registered) functions instead. When a file in the _/proc_ directory is")]),e._v("created'', it is registered with a set of functions that tell the kernel what to do when the file is read from or written to. Most entries only allow reads and they simply print out the state of certain system variables for use by other programs or for perusal by knowledgeable users.")]),e._v(" "),t("p",[e._v("The only tricky thing about using "),t("em",[e._v("proc")]),e._v(" files is that the kernel calls the information generation function each and every time the file is read; subsequent reads of a changing file without copying and buffering the results may yield very different results. The best way to use a "),t("em",[e._v("proc")]),e._v(" file is to read it into a PAGE_SIZE-byte buffer. This will read the entire entry at once and the buffer will then allow consistent random accesses.")]),e._v(" "),t("h2",{attrs:{id:"_12-2-network-proc-files"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-network-proc-files"}},[e._v("#")]),e._v(" 12.2  Network "),t("em",[e._v("proc")]),e._v(" Files")]),e._v(" "),t("p",[e._v("This is a list of the most important files in the "),t("em",[e._v("/proc/net/")]),e._v(" directory, what they contain, and a reference to the function and file that creates them. Note that there are many other interesting "),t("em",[e._v("proc")]),e._v(" entries, such as the "),t("em",[e._v("/proc/sys")]),e._v(" files, "),t("em",[e._v("/proc/ksyms")]),e._v(", and "),t("em",[e._v("/proc/modules")]),e._v(" to name only a few.")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("arp")])])]),e._v(" "),t("p",[e._v("displays the neighbor table (arp_tbl); the IP and hardware addresses, hardware type, device, and flags. (arp_get_info() : "),t("em",[e._v("net/ipv4/arp.c")]),e._v(" 988)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("dev")])])]),e._v(" "),t("p",[e._v("displays reception and transmission statistics for each registered interface")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("dev_stat")])])]),e._v(" "),t("p",[e._v("displays number of received packets dropped and throttle and FASTROUTE statistics (dev_proc_stats() : "),t("em",[e._v("net/core/dev.c")]),e._v(" 1228)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("netstat")])])]),e._v(" "),t("p",[e._v("displays sync cookie, pruning, and ICMP statistics (netstat_get_info() : "),t("em",[e._v("net/ipv4/proc.c")]),e._v(" 355)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("raw")])])]),e._v(" "),t("p",[e._v("displays address, queue, and timeout information for each open RAW socket from struct proto raw_prot (get__netinfo() : "),t("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("route")])])]),e._v(" "),t("p",[e._v("displays the FIB table (main_table); the interface, address, gateway, flags, and usage information. (fib_get_procinfo()) : "),t("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(" 109)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("rt_cache")])])]),e._v(" "),t("p",[e._v("displays the routing cache (rt_hash_table); the interface, address, gateway, usage, source, and other information. (rt_cache_get_info() : "),t("em",[e._v("net/ipv4/route.c")]),e._v(" 191)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("sockstat")])])]),e._v(" "),t("p",[e._v("displays number of sockets that have been used and some statistics on how many were TCP, UDP, and RAW (afinet_get_info() : "),t("em",[e._v("net/ipv4/proc.c")]),e._v(" 244)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("tcp")])])]),e._v(" "),t("p",[e._v("displays address, queue, and timeout information for each open TCP socket from struct proto tcp_prot (get__netinfo() : "),t("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),t("p",[t("strong",[t("em",[e._v("udp")])])]),e._v(" "),t("p",[e._v("displays address, queue, and timeout information for each open UDP socket from struct proto udp_prot (get__netinfo() : "),t("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),t("h2",{attrs:{id:"_12-3-registering-proc-files"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-registering-proc-files"}},[e._v("#")]),e._v(" 12.3  Registering "),t("em",[e._v("proc")]),e._v(" Files")]),e._v(" "),t("p",[e._v("This section describes the simplest method for registering a read-only "),t("em",[e._v("proc")]),e._v(" ``file'' entry (available only in Linux 2.0 and later releases). It is possible to create a more fully functional entry by defining file_operations and inode_operations structures. However, that method is significantly more complicated than the one presented here; look in the source code for details on implementing fully functional entry. The method described below - defining a function and then registering and unregistering the function - provides most of the functionality required for testing and tracking system resources. Only the kernel can register a "),t("em",[e._v("proc")]),e._v(" file; users can do so by building and installing kernel modules (though only root can install and remove modules). These procedures assume that the Linux source is installed and the kernel is compiled to use modules.")]),e._v(" "),t("h3",{attrs:{id:"_12-3-1-formatting-a-function-to-provide-information"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-1-formatting-a-function-to-provide-information"}},[e._v("#")]),e._v(" 12.3.1  Formatting a Function to Provide Information")]),e._v(" "),t("p",[e._v("static int "),t("em",[e._v("read_proc_function")]),e._v("(char *buf,char **start,off_t offset,int len,int unused)")]),e._v(" "),t("p",[e._v("This is the function that the Linux kernel will call whenever it tries to read from the newly created "),t("em",[e._v("proc")]),e._v(" ``file''. The only parameter that is usually significant is buf - a pointer to the buffer the kernel makes available for storing information. The others normally will not change. ("),t("em",[e._v("read_proc_function")]),e._v(" is of course the name of the new function.)")]),e._v(" "),t("p",[e._v("Typically this function prints out a header, iterates through a list or table printing its contents (using the normal sprintf routine), and returns the length of the resulting string. The only limitation is that the buffer (buf) is at most PAGE_SIZE bytes (this is at least 4KB).")]),e._v(" "),t("p",[e._v("For an example of this kind of function, look at the fib_get_procinfo() function beginning on line 109 of "),t("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(". This function displays the contents of the main FIB table.")]),e._v(" "),t("h3",{attrs:{id:"_12-3-2-building-a-proc-entry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-2-building-a-proc-entry"}},[e._v("#")]),e._v(" 12.3.2  Building a "),t("em",[e._v("proc")]),e._v(" Entry")]),e._v(" "),t("p",[e._v("Because this is part of the file system, the entry needs an inode. This is easily constructed using a struct proc_dir_entry:")]),e._v(" "),t("p",[e._v('#include <linux/proc_fs.h>\nstruct proc_dir_entry new_proc_entry = {\n0,                     // low_ino - inode number (0 for dynamic)\n5,                     // namelen  - length of entry name\n"entry",               // name\nS_IFREG | S_IRUGO,     // mode\n1,                     // nlinks\n0,                     // uid - owner\n0,                     // gid - group\n0,                     // size - not used\nNULL,                  // ops - inode operations (use default)\n&read_proc_function    // read_proc - address of read function\n// leave rest blank!\n}')]),e._v(" "),t("p",[e._v("The contents of this block can be used as shown by simply replacing the namelen, name, and read_proc_function fields with the desired values. Note that many of the kernel defined entries have predefined inode numbers (like PROC_NET_ROUTE, part of an enumeration defined in "),t("em",[e._v("include/linux/proc_fs.h")]),e._v(".")]),e._v(" "),t("p",[e._v("For an example of this kind of entry, look at the __init_func() function beginning on line 607 of "),t("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(". This functions calls proc_net_register() (described below) with a newly created proc_dir_entry structure.")]),e._v(" "),t("h3",{attrs:{id:"_12-3-3-registering-a-proc-entry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-3-registering-a-proc-entry"}},[e._v("#")]),e._v(" 12.3.3  Registering a "),t("em",[e._v("proc")]),e._v(" Entry")]),e._v(" "),t("p",[e._v("Once the read function and the inode entry are ready, all that remains is to register the new ``file'' with the "),t("em",[e._v("proc")]),e._v(" system.")]),e._v(" "),t("p",[e._v("int proc_register(struct proc_dir_entry *dir, struct proc_dir_entry *entry)"),t("br"),e._v("\nint proc_net_register(struct proc_dir_entry *entry)")]),e._v(" "),t("p",[e._v("dir is a pointer to the directory in which the entry belongs - &proc_root and proc_net (defined in "),t("em",[e._v("include/proc_fs.h")]),e._v(") are probably the most useful. entry is a pointer to the entry itself, as created above. These two functions are identical except that proc_net_register automatically uses the "),t("em",[e._v("/proc/net")]),e._v(" directory. They return either 0 (success) or EAGAIN (if there are no available inodes).")]),e._v(" "),t("h3",{attrs:{id:"_12-3-4-unregistering-a-proc-entry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-4-unregistering-a-proc-entry"}},[e._v("#")]),e._v(" 12.3.4  Unregistering a "),t("em",[e._v("proc")]),e._v(" Entry")]),e._v(" "),t("p",[e._v("When an entry is no longer needed, it should be deleted by unregistering it.")]),e._v(" "),t("p",[e._v("int proc_unregister(struct proc_dir_entry *dir,int inode)"),t("br"),e._v("\nint proc_net_unregister(int inode)")]),e._v(" "),t("p",[e._v("dir is the "),t("em",[e._v("proc")]),e._v(" directory in which the file resides, and inode is the inode number of the file. (The inode is available in the entry's struct proc_dir_entry.low_ino field if it is not a constant.) Again, these functions are identical except that proc_net_unregister automatically uses the "),t("em",[e._v("/proc/net")]),e._v(" directory. They return either 0 (success) or EINVAL (if there is no such entry).")]),e._v(" "),t("h2",{attrs:{id:"_12-4-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-example"}},[e._v("#")]),e._v(" 12.4  Example")]),e._v(" "),t("p",[e._v("This is a complete example of a module that installs a simple "),t("em",[e._v("proc")]),e._v(" entry.")]),e._v(" "),t("p",[t("em",[e._v("simple_entry.c")])]),e._v(" "),t("p",[e._v("/* simple_entry.c\n*")]),e._v(" "),t("ul",[t("li",[e._v("This program provides an example of how to install an entry into the")]),e._v(" "),t("li",[e._v("/proc File System.  All this entry does is display some statistical")]),e._v(" "),t("li",[e._v("information about IP.\n*/")])]),e._v(" "),t("p",[e._v("#define MODULE\n#include <linux/module.h>\n/* proc_fs.h contains proc_dir_entry and register/unregister prototypes "),t("em",[e._v("/\n#include <linux/proc_fs.h>\n/")]),e._v(" ip.h contains the ip_statistics variable */\n#include <net/ip.h>")]),e._v(" "),t("p",[e._v("/************************************************************ show_ip_stats")]),e._v(" "),t("ul",[t("li",[e._v("this function is what the /proc FS will call when anything tries to read")]),e._v(" "),t("li",[e._v("from the file /proc/simple_entry - it puts some of the kernel global")]),e._v(" "),t("li",[e._v("variable ip_statistics's contents into the return buffer */\nint show_ip_stats(char *buf,char *"),t("em",[e._v('start,off_t offset,int len,int unused) {\nlen = sprintf(buf,"Some IP Statistics:\\nIP Forwarding is ");\nif (ip_statistics.IpForwarding)\nlen += sprintf(buf+len,"on\\n");\nelse\nlen += sprintf(buf+len,"off\\n");\nlen += sprintf(buf+len,"Default TTL:  %lu\\n",ip_statistics.IpDefaultTTL);\nlen += sprintf(buf+len,"Frag Creates: %lu\\n",ip_statistics.IpFragCreates);\n/')]),e._v(" this could show more.... "),t("em",[e._v("/\nreturn len;\n}  /")]),e._v(" show_ip_stats */")])]),e._v(" "),t("p",[e._v("/**************************************************************** test_entry")]),e._v(" "),t("ul",[t("li",[e._v("this structure is a sort of registration form for the /proc FS; it tells")]),e._v(" "),t("li",[e._v('the FS to allocate a dynamic inode, gives the "file" a name, and gives')]),e._v(" "),t("li",[e._v("the address of a function to call when the file is read  "),t("em",[e._v("/\nstruct proc_dir_entry test_entry = {\n0,                     /")]),e._v(" low_ino - inode number (0 for dynamic)  "),t("em",[e._v("/\n12,                    /")]),e._v(" namelen - length of entry name          "),t("em",[e._v('/\n"simple_entry",        /')]),e._v(" name                                    "),t("em",[e._v("/\nS_IFREG | S_IRUGO,     /")]),e._v(" mode                                    "),t("em",[e._v("/\n1,                     /")]),e._v(" nlinks                                  "),t("em",[e._v("/\n0,                     /")]),e._v(" uid - owner                             "),t("em",[e._v("/\n0,                     /")]),e._v(" gid - group                             "),t("em",[e._v("/\n0,                     /")]),e._v(" size - not used                         "),t("em",[e._v("/\nNULL,                  /")]),e._v(" ops - inode operations (use default)    "),t("em",[e._v("/\n&show_ip_stats         /")]),e._v(" read_proc - address of read function    "),t("em",[e._v("/\n/")]),e._v(" leave rest blank!                       */\n};")])]),e._v(" "),t("p",[e._v("/*************************************************************** init_module")]),e._v(" "),t("ul",[t("li",[e._v("this function installs the module; it simply registers a directory entry")]),e._v(" "),t("li",[e._v("with the /proc FS  "),t("em",[e._v("/\nint init_module() {\n/")]),e._v(" register the function with the proc FS "),t("em",[e._v("/\nint err = proc_register(&proc_root,&test_entry);\n/")]),e._v(" put the registration results in the log "),t("em",[e._v('/\nif (!err)\nprintk("<1> simple_entry: registered with inode %d.\\n",\ntest_entry.low_ino);\nelse\nprintk("<1> simple_entry: registration error, code %d.\\n",err);\nreturn err;\n}  /')]),e._v(" init_module */")])]),e._v(" "),t("p",[e._v("/************************************************************ cleanup_module")]),e._v(" "),t("ul",[t("li",[e._v("this function removes the module; it simply unregisters the directory")]),e._v(" "),t("li",[e._v("entry from the /proc FS  "),t("em",[e._v("/\nvoid cleanup_module() {\n/")]),e._v(" unregister the function from the proc FS "),t("em",[e._v("/\nint err = proc_unregister(&proc_root,test_entry.low_ino);\n/")]),e._v(" put the unregistration results in the log "),t("em",[e._v('/\nif (!err)\nprintk("<1> simple_entry: unregistered inode %d.\\n",\ntest_entry.low_ino);\nelse\nprintk("<1> simple_entry: unregistration error, code %d.\\n",err);\n}  /')]),e._v(" cleanup_module */")])]),e._v(" "),t("p",[e._v("This is the "),t("em",[e._v("Makefile")]),e._v(":")]),e._v(" "),t("h1",{attrs:{id:"makefile-for-simple-entry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#makefile-for-simple-entry"}},[e._v("#")]),e._v(" Makefile for simple_entry")]),e._v(" "),t("p",[e._v("CC = gcc -I/usr/src/linux/include")]),e._v(" "),t("p",[e._v("CFLAGS = -O2 -D__KERNEL__ -Wall")]),e._v(" "),t("p",[e._v("simple_entry.o: simple_entry.c")]),e._v(" "),t("p",[e._v("install:\n/sbin/insmod simple_entry")]),e._v(" "),t("p",[e._v("remove:\n/sbin/rmmod simple_entry")]),e._v(" "),t("p",[e._v("To use (must be root):")]),e._v(" "),t("p",[e._v("root# make\nroot# make install\nroot# cat /proc/simple_entry\nSome IP Statistics:\nIP Forwarding is on\nDefault TTL:  64\nFrag Creates: 0\nroot# make remove\nroot# tail /var/log/messages\n... kernel: simple_entry: registered with inode 4365.\n... kernel: simple_entry: unregistered inode 4365.")]),e._v(" "),t("h1",{attrs:{id:"chapter-13"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-13"}},[e._v("#")]),e._v(" Chapter 13")]),e._v(" "),t("p",[e._v("Example - Packet Dropper")]),e._v(" "),t("p",[e._v("This sample experiment inserts a routine into the kernel that selectively drops packets to a given host. It discusses the placement of the code, outlines the data from an actual trial, presents a lightweight analysis of the results, and includes the code itself.")]),e._v(" "),t("h2",{attrs:{id:"_13-1-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-overview"}},[e._v("#")]),e._v(" 13.1  Overview")]),e._v(" "),t("p",[e._v("This program is implemented as a module that, while installed, compares each outgoing packet's destination address to a given target. If they match, it randomly drops a percentage of those packets. It does this for all IP traffic, no matter where it was generated and what transport protocol it uses. Implementing this requires a modification to the kernel (to allow a module access to the transmission functions) and a module that takes advantage of that modification.")]),e._v(" "),t("h2",{attrs:{id:"_13-2-considerations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-considerations"}},[e._v("#")]),e._v(" 13.2  Considerations")]),e._v(" "),t("p",[t("strong",[e._v("Code Placement")])]),e._v(" "),t("p",[e._v("This code could be built directly into the kernel or it could be designed as a module:")]),e._v(" "),t("ul",[t("li",[e._v("Kernel - this is conceptually much simpler; simply adding some code to the kernel is a fairly easy matter. However, it makes semi-permanent changes and takes a long time to debug, since the entire kernel must be recompiled, installed, and rebooted for every change.")]),e._v(" "),t("li",[e._v("Module - this is much safer and easier since the (super) user can install, remove, and debug modules quite painlessly. However, it requires access to the kernel that is not always available - even from a module. The kernel does not always export the variables that a module may need to access. (See the discussion on the "),t("em",[e._v("ksyms")]),e._v(" program in Chapter "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#module",target:"_blank",rel:"noopener noreferrer"}},[e._v("11"),t("OutboundLink")],1),e._v(".)")]),e._v(" "),t("li",[e._v("Both - this is the best method; by performing a few minor modifications to the kernel code to export necessary variables and make use of a module only if it is loaded, a user can recompile the kernel once and then perform tests and experiments with modules. This still has the disadvantage of opening potential security holes on a system, but since only the experimenter knows how they are implemented, this is a minimal risk.")])]),e._v(" "),t("p",[t("strong",[e._v("Protocol Level")])]),e._v(" "),t("p",[e._v("This code could be implemented at many levels:")]),e._v(" "),t("ul",[t("li",[e._v("Device Driver - this is a possibility since all traffic comes through the device. However, this breaks the layering protocols and requires hacking a (presumably) stable hardware driver.")]),e._v(" "),t("li",[e._v("Generic Device Functions - this is the best choice, since this is the lowest level through which all traffic travels (specifically the dev_queue_xmit() and netif_rx() functions). It still violates the protocol layering, but all of the modifications can be made in one section of code.")]),e._v(" "),t("li",[e._v("IP Protocol - this is conceptually the right place to insert a special function, either in the input, routing, or output routines. However, this is unsuitable precisely because there are three different routines in the implementation that a packet might go through - ip_forward() (forwarded packets), ip_queue_xmit() (TCP packets), or ip_build_xmit() (UDP packets). See the coding sections in Chapters "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sending",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),t("OutboundLink")],1),e._v(" and "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#forward",target:"_blank",rel:"noopener noreferrer"}},[e._v("7"),t("OutboundLink")],1),e._v(" to see how these routines interact. These functions would be a good choice for inserting a special-purpose dropper, but not one that affects all traffic.")]),e._v(" "),t("li",[e._v("Transport Protocol - these routines would be appropriate for affecting specific traffic types (such as UDP only) but are not useful for this example.")])]),e._v(" "),t("h2",{attrs:{id:"_13-3-experimental-systems-and-benchmarks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-3-experimental-systems-and-benchmarks"}},[e._v("#")]),e._v(" 13.3  Experimental Systems and Benchmarks")]),e._v(" "),t("p",[e._v("This example was implemented on two computers that are connected through a single router as shown in Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_setup",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.1"),t("OutboundLink")],1),e._v("; the router runs the modifed kernel and packet dropper module. In the general example, this represents traffic flowing between neon and eagle, with dodge/viper dropping packets for eagle.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_setup.gif",alt:"x_setup.gif"}})]),e._v(" "),t("p",[e._v("Figure 13.1: Experimental system setup.")]),e._v(" "),t("p",[e._v("The switch is a Cisco Catalyst 2900 set up with Virtual LANs (VLANs) for each ``subnetwork'' (one for the source computer and one for the destination computer, with the routing computer acting as the router between the two. The switch operates entirely on the link level and is essentially invisible for routing purposes.")]),e._v(" "),t("p",[e._v("The routing computer (dodge/viper) is a Dell Optiplex GX1 with a Pentium II/350 processor and 128M of RAM. It has three 3Com 3c59x Ethernet cards with 10Mbps connections to the switch.")]),e._v(" "),t("p",[e._v("One host computer (neon) is an AST Premmia GX with a Pentium/100 processor and 32M of RAM. It has an AMD Lance Ethernet card with a 10Mbps connection to the switch.")]),e._v(" "),t("p",[e._v("The other host computer (eagle) is a Dell Optiplex XL590 with a Pentium/90 processor and 32M of RAM. It has a 3Com 3c509 Ethernet card with a 10Mbps connection to the switch.")]),e._v(" "),t("p",[e._v("All computers have the Red Hat 6.1 distribution of Linux; the source and destination computers have standard recompiled version 2.2.14 kernels, while the router uses either a standard (2.2.14) kernel or a slightly modified one as indicated.")]),e._v(" "),t("p",[e._v("The first benchmark is a ``ping-pong'' test that establishes a TCP connection and then repeatedly sends packets back and forth. It returns a total transmission time (from start to finish, not including making and closing the connection); dividing the time by the number of iterations yields an average Round Trip Time (RTT). This test was run with 20,000 iterations of 5 byte packets and 5,000 iterations of 500 byte packets.")]),e._v(" "),t("p",[e._v("The second benchmark is a ``blast'' test that establishes a TCP connection and then sends data from a source to a destination. It returns a total transmission time (from start to finish, not including making and closing the connection); multiplying the number of packets by the size of the packets and dividing by the time yields the throughput. This test was run with 50,000 5 byte packets, 5,000 500 byte packets, and 1,000 1500 byte packets.")]),e._v(" "),t("p",[e._v("The benchmarks were run on both machines (i.e., from neon to eagle and from eagle to neon), but in both cases only packets to eagle were dropped. In each trial the blast test was run once with default settings (100 packets of 1 byte each) before running the performance tests ``for record'' to ensure that the routing cache and any protocol tables were in a normalized state. The complete suite was run ten times to capture variations between trials (the averages are presented here). None of the machines (including the router) were running any other user programs beyond a login shell and the appropriate module, client, or server programs (not even X Windows).")]),e._v(" "),t("h2",{attrs:{id:"_13-4-results-and-preliminary-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-results-and-preliminary-analysis"}},[e._v("#")]),e._v(" 13.4  Results and Preliminary Analysis")]),e._v(" "),t("h3",{attrs:{id:"_13-4-1-standard-kernel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-1-standard-kernel"}},[e._v("#")]),e._v(" 13.4.1  Standard Kernel")]),e._v(" "),t("p",[e._v("These are the reference standards; these routines were run with the two computers directly connected (NOT routed) and while the router had an unmodified Linux 2.2.14 kernel. The error rate on such a direct connection is near zero.")]),e._v(" "),t("p",[t("em",[e._v("ping-pong")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("                       Mean Time (sec)     Average RTT (millisec)\n           Drop Rate   20K@5    5K@500         20K@5    5K@500\n")])])]),t("p",[e._v("Direct -\nneon to eagle:   ---      17.24     28.98          0.86     5.80\neagle to neon:   ---      17.20     28.99          0.86     5.80\nRouted -\nneon to eagle:  (0.0%)    24.53     48.59          1.23     9.72\neagle to neon:  (0.0%)    24.36     48.46          1.22     9.69")]),e._v(" "),t("p",[t("em",[e._v("blast")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("                           Mean Time (sec)       Throughput (Mbits/sec)\n           Drop Rate   50K*5  10K*500  1K*1500   50K*5  10K*500  1K*1500\n")])])]),t("p",[e._v("Direct -\nneon to eagle:   ---       0.56    3.19     1.89     3.55    6.26    6.36\neagle to neon:   ---       0.78    3.03     1.77     2.58    6.61    6.76\nRouted -\nneon to eagle:  (0.0%)     0.56    3.19     1.92     3.60    6.27    6.26\neagle to neon:  (0.0%)     0.77    3.19     1.93     2.60    6.27    6.23")]),e._v(" "),t("h3",{attrs:{id:"_13-4-2-modified-kernel-dropping-packets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-2-modified-kernel-dropping-packets"}},[e._v("#")]),e._v(" 13.4.2  Modified Kernel Dropping Packets")]),e._v(" "),t("p",[e._v("These are the experimental results. The drop rate of 0.0% provides a reference for measuring the overhead of calling the test and random functions without dropping any packets.")]),e._v(" "),t("p",[t("em",[e._v("ping-pong")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("                       Mean Time (sec)     Average RTT (millisec)\n           Drop Rate   20K@5    5K@500         20K@5    5K@500\n")])])]),t("p",[e._v("neon to eagle:    0.0%     25.55     49.12          1.28     9.82\n0.1%     29.87     51.11          1.49    10.22\n0.5%     44.78     58.07          2.24    11.61\n1.0%     65.37     68.77          3.27    13.75\n5.0%    245.51    160.09         12.28    32.02\n10.0%    506.03    290.77         25.30    58.15\neagle to neon:    0.0%     25.53     49.21          1.28     9.84\n0.1%     29.08     50.92          1.45    10.18\n0.5%     45.87     59.21          2.29    11.84\n1.0%     66.19     68.66          3.31    13.73\n5.0%    235.68    156.94         11.78    31.39\n10.0%    519.61    297.02         25.98    59.40")]),e._v(" "),t("p",[t("em",[e._v("blast")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("                           Mean Time (sec)       Throughput (Mbits/sec)\n           Drop Rate   50K*5  10K*500  1K*1500   50K*5  10K*500  1K*1500\n")])])]),t("p",[e._v("neon to eagle:    0.0%      0.55    3.19     1.91     3.64    6.26    6.27\n0.1%      0.55    3.07     1.93     3.62    6.51    6.21\n0.5%      0.55    2.95     1.76     3.64    6.77    6.82\n1.0%      0.55    2.87     1.75     3.65    6.96    6.87\n2.5%      0.59    3.36     2.04     3.38    5.59    5.90\n5.0%      0.63    4.63     2.71     3.19    4.31    4.43\n10.0%      1.06    7.08     5.11     1.89    2.83    2.35\n20.0%      3.43   30.35    18.55     0.58    0.66    0.65\neagle to neon:    0.0%      0.79    3.21     1.93     2.53    6.23    6.23\n0.1%      0.77    3.22     1.89     2.59    6.20    6.35\n0.5%      0.80    3.24     1.88     2.51    6.17    6.39\n1.0%      0.77    3.24     1.91     2.60    6.17    6.27\n2.5%      0.79    3.17     1.90     2.53    6.31    6.33\n5.0%      0.78    3.17     1.91     2.57    6.31    6.29\n10.0%      0.81    3.85     2.51     2.48    5.20    4.78\n20.0%      2.02    4.06     2.51     0.99    4.92    4.78")]),e._v(" "),t("h3",{attrs:{id:"_13-4-3-preliminary-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-3-preliminary-analysis"}},[e._v("#")]),e._v(" 13.4.3  Preliminary Analysis")]),e._v(" "),t("p",[e._v("What follows is an elementary examination of the results. It is NOT intended as an exhaustive analysis, and indeed the experiment was not extensive enough to provide hard data from which to draw definite conclusions. However, this does demonstrate the multitude of factors involved and the effects that a few lines of code can have on a network. Further analysis, if desired, is left as an exercise for the reader.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_pong.gif",alt:"x_pong.gif"}})]),e._v(" "),t("p",[e._v("Figure 13.2: Ping-pong benchmark results.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_blast.gif",alt:"x_blast.gif"}})]),e._v(" "),t("p",[e._v("Figure 13.3: Blast benchmark results.")]),e._v(" "),t("p",[e._v("The kernel modifications and module insertion had a small but measurable impact on a TCP connection (measured by the increased RTT). For very small packets, this difference was approximately 0.05 msec; for large packets it was 0.10 msec. Why should there be a difference? Note that the direction of travel and packet size made a large difference on the throughput. This is an indication that processor speed and layering overhead are affecting the RTT; for a 1500 byte packet, 66 bytes of wrappers (20 for TCP, 20 for IP, and at least 26 for Ethernet) are not very significant - but for a 5 byte packet, that overhead is very large. Assume that the actual ``cost'' of inserting the module the delay for the larger packets, 0.10 msec.")]),e._v(" "),t("p",[e._v("Dropping packets from a TCP connection resulted in a fairly linear drop in performance on the ping-pong test; see the graph in Figure "),t("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_pong",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.2"),t("OutboundLink")],1),e._v(". This is as expected; when either a packet or acknowledgement is lost, the sender pauses and then sends again. The RTT is also very close (certainly within the expected experimental error) no matter which machine is the ``source''; again this is because the benchmark tests the behavior of both machines at the same time.")]),e._v(" "),t("p",[e._v("At low packet sizes, the throughput was very different depending on which way data was sent. This is because one machine (eagle) was slower than the other. For a large number of very small packets, the chokepoint in the network is not the medium or the interface, but the speed at which the processor can build and send packets. However, for larger packet sizes, the throughput (for low error rate) for both sources is similar; in this case the network is the limiting factor, not the processor.")]),e._v(" "),t("p",[e._v("The most surprising result is the apparent peak in throughput when the loss rate is approximately 1% - better even than no loss at all (for blasted data; loss of ACKs sent from the receiver to the source had little impact). This is a very counter-intuitive finding; why should losing packets speed up the throughput? A 1% error might be just enough to prevent a TCP exponential back-off algorithm from slowing the traffic rate. The immediate ACK that the receiver sends when an out-of-sequence packet arrives might include window size information that keeps the sender from pausing. Interrupts caused by out-of-sequence packets might result in the scheduler running the benchmark process more frequently, emptying the buffer window and again keeping the sender from pausing. There are many potential causes; determining the real one would take much more study - but would be very interesting.")]),e._v(" "),t("h2",{attrs:{id:"_13-5-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-code"}},[e._v("#")]),e._v(" 13.5  Code")]),e._v(" "),t("h3",{attrs:{id:"_13-5-1-kernel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-1-kernel"}},[e._v("#")]),e._v(" 13.5.1  Kernel")]),e._v(" "),t("p",[e._v("The following code adds a trapdoor to the kernel. It creates a function that will be called (if it exists) from within the dev_queue_xmit() function and exports it so that modules will be able to use it. These lines are added directly to the source code; the kernel then has to be recompiled. installed, and booted. Note that the kernel still functions normally (albeit with one extra comparison) while no test module is installed.")]),e._v(" "),t("p",[t("em",[e._v("net/core/dev.c")]),e._v(" (after line 579)")]),e._v(" "),t("p",[e._v("...\nint *test_function(struct sk_buff "),t("em",[e._v(")=0;                  /")]),e._v(" new */")]),e._v(" "),t("p",[e._v("int dev_queue_xmit(struct sk_buff *skb)...")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...struct Qdisc  *q;\n\nif (test_function && (*test_function)(skb)) {        /* new */\n    kfree_skb(skb);                                  /* new */\n    return 0;                                        /* new */\n}                                                    /* new */\n")])])]),t("p",[e._v("#ifdef CONFIG_NET_PROFILE...")]),e._v(" "),t("p",[t("em",[e._v("net/netsyms.c")]),e._v(" (after line 544)")]),e._v(" "),t("p",[e._v("...\nextern int (*test_function)(struct sk_buff "),t("em",[e._v(");           /")]),e._v(" new "),t("em",[e._v("/\nEXPORT_SYMBOL_NOVERS(test_function);                     /")]),e._v(" new */\nEXPORT_SYMBOL(register_gifconf);...")]),e._v(" "),t("h3",{attrs:{id:"_13-5-2-module"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-2-module"}},[e._v("#")]),e._v(" 13.5.2  Module")]),e._v(" "),t("p",[e._v("The following is the code for the packet dropping module itself. On installation, it calculates a percentage cut-off and puts an address into the function pointer defined above. From then on, any packets sent through dev_queue_xmit() will also pass through the packet_dropper function, which compares the destination address to a hard coded one. If they match and a random number comes up below the calculated cut-off, it drops the packet; otherwise the packets pass through untouched. When the module is removed, it resets the function pointer to 0 (null) again. (Note that this not very robust code depends on two byte short integers for simplicity. The function get_random_bytes() is only accessible to the kernel - or modules, of course - and provides random numbers that are ``merely cryptographically strong''.)")]),e._v(" "),t("p",[t("em",[e._v("packet_dropper.c")])]),e._v(" "),t("p",[e._v("/* packet_dropper.c\n*")]),e._v(" "),t("ul",[t("li",[e._v("This program provides an example of how to install a module into a")]),e._v(" "),t("li",[e._v("slightly modified kernel that will randomly drop packets for a specific")]),e._v(" "),t("li",[e._v("(hard-coded) host.")]),e._v(" "),t("li"),e._v(" "),t("li",[e._v("See linux/drivers/char/random.c for details of get_random_bytes().")]),e._v(" "),t("li"),e._v(" "),t("li",[e._v("Usage (must be root to use):")]),e._v(" "),t("li",[e._v("/sbin/insmod packet_dropper")]),e._v(" "),t("li",[e._v("/sbin/rmmod packet_dropper\n*/")])]),e._v(" "),t("p",[e._v("#define MODULE\n#define MAX_UNSIGNED_SHORT 65535")]),e._v(" "),t("p",[e._v("#include <linux/module.h>\n#include <linux/skbuff.h>  /* for struct sk_buff "),t("em",[e._v("/\n#include <linux/ip.h>      /")]),e._v(" for struct iphdr */")]),e._v(" "),t("p",[e._v("extern int (*test_function)(struct sk_buff "),t("em",[e._v(");       /")]),e._v(" calling function */\nextern void get_random_bytes(void "),t("em",[e._v("buf, int nbytes); /")]),e._v(" random function "),t("em",[e._v("/\nunsigned short cutoff;                               /")]),e._v(" drop cutoff "),t("em",[e._v("/\nfloat rate   = 0.050;                                /")]),e._v(" drop percentage "),t("em",[e._v("/\n__u32 target = 0x220010AC;                           /")]),e._v(" 172.16.0.34 */")]),e._v(" "),t("p",[e._v("/************************************************************ packet_dropper")]),e._v(" "),t("ul",[t("li",[e._v("this is what dev_queue_xmit will call while this module is installed */\nint packet_dropper(struct sk_buff "),t("em",[e._v("skb) {\nunsigned short t;\nif (skb->nh.iph->daddr == target) {\nget_random_bytes(&t,2);\nif (t <= cutoff) return 1;    /")]),e._v(" drop this packet "),t("em",[e._v("/\n}\nreturn 0;                       /")]),e._v(" continue with normal routine "),t("em",[e._v("/\n}  /")]),e._v(" packet_dropper */")])]),e._v(" "),t("p",[e._v("/*************************************************************** init_module")]),e._v(" "),t("ul",[t("li",[e._v("this function replaces the null pointer with a real one "),t("em",[e._v('/\nint init_module() {\nEXPORT_NO_SYMBOLS;\ncutoff = rate * MAX_UNSIGNED_SHORT;\ntest_function = packet_dropper;\nprintk("<1> packet_dropper: now dropping packets\\n");\nreturn 0;\n}  /')]),e._v(" init_module */")])]),e._v(" "),t("p",[e._v("/************************************************************ cleanup_module")]),e._v(" "),t("ul",[t("li",[e._v("this function resets the function pointer back to null "),t("em",[e._v('/\nvoid cleanup_module() {\ntest_function = 0;\nprintk("<1> packet_dropper: uninstalled\\n");\n}  /')]),e._v(" cleanup_module */")])]),e._v(" "),t("h1",{attrs:{id:"chapter-14"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-14"}},[e._v("#")]),e._v(" Chapter 14")]),e._v(" "),t("p",[e._v("Additional Resources")]),e._v(" "),t("h2",{attrs:{id:"_14-1-internet-sites"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-internet-sites"}},[e._v("#")]),e._v(" 14.1  Internet Sites")]),e._v(" "),t("p",[t("strong",[e._v("Linux Documentation Project")])]),e._v(" "),t("p",[e._v("http://metalab.unc.edu/mdw/index.html")]),e._v(" "),t("p",[t("strong",[e._v("Linux Headquarters")])]),e._v(" "),t("p",[e._v("http://www.linuxhq.com")]),e._v(" "),t("p",[t("strong",[e._v("Linux HOWTOs")])]),e._v(" "),t("p",[e._v("ftp://metalab.unc.edu/pub/Linux/docs/HOWTO")]),e._v(" "),t("p",[t("strong",[e._v("Linux Kernel Hackers' Guide")])]),e._v(" "),t("p",[e._v("http://metalab.unc.edu/mdw/LDP/khg/HyperNews/get/khg.html")]),e._v(" "),t("p",[t("strong",[e._v("Linux Router Project")])]),e._v(" "),t("p",[e._v("http://www.linuxrouter.org")]),e._v(" "),t("p",[t("strong",[e._v("New TTCP")])]),e._v(" "),t("p",[e._v("http://users.leo.org/~bartel")]),e._v(" "),t("p",[t("strong",[e._v("Red Hat Software")])]),e._v(" "),t("p",[e._v("http://www.redhat.com")]),e._v(" "),t("p",[t("strong",[e._v("Requests for Comment")])]),e._v(" "),t("p",[e._v("http://www.rfc-editor.org/isi.html")]),e._v(" "),t("h2",{attrs:{id:"_14-2-books"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-books"}},[e._v("#")]),e._v(" 14.2  Books")]),e._v(" "),t("p",[t("strong",[e._v("Computer Networks")])]),e._v(" "),t("p",[e._v("Tanenbaum, Andrew, Prentice-Hall Inc., Upper Saddle River, NJ, 1996.")]),e._v(" "),t("p",[t("strong",[e._v("High Speed Networks")])]),e._v(" "),t("p",[e._v("Stallings, William, Prentice-Hall Inc., Upper Saddle River, NJ, 1998.")]),e._v(" "),t("p",[t("strong",[e._v("Linux Core Kernel Commentary")])]),e._v(" "),t("p",[e._v("Maxwell, Scott, CoriolisOpen Press, Scottsdale, AZ, 1999.")]),e._v(" "),t("p",[t("strong",[e._v("Linux Device Drivers")])]),e._v(" "),t("p",[e._v("Rubini, Alessandro, O'Reilly & Associates, Inc., Sebastopol, CA, 1998.")]),e._v(" "),t("p",[t("strong",[e._v("Linux Kernel Internals")])]),e._v(" "),t("p",[e._v("Beck, Michael, et al., Addison-Wesley, Harlow, England, 1997.")]),e._v(" "),t("p",[t("strong",[e._v("Running Linux")])]),e._v(" "),t("p",[e._v("Welsh, Matt, Dalheimer, Matthias, and Kaufman, Lar, O'Reilly & Associates, Inc., Sebastopol, CA, 1999.")]),e._v(" "),t("p",[t("strong",[e._v("Unix Network Programming, Vol. 1 (2d Ed.)")])]),e._v(" "),t("p",[e._v("Stevens, W. Richard, Prentice-Hall Inc., Upper Saddle River, NJ, 1998.")]),e._v(" "),t("h1",{attrs:{id:"chapter-15"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chapter-15"}},[e._v("#")]),e._v(" Chapter 15")]),e._v(" "),t("p",[e._v("Acronyms")]),e._v(" "),t("p",[t("strong",[e._v("ARP")])]),e._v(" "),t("p",[e._v("Address Resolution Protocol")]),e._v(" "),t("p",[t("strong",[e._v("ATM")])]),e._v(" "),t("p",[e._v("Asynchronous Transfer Mode (a protocol)")]),e._v(" "),t("p",[t("strong",[e._v("BSD")])]),e._v(" "),t("p",[e._v("Berkeley Software Distribution")]),e._v(" "),t("p",[t("strong",[e._v("DHCP")])]),e._v(" "),t("p",[e._v("Dynamic Hardware Configuration Protocol")]),e._v(" "),t("p",[t("strong",[e._v("DNS")])]),e._v(" "),t("p",[e._v("Domain Name Server")]),e._v(" "),t("p",[t("strong",[e._v("FIB")])]),e._v(" "),t("p",[e._v("Forwarding Information Base")]),e._v(" "),t("p",[t("strong",[e._v("GUI")])]),e._v(" "),t("p",[e._v("Graphical User Interface")]),e._v(" "),t("p",[t("strong",[e._v("ICMP")])]),e._v(" "),t("p",[e._v("Internet Control Message Protocol")]),e._v(" "),t("p",[t("strong",[e._v("INET")])]),e._v(" "),t("p",[e._v("Internet")]),e._v(" "),t("p",[t("strong",[e._v("IP")])]),e._v(" "),t("p",[e._v("Internet Protocol")]),e._v(" "),t("p",[t("strong",[e._v("ISP")])]),e._v(" "),t("p",[e._v("Internet Service Provider")]),e._v(" "),t("p",[t("strong",[e._v("LAN")])]),e._v(" "),t("p",[e._v("Local Area Network")]),e._v(" "),t("p",[t("strong",[e._v("LDP")])]),e._v(" "),t("p",[e._v("Linux Documentation Project")]),e._v(" "),t("p",[t("strong",[e._v("lo")])]),e._v(" "),t("p",[e._v("Loopback (device or interface)")]),e._v(" "),t("p",[t("strong",[e._v("MTU")])]),e._v(" "),t("p",[e._v("Maximum Transfer Unit")]),e._v(" "),t("p",[t("strong",[e._v("PPP")])]),e._v(" "),t("p",[e._v("Point-to-Point Protocol")]),e._v(" "),t("p",[t("strong",[e._v("RARP")])]),e._v(" "),t("p",[e._v("Reverse Address Resolution Protocol")]),e._v(" "),t("p",[t("strong",[e._v("RIP")])]),e._v(" "),t("p",[e._v("Routing Information Protocol")]),e._v(" "),t("p",[t("strong",[e._v("RTT")])]),e._v(" "),t("p",[e._v("Round Trip Time")]),e._v(" "),t("p",[t("strong",[e._v("TCP")])]),e._v(" "),t("p",[e._v("Transmission Control Protocol")]),e._v(" "),t("p",[t("strong",[e._v("UDP")])]),e._v(" "),t("p",[e._v("User Datagram Protocol")]),e._v(" "),t("p",[t("strong",[e._v("UNH")])]),e._v(" "),t("p",[e._v("University of New Hampshire")]),e._v(" "),t("p",[t("strong",[e._v("VLAN")])]),e._v(" "),t("p",[e._v("Virtual Local Area Network")]),e._v(" "),t("p",[t("strong",[e._v("WAN")])]),e._v(" "),t("p",[e._v("Wide Area Network")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("File translated from TEX by "),t("a",{attrs:{href:"http://hutchinson.belmont.ma.us/tth/",target:"_blank",rel:"noopener noreferrer"}},[e._v("TTH"),t("OutboundLink")],1),e._v(", version 2.70."),t("br"),e._v("\nOn 31 May 2000, 23:35.")])])}),[],!1,null,null,null);t.default=o.exports}}]);