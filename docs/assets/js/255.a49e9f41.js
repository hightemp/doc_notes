(window.webpackJsonp=window.webpackJsonp||[]).push([[255],{527:function(e,n,t){"use strict";t.r(n);var a=t(14),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("https://habr.com/ru/articles/336758/")]),e._v(" "),n("p",[e._v("Статья рассчитана на широкий круг читателей и требует лишь базовых знаний PHP и Javascript. Если вы занимались программированием и вам знакома аббревиатура API, то вы по адресу.")]),e._v(" "),n("p",[e._v("Изначально статья предполагала лишь описание отличительных особенностей GraphQL и RESTful API, с которыми мы столкнулись на практике, но в итоге она вылилась в объемный туториал на несколько частей.")]),e._v(" "),n("p",[e._v("И сразу же хочу добавить, что не считаю GraphQL панацеей от всех бед и киллером RESTful API.")]),e._v(" "),n("h2",{attrs:{id:"кто-мы"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#кто-мы"}},[e._v("#")]),e._v(" Кто мы?")]),e._v(" "),n("p",[e._v("Мы — компания, которая разрабатывает мобильные приложения, причем, как правило, у этих приложений существует клиент на iOS (ну понятное дело), Android и Web. Лично я в этой компании занимаюсь написанием серверной части на PHP.")]),e._v(" "),n("h2",{attrs:{id:"предыстория"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#предыстория"}},[e._v("#")]),e._v(" Предыстория")]),e._v(" "),n("p",[e._v("Все началось с того что мы закончили разработку одного приложения (ну как закончили, закончить разработку приложения невозможно, просто его финансирование было безвременно приостановлено), и нам тут же зашел новый проект. Благо, компания не ограничивает разработчиков в выборе технологий (конечно же в разумных пределах), и было принято решение внести определенные изменения, дабы попытаться избежать проблем, возникавших в прошлом. Ведь, как известно, если продолжать делать то, что делаешь, то и продолжаешь получать то, что получаешь.")]),e._v(" "),n("h2",{attrs:{id:"проблемы-restful-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#проблемы-restful-api"}},[e._v("#")]),e._v(" Проблемы RESTful API")]),e._v(" "),n("p",[e._v("Не то чтобы у REST’а были большие проблемы, но с одной из них я сталкивался весьма регулярно. Дело в том, что разработчики на наших проектах весьма высоко квалифицированы, и это, в свою очередь, причина того, что каждый из них считает себя на определенном уровне экспертом в своей области. API это та тонкая ниточка среди технологий которая связывает backend и frontend специалистов и является причиной многочисленных споров о том, как именно его нужно разрабатывать.")]),e._v(" "),n("h3",{attrs:{id:"структура-проекта"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#структура-проекта"}},[e._v("#")]),e._v(" Структура проекта")]),e._v(" "),n("p",[e._v("Для примера рассмотрим типичную структуру данных:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/99c/a6c/269/99ca6c269c08c39f3077c74da4590a39.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Тут нужно понимать, что в реальной жизни такие таблицы могут иметь по 20+ полей, что делает использование GraphQL еще более привлекательным и оправданным. Почему именно, я попытаюсь объяснить в статье.")]),e._v(" "),n("h3",{attrs:{id:"какие-api-методы-хочет-создавать-backend-разработчик"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#какие-api-методы-хочет-создавать-backend-разработчик"}},[e._v("#")]),e._v(" Какие API методы хочет создавать backend разработчик?")]),e._v(" "),n("p",[e._v("Разработчик серверной части конечно же хочет писать API методы таким образом, чтобы они максимально соответствовали целостным исчерпывающим объектам. Например:")]),e._v(" "),n("p",[n("strong",[e._v("GET /api/user/:id")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n\tid\n\temail\n\tfirstName\n\tlastName\n\tcreateDate\n\tmodifyDate\n\tlastVisitDate\n\tstatus\n}\n")])])]),n("p",[n("strong",[e._v("GET /api/address/:id")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n\tid\n\tuserId\n\tstreet\n\tzip\n\tcityId\n\tcreateDate\n\tmodifyDate\n\tstatus\n}\n")])])]),n("p",[n("strong",[e._v("GET /api/city/:id")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n\tid\n\tname\n}\n")])])]),n("p",[e._v("… и т.д. Написание подобной архитектуры не только проще и быстрее (если не говорить о том, что это все делает за нас какой-нибудь скаффолдинг), но и архитектурно и эстетически красивее и правильнее (по крайней мере так считает сам разработчик). В лучшем случае backend соглашается на вложенные объекты, чтобы вместо addressId в респонсе возвращался вложенный объект адреса или (в случае связки “один ко многим”) массив адресов.")]),e._v(" "),n("h3",{attrs:{id:"какие-api-методы-хочет-вызывать-разработчик-ui"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#какие-api-методы-хочет-вызывать-разработчик-ui"}},[e._v("#")]),e._v(" Какие API методы хочет вызывать разработчик UI?")]),e._v(" "),n("p",[e._v("Разработчик клиента немногим более приближен к живым людям (пользователям приложения) и их потребностям, в результате чего в приложении существует несколько (нужно читать много) мест, где необходимы разные наборы одних и тех же данных. Таким образом он хочет для каждого функционального элемента иметь по методу:")]),e._v(" "),n("p",[n("strong",[e._v("GET /api/listOfUsersForMainScreen")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("[\n\t{\n\t\tfirstName\n\t\tlastName\n\t\tdateCreated\n\t\tcity\n\t\tstreet\n\t}\n\t...\n]\n")])])]),n("p",[e._v("… и так далее в том же духе. Конечно же, такое желание вполне оправдано не только желанием сократить себе работу, но и улучшить производительность приложения. Во-первых UI делает один вызов вместо трёх (сначала user, затем address, а потом и city). Во вторых, такой метод избавит от получения множества (зачастую немалого) избыточных данных. При этом очень желательно чтобы dateCreated возвращалась в человеческом формате, а не в первозданном, взятом из поля в БД (а то ведь еще придется и unix time конвертировать).")]),e._v(" "),n("p",[e._v("На этой почве и рождаются конфликты, коих я был свидетелем, а иногда и участником. Хорошие разработчики ищут и, конечно же, находят компромиссы, чтобы частично удовлетворить потребности друг друга. Но если у вас, к примеру, один frontend и два backend, то тут одиночке придется включить свою харизму на максимум и задействовать все дипломатические навыки, дабы продавить написание своих бессмысленных методов, которые будут вызываться один раз за весь жизненный цикл приложения.")]),e._v(" "),n("h2",{attrs:{id:"что-такое-graphql-и-почему-он-должен-решать-мои-проблемы"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#что-такое-graphql-и-почему-он-должен-решать-мои-проблемы"}},[e._v("#")]),e._v(" Что такое GraphQL и почему он должен решать мои проблемы?")]),e._v(" "),n("p",[e._v("Для тех, кто не знаком с GraphQL, советую потратить не более, чем 5-10 минут и посетить "),n("a",{attrs:{href:"http://graphql.org/learn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("эту страницу"),n("OutboundLink")],1),e._v(", чтобы понять с чем его едят.")]),e._v(" "),n("p",[e._v("Почему он решает вышеописанную проблему? Потому что при использовании GraphQL, серверный разработчик описывает атомарные сущности и связи так, как ему это нравится, а UI строит кастомные запросы в зависимости от потребностей конкретного элемента. И вроде бы и овцы сыты и волки целы, но, к счастью, мы не живем в идеальном мире и подстраиваться все равно приходится. Но обо всем по-порядку.")]),e._v(" "),n("h2",{attrs:{id:"покажите-мне-код"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#покажите-мне-код"}},[e._v("#")]),e._v(" Покажите мне код")]),e._v(" "),n("p",[e._v("На Хабре уже была "),n("a",{attrs:{href:"https://habrahabr.ru/post/328122/",target:"_blank",rel:"noopener noreferrer"}},[e._v("хорошая статья"),n("OutboundLink")],1),e._v(" о том, как подружить PHP и GraphQL, из которой я вынес много полезного, и заранее извиняюсь за повторения, ведь основной поинт статьи не обучить основам, а показать преимущества и недостатки.")]),e._v(" "),n("p",[n("em",[e._v("Готовый демо проект серверной части можно "),n("a",{attrs:{href:"https://github.com/timur560/graphql-server-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("посмотреть тут"),n("OutboundLink")],1),e._v(".")])]),e._v(" "),n("p",[e._v("Собственно, приступим к написанию сервера. Чтобы пропустить настройку фреймворка и окружения, которая не содержит никакой информации о самом GraphQL, можете сразу переходить к созданию структуры (шаг 2).")]),e._v(" "),n("h3",{attrs:{id:"шаг-1-установка-и-настроика-yii2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-1-установка-и-настроика-yii2"}},[e._v("#")]),e._v(" Шаг 1. Установка и настройка Yii2")]),e._v(" "),n("p",[e._v("Данный шаг никак не связан с GraphQL, но он необходим для наших дальнейших действий.")]),e._v(" "),n("p",[n("strong",[e._v("Установка и настройка Yii2")])]),e._v(" "),n("h3",{attrs:{id:"шаг-2-установка-расширения-для-graphql"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-2-установка-расширения-для-graphql"}},[e._v("#")]),e._v(" Шаг 2. Установка расширения для GraphQL")]),e._v(" "),n("p",[e._v("Для нашего проекта будем использовать базовое расширение webonyx/graphql-php (https://github.com/webonyx/graphql-php).")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$> composer require webonyx/graphql-php\n")])])]),n("p",[e._v("Также на github можно найти уже заточенное расширение под Yii2, но на первый взгляд оно меня не вдохновило. Если же вы с ним знакомы, поделитесь своим опытом в комментариях.")]),e._v(" "),n("h3",{attrs:{id:"шаг-3-создаем-структуру-проекта"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-3-создаем-структуру-проекта"}},[e._v("#")]),e._v(" Шаг 3. Создаем структуру проекта.")]),e._v(" "),n("p",[e._v("Основные элементы структуры, задействованные в реализации GraphQL сервера:")]),e._v(" "),n("p",[n("strong",[e._v("schema")]),e._v(" — директория в корне фреймворка, которая будет хранить сущности для GraphQL сервера: типы и мутации. Название директории и расположение не принципиально, можете назвать как угодно и расположить в другом неймспейсе (например api/ или components/).")]),e._v(" "),n("p",[n("strong",[e._v("schema/QueryType.php, schema/MutationType.php")]),e._v(" — “корневые” типы.")]),e._v(" "),n("p",[n("strong",[e._v("schema/Types.php")]),e._v(" — некий агрегатор для инициализации наших кастомных типов.")]),e._v(" "),n("p",[n("strong",[e._v("schema/mutations")]),e._v(" — мутации предпочтительно хранить в отдельной директории для удобства.")]),e._v(" "),n("p",[e._v("Ну и собственно "),n("strong",[e._v("controllers/api/GraphqlController.php")]),e._v(" — точка входа. Все запросы к GraphQL серверу идут через одну точку входа — /api/graphql. Таким образом ничего не мешает вам параллельно содержать RESTful API (если уж на то пошло, то, грубо говоря, GraphQL сервер это один API-метод, принимающий на вход параметрами GraphQL-запросы).")]),e._v(" "),n("h4",{attrs:{id:"шаг-3-1-создадим-типы-для-наших-моделеи"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-3-1-создадим-типы-для-наших-моделеи"}},[e._v("#")]),e._v(" Шаг 3.1. Создадим типы для наших моделей.")]),e._v(" "),n("p",[e._v("Создадим новую директорию schema и в ней классы для наших моделей.")]),e._v(" "),n("p",[n("em",[e._v("/schema/CityType.php:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass CityType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                \t'name' => [\n                \t\t'type' => Type::string(),\n                \t],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n\n}\n")])])]),n("p",[e._v("В описании поля участвуют следующие параметры:")]),e._v(" "),n("p",[n("strong",[e._v("type")]),e._v(" — GraphQL-тип поля (Type::string(), Type::int(), т.д).")]),e._v(" "),n("p",[n("strong",[e._v("description")]),e._v(" — описание (просто текст; будет использоваться в схеме, придает удобство при отладке запросов).")]),e._v(" "),n("p",[n("strong",[e._v("args")]),e._v(" — принимаемые аргументы (ассоциативные массив, где ключ — имя аргумента, значение — GraphQL-тип).")]),e._v(" "),n("p",[n("strong",[e._v("resolve($root, $args)")]),e._v(" — функция, которая возвращает значение поля. Аргументы: $root — объект соответствующего ActiveRecord (в данном случае в него будет приходить объект models\\City); $args — ассоциативный массив аргументов (описанных в $args).")]),e._v(" "),n("p",[e._v("Все поля кроме type — опциональны.")]),e._v(" "),n("p",[n("em",[e._v("/schema/UserType.php:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse app\\models\\User;\n\nclass UserType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    'firstname' => [\n                        'type' => Type::string(),\n                    ],\n                    'lastname' => [\n                        'type' => Type::string(),\n                    ],\n                    'createDate' => [\n                        'type' => Type::string(),\n                        \n                        // текстовое описание, поясняющее\n                        // что именно хранит поле\n                        // немного позже вы увидите в чем его удобство\n                        // (оно еще больше сократит ваше общение с юайщиком)\n                        'description' => 'Date when user was created',\n                        \n                        // чтобы можно было форматировать дату, добавим\n                        // дополнительный аргумент format\n                        'args' => [\n                            'format' => Type::string(),\n                        ],\n\n                        // и собственно опишем что с этим аргументом\n                        // делать\n                        'resolve' => function(User $user, $args) {\n                            if (isset($args['format'])) {\n                                return date($args['format'], strtotime($user->createDate));\n                            }\n\n                            // коли ничего в format не пришло, \n                            // оставляем как есть\n                            return $user->createDate;\n                        },\n                    ],\n\n                    // при необходимости с остальными датами можно\n                    // произвести те же действия, но мы\n                    // сейчас этого делать, конечно же, не будем\n                    'modityDate' => [\n                        'type' => Type::string(),\n                    ],\n                    'lastVisitDate' => [\n                        'type' => Type::string(),\n                    ],\n                    'status' => [\n                        'type' => Type::int(),\n                    ],\n\n                    // теперь самая интересная часть схемы - \n                    // связи\n                    'addresses' => [\n                        // так как адресов у нас много,\n                        // то нам необходимо применить\n                        // модификатор Type::listOf, который\n                        // указывает на то, что поле должно вернуть\n                        // массив объектов типа, указанного\n                        // в скобках\n                        'type' => Type::listOf(Types::address()),\n                        'resolve' => function(User $user) {\n                            // примечательно то, что мы можем сразу же\n                            // обращаться к переменной $user без дополнительных проверок\n                            // вроде, не пустой ли он, и т.п.\n                            // так как если бы он был пустой, до текущего\n                            // уровня вложенности мы бы просто не дошли\n                            return $user->addresses;\n                        },\n                    ],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n\n}\n")])])]),n("p",[n("em",[e._v("/schema/AddressType.php:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass AddressType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    'user' => [\n                        'type' => Types::user(),\n                    ],\n                    'city' => [\n                        'type' => Types::city(),\n                    ],\n\n                    // остальные поля не столь интересны\n                    // посему оставляю их вам на \n                    // личное растерзание\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n\n}\n")])])]),n("p",[e._v("Для AddressType.php нам необходим вспомогательный класс Types.php, который описан ниже.")]),e._v(" "),n("h4",{attrs:{id:"шаг-3-2-schema-types-php"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-3-2-schema-types-php"}},[e._v("#")]),e._v(" Шаг 3.2. schema/Types.php")]),e._v(" "),n("p",[e._v("Дело в том, что GraphQL схема не может иметь несколько одинаковых (одноименных) типов. Именно за этим призван следить агрегатор Types.php. Название нарочно было выбрано именно Types, чтобы было похоже, и, в тоже время, отличалось от стандартного класса библиотеки GraphQL — Type. Таким образом обратиться к стандартному типу можно через Type::int(), Type::string(), а к кастомному — Types::query(), Types::user(), и т.д.")]),e._v(" "),n("p",[n("em",[e._v("schema/Types.php:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php \n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass Types\n{\n    private static $query;\n    private static $mutation;\n\n    private static $user;\n    private static $address;\n    private static $city;\n\n\n    public static function query()\n    {\n        return self::$query ?: (self::$query = new QueryType());\n    }\n\n    public static function user()\n    {\n        return self::$user ?: (self::$user = new UserType());\n    }\n\n    public static function address()\n    {\n        return self::$address ?: (self::$address = new AddressType());\n    }\n\n    public static function city()\n    {\n        return self::$city ?: (self::$city = new CityType());\n    }\n\n}\n")])])]),n("h4",{attrs:{id:"шаг-3-3-schema-querytype-php"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-3-3-schema-querytype-php"}},[e._v("#")]),e._v(" Шаг 3.3. schema/QueryType.php")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse app\\models\\User;\nuse app\\models\\Address;\n\nclass QueryType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    'user' => [\n                        'type' => Types::user(),\n\n                        // добавим сюда аргументов, дабы\n                        // выбрать необходимого нам юзера\n                        'args' => [\n                            // чтобы агрумент сделать обязательным\n                            // применим модификатор Type::nonNull()\n                            'id' => Type::nonNull(Type::int()),\n                        ],\n                        'resolve' => function($root, $args) {\n                            // таким образом тут мы уверены в том\n                            // что в $args обязательно присутствет элемент с индексом\n                            // `id`, и он обязательно целочисленный, иначе мы бы сюда не попали\n\n                            // так же мы не боимся, что юзера с этим `id`\n                            // в базе у нас не существует\n                            // библиотека корректно это обработает\n                            return User::find()->where(['id' => $args['id']])->one();\n                        }\n                    ],\n\n                    // в принципе на поле user можно остановиться, в случае\n                    // если нам нужно обращаться к данным лиш конкретного пользователя\n                    // но если нам нужны данные с другими привязками добавим\n                    // для примера еще полей\n\n                    'addresses' => [\n                        // без дополтинельных параметров\n                        // просто вернет нам списох всех\n                        // адресов\n                        'type' => Type::listOf(Types::address()), \n\n                        // добавим фильтров для интереса\n                        'args' => [\n                            'zip' => Type::string(),\n                            'street' => Type::string(),\n                        ],\n                        'resolve' => function($root, $args) {\n                            $query = Address::find();\n\n                            if (!empty($args)) {\n                                $query->where($args);\n                            }\n\n                            return $query->all();\n                        }\n                    ],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n}\n")])])]),n("p",[e._v("C MutationType.php разберемся немного позже.")]),e._v(" "),n("h4",{attrs:{id:"шаг-3-4-создаем-controllers-api-graphqlcontroller-php"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-3-4-создаем-controllers-api-graphqlcontroller-php"}},[e._v("#")]),e._v(" Шаг 3.4. Создаем controllers/api/GraphqlController.php")]),e._v(" "),n("p",[e._v("Теперь доделаем последнюю часть, чтобы к нашим новосозданным типам можно было достучаться.")]),e._v(" "),n("p",[n("em",[e._v("GraphqlController.php:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\controllers\\api;\n\nuse app\\schema\\Types;\nuse GraphQL\\GraphQL;\nuse GraphQL\\Schema;\nuse yii\\base\\InvalidParamException;\nuse yii\\helpers\\Json;\n\nclass GraphqlController extends \\yii\\rest\\ActiveController\n{\n    public $modelClass = '';\n\n    /**\n     * @inheritdoc\n     */\n    protected function verbs()\n    {\n        return [\n            'index' => ['POST'],\n        ];\n    }\n\n    public function actions()\n    {\n        return [];\n    }\n\n    public function actionIndex()\n    {\n        // сразу заложим возможность принимать параметры\n        // как через MULTIPART, так и через POST/GET\n\n        $query = \\Yii::$app->request->get('query', \\Yii::$app->request->post('query'));\n        $variables = \\Yii::$app->request->get('variables', \\Yii::$app->request->post('variables'));\n        $operation = \\Yii::$app->request->get('operation', \\Yii::$app->request->post('operation', null));\n\n        if (empty($query)) {\n            $rawInput = file_get_contents('php://input');\n            $input = json_decode($rawInput, true);\n            $query = $input['query'];\n            $variables = isset($input['variables']) ? $input['variables'] : [];\n            $operation = isset($input['operation']) ? $input['operation'] : null;\n        }\n\n        // библиотека принимает в variables либо null, либо ассоциативный массив\n        // на строку будет ругаться\n\n        if (!empty($variables) && !is_array($variables)) {\n            try {\n                $variables = Json::decode($variables);\n            } catch (InvalidParamException $e) {\n                $variables = null;\n            }\n        }\n\n        // создаем схему и подключаем к ней наши корневые типы\n\n        $schema = new Schema([\n            'query' => Types::query(),\n        ]);\n\n        // огонь!\n\n        $result = GraphQL::execute(\n            $schema,\n            $query,\n            null,\n            null,\n            empty($variables) ? null : $variables,\n            empty($operation) ? null : $operation\n        );\n\n        return $result;\n    }\n}\n")])])]),n("p",[e._v("Также стоит отметить, что обертывание в try-catch GraphQL::execute() для форматирования вывода ошибок ничего не даст, т.к. он уже внутри перехватывает всё возможное, а что делать с ошибками, я опишу немного позже.")]),e._v(" "),n("h3",{attrs:{id:"шаг-4-тестируем"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#шаг-4-тестируем"}},[e._v("#")]),e._v(" Шаг 4. Тестируем.")]),e._v(" "),n("p",[e._v("Собственно, настало время осознать, увидеть и потрогать то, что у нас получилось.")]),e._v(" "),n("p",[e._v("Проверим наш запрос в расширении для Chome — GraphiQL. Лично я больше предпочитаю «GraphiQL Feen», которое имеет более расширенный функционал (сохраненные запросы, кастомные хедеры). Правда последнее иногда имеет проблемы с выводом ошибок, а точнее просто ничего не выводит в случае ошибки на сервере.")]),e._v(" "),n("p",[e._v("Вводим в поля необходимые данные и радуемся результату:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/f14/2b0/ccf/f142b0ccfc3da3c894336e9c245460bb.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Таким образом, после всего имеем:")]),e._v(" "),n("ul",[n("li",[e._v("автокомплит по полям и аргументам (с подчеркиванием неверных параметров, конечно же)")]),e._v(" "),n("li",[e._v("вывод дескрипшна подсвеченного поля")]),e._v(" "),n("li",[e._v("автоматическая справка с серфингом в правой части")]),e._v(" "),n("li",[e._v("моментальное получение результата")])]),e._v(" "),n("p",[n("em",[e._v("Примечание. Если у вас не заработал красивый URL, это значит, что вы недоконфигурили UrlManager и .htaccess, т.к. в первозданном Yii это не работает. Как это сделать гляньте в "),n("a",{attrs:{href:"https://github.com/timur560/graphql-server-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("репозитории к статье"),n("OutboundLink")],1),e._v(".")])]),e._v(" "),n("p",[e._v("Автокомплит аргументов:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/366/45e/404/36645e404fed7af4726a988bf087bc37.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Полностью кастомный запрос с полностью кастомным результатом — мечта frontend разработчика:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/72d/6c7/a48/72d6c7a484d762bfa1385332ab3e9f91.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Могли ли вы об этом всем мечтать разрабатывая свой RESTful, при том что вы для этого ничего и не делали? Конечно же нет.")]),e._v(" "),n("p",[e._v("Также важно обратить внимание на то, что для того, чтобы вытащить адреса и пользователя, нам не нужно делать два отдельных запроса, а можно (и нужно) всё сделать сразу:")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/f14/d4b/356/f14d4b356ef5469b66fbf017986b29c7.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Возможность дебага запросов лично я считаю одним из весомых преимуществ GraphQL. Дело в том, что он автоматически генерирует схему, которую втягивает расширение, и у вас включается валидация и автокомплит. Таким образом имея лишь адрес точки входа в GraphQL сервер, вы можете полностью изучить его возможности. Несекьюрно? Как по мне, секьюрность реализуется немного на другом уровне. Имея доступ к документации любого API, мы точно так же имеем полную его схему. Некоторые RESTful API имеют подобные JSON или XML схемы, к сожалению не многие, а для GraphQL это стандарт, к тому они же активно используются клиентами.")]),e._v(" "),n("h2",{attrs:{id:"to-be-continued"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#to-be-continued"}},[e._v("#")]),e._v(" To be continued…")]),e._v(" "),n("p",[e._v("В следующей(их) части(ях) статьи я опишу "),n("a",{attrs:{href:"https://habrahabr.ru/post/337044/",target:"_blank",rel:"noopener noreferrer"}},[e._v("как это всё по-красивому использовать в UI"),n("OutboundLink")],1),e._v(", и конечно же мы затронем еще одну тему без которой API не API — это "),n("a",{attrs:{href:"https://habrahabr.ru/post/337046/",target:"_blank",rel:"noopener noreferrer"}},[e._v("мутации"),n("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);n.default=r.exports}}]);