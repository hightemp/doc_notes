(window.webpackJsonp=window.webpackJsonp||[]).push([[341],{611:function(e,r,v){"use strict";v.r(r);var t=v(14),_=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("https://habr.com/ru/companies/piter/articles/275633/")]),e._v(" "),r("p",[e._v("Здравствуйте, Хабр!")]),e._v(" "),r("p",[e._v('В ближайшее время читайте пост о русском переводе долгожданной книги "'),r("a",{attrs:{href:"http://www.piter.com/product_by_id/51778339",target:"_blank",rel:"noopener noreferrer"}},[e._v("Создание Микросервисов"),r("OutboundLink")],1),e._v('" Сэма Ньюмена, которая уже отправилась в магазины. Пока же мы предлагаем почитать перевод статьи Аруна Гупты, автор которой описывает самые интересные паттерны проектирования, применимые в микросервисной архитектуре')]),e._v(" "),r("p",[e._v('Основные характеристики микросервисных приложений описаны в статье "'),r("a",{attrs:{href:"http://blog.arungupta.me/microservices-monoliths-noops/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Microservices, Monoliths and NoOps"),r("OutboundLink")],1),e._v('". Эти характеристики – функциональная декомпозиция или предметно-ориентированное проектирование, четко определенные интерфейсы, явно публикуемый интерфейс, принцип единственной обязанности и потенциальная многоязычность. Каждый сервис полностью автономный и полностековый. Соответственно, изменение реализации одного сервиса никак не сказывается на остальных, а обмен информацией происходит через четко определенные интерфейсы. У такого приложения есть ряд преимуществ, но они '),r("a",{attrs:{href:"http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("даром не даются"),r("OutboundLink")],1),e._v(", а требуют серьезной работы, связанной с NoOps.")]),e._v(" "),r("p",[e._v("Но предположим, что вы представляете себе масштаб этой работы, хотя бы частично, что вы действительно хотите создать такое приложение и посмотреть, что получится. Что же делать? Какова будет архитектура такого приложения?"),r("br"),e._v("\nСуществуют ли паттерны проектирования, оптимизирующие взаимодействие микросервисов?")]),e._v(" "),r("p",[e._v("Для создания качественной микросервисной архитектуры необходимо четко разделить функции в вашем приложении и команде. Так можно достичь слабого связывания (REST-интерфейсы) и сильного сцепления (множество сервисов могут компоноваться вместе, определяя более высокоуровневые сервисы или приложение).")]),e._v(" "),r("p",[e._v("Создание «глаголов» (напр. Checkout) или «существительных» (Product) в составе приложения — один из эффективных способов декомпозиции имеющегося кода. Например, product, catalog и checkout могут быть реализованы как три отдельных микросервиса, а затем взаимодействовать друг с другом, обеспечивая полный функционал корзины заказов.")]),e._v(" "),r("p",[e._v("Функциональная декомпозиция обеспечивает гибкость, масштабируемость и прочие -ости, но наша задача – создать приложение. Итак, если отдельные микросервисы идентичны, как же скомпоновать их для реализации функционала приложения?")]),e._v(" "),r("p",[e._v("Об этом и пойдет речь в статье")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн Агрегатор (Aggregator)")])]),e._v(" "),r("p",[e._v("Первый и, пожалуй, наиболее распространенный паттерн проектирования при работе с микросервисами — «агрегатор».")]),e._v(" "),r("p",[e._v("В простейшей форме агрегатор представляет собой обычную веб-страницу, вызывающую множество сервисов для реализации функционала, требуемого в приложении. Поскольку все сервисы (Service A, Service B и Service C) предоставляются при помощи легковесного REST-механизма, веб-страница может извлечь данные и обработать/отобразить их как нужно. Если требуется какая-либо обработка, например, применить бизнес-логику к данным, полученным от отдельных сервисов, то для этого у вас может быть CDI-компонент, преобразующий данные таким образом, чтобы их можно было вывести на веб-странице.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/094/0e1/d15/0940e1d1593b4254baed594640a051b9.png",alt:""}})]),e._v(" "),r("p",[e._v("Агрегатор может использоваться и в тех случаях, когда не требуется ничего отображать, а нужен лишь более высокоуровневый составной микросервис, который могут потреблять другие сервисы. В данном случае агрегатор просто соберет данные от всех отдельных микросервисов, применит к ним бизнес-логику, а далее опубликует микросервис как конечную точку REST. В таком случае, при необходимости, его смогут потреблять другие нуждающиеся в нем сервисы.")]),e._v(" "),r("p",[e._v("Этот паттерн следует принципу DRY. Если существует множество сервисов, которые должны обращаться к сервисам A, B и C, то рекомендуется абстрагировать эту логику в составной микросервис и агрегировать ее в виде отдельного сервиса. Преимущество абстрагирования на этом уровне заключается в том, что отдельные сервисы, скажем, A, B и C, могут развиваться независимо, а бизнес-логику будет по-прежнему выполнять составной микросервис.")]),e._v(" "),r("p",[e._v("Обратите внимание: каждый отдельный микросервис (опционально) имеет собственные уровни кэширования и базы данных. Если агрегатор – это составной микросервис, то и у него могут быть такие уровни.")]),e._v(" "),r("p",[e._v("Агрегатор также может независимо масштабироваться как по горизонтали, так и по вертикали. То есть, если речь идет о веб-странице, то к ней можно прикрутить дополнительные веб-серверы, а если это составной микросервис, использующий Java EE, то к нему прикручиваются дополнительные экземпляры WildFly, позволяющие удовлетворить растущие потребности.")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн Посредник (Proxy)")])]),e._v(" "),r("p",[e._v("Паттерн «посредник» при работе с микросервисами – это вариант агрегатора. В таком случае агрегация должна происходить на клиенте, но в зависимости от бизнес-требований при этом может вызываться дополнительный микросервис.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/a5e/699/6d1/a5e6996d11e544ea8ebf48f6cddfe906.png",alt:""}})]),e._v(" "),r("p",[e._v("Как и агрегатор, посредник может независимо масштабироваться по горизонтали и по вертикали. Это может понадобиться в ситуации, когда каждый отдельный сервис нужно не предоставлять потребителю, а запускать через интерфейс.")]),e._v(" "),r("p",[e._v("Посредник может быть "),r("em",[e._v("формальным")]),e._v(" (dumb), в таком случае он просто делегирует запрос одному из сервисов. Он может быть и "),r("em",[e._v("интеллектуальным")]),e._v(" (smart), в таком случае данные перед отправкой клиенту подвергаются тем или иным преобразованиям. Например, уровень представления для различных устройств может быть инкапсулирован в интеллектуальный посредник.")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн проектирования «Цепочка» (Chained)")])]),e._v(" "),r("p",[e._v("Микросервисный паттерн проектирования «Цепочка» выдает единый консолидированный ответ на запрос. В данном случае сервис A получает запрос от клиента, связывается с сервисом B, который, в свою очередь, может связаться с сервисом C. Все эти сервисы, скорее всего, будут обмениваться синхронными сообщениями «запрос/отклик» по протоколу HTTP.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/876/605/0f5/8766050f52f84c328a48201c495b94e3.png",alt:""}})]),e._v(" "),r("p",[e._v("Здесь важнее всего запомнить, что клиент блокируется до тех пор, пока не выполнится вся коммуникационная цепочка запросов и откликов, т.е. Service <-> Service B и Service B <-> Service C. Запрос от Service B к Service C может выглядеть совершенно иначе, нежели от Service A к Service B. Аналогично, отклик от Service B к Service A может принципиально отличаться от отклика Service C к Service B. Это наиболее важно во всех случаях, когда бизнес-ценность нескольких сервисов суммируется.")]),e._v(" "),r("p",[e._v("Здесь также важно понять, что нельзя делать цепочку слишком длинной. Это критично, поскольку цепочка синхронна по своей природе, и чем она длиннее, тем дольше придется ожидать клиенту, особенно если отклик заключается в выводе веб-страницы на экран. Существуют способы обойти такой блокирующий механизм запросов и откликов, и они рассматриваются в следующем паттерне.")]),e._v(" "),r("p",[e._v("Цепочка, состоящая из единственного микросервиса, называется «цепочка-одиночка». Впоследствии ее можно расширить.")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн проектирования «Ветка» (Branch)")])]),e._v(" "),r("p",[e._v("Микросервисный паттерн проектирования «Ветка» расширяет паттерн «Агрегатор» и обеспечивает одновременную обработку откликов от двух цепочек микросервисов, которые могут быть взаимоисключающими. Этот паттерн также может применяться для вызова различных цепочек, либо одной и той же цепочки – в зависимости от ваших потребностей.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/173/257/bca/173257bcaed04d97831a0691ec0c37ca.png",alt:""}})]),e._v(" "),r("p",[e._v("Сервис A, будь то веб-страница или составной микросервис, может конкурентно вызывать две различные цепочки – и в этом случае будет напоминать агрегатор. В другом случае сервис А может вызывать лишь одну цепочку в зависимости от того, какой запрос получит от клиента.")]),e._v(" "),r("p",[e._v("Такой механизм можно сконфигурировать, реализовав маршрутизацию конечных точек JAX-RS, в таком случае конфигурация должна быть динамической.")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн «Разделяемые данные» (Shared Data)")])]),e._v(" "),r("p",[e._v("Один из принципов проектирования микросервисов – автономность. Это означает, что сервис полностековый и контролирует все компоненты – пользовательский интерфейс, промежуточное ПО, сохраняемость, транзакции. В таком случае сервис может быть многоязычным и решать каждую задачу при помощи наиболее подходящих инструментов. Например, если при необходимости можно применить хранилище данных NoSQL, то лучше сделать именно так, а не забивать эту информацию в базу данных SQL.")]),e._v(" "),r("p",[e._v("Однако, типичная проблема, особенно при рефакторинге имеющегося монолитного приложения, связана с нормализацией базы данных — так, чтобы у каждого микросервиса был строго определенный объем информации, ни больше, ни меньше. Даже если в монолитном приложении используется только база данных SQL, ее денормализация приводит к дублированию данных, а возможно – и к несогласованности. На переходном этапе в некоторых приложениях бывает очень полезно применить паттерн «Разделяемые данные».")]),e._v(" "),r("p",[e._v("При этом паттерне несколько микросервисов могут работать о цепочке и совместно использовать хранилища кэша и базы данных. Это целесообразно лишь в случае, если между двумя сервисами существует сильная связь. Некоторые могут усматривать в этом антипаттерн, но в некоторых бизнес-ситуациях такой шаблон действительно уместен. Он определенно был бы антипаттерном в приложении, которое изначально создается как микросервисное.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/3b0/6e8/f29/3b06e8f29f9f4a78a09e8afff9c79935.png",alt:""}})]),e._v(" "),r("p",[e._v("Кроме того, его можно рассматривать как промежуточный этап, который нужно преодолеть, пока микросервисы не станут полностью автономными.")]),e._v(" "),r("p",[r("strong",[e._v("Паттерн «Асинхронные сообщения» (Asynchronous Messaging)")])]),e._v(" "),r("p",[e._v("При всей распространенности и понятности паттерна REST, у него есть важное ограничение, а именно: он синхронный и, следовательно, блокирующий. Обеспечить асинхронность можно, но это делается по-своему в каждом приложении. Поэтому в некоторых микросервисных архитектурах могут использоваться очереди сообщений, а не модель REST запрос/отклик.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://habrastorage.org/files/bec/4a4/2ec/bec4a42ec9d7476f90c7f8047957c87c.png",alt:""}})]),e._v(" "),r("p",[e._v("В этом паттерне сервис А может синхронно вызывать сервис C, который затем будет асинхронно связываться с сервисами B и В при помощи разделяемой очереди сообщений. Коммуникация Service A -> Service C может быть асинхронной, скажем, с использованием веб-сокетов; так достигается желаемая масштабируемость."),r("br"),e._v("\nКомбинация модели REST запрос/отклик и обмена сообщениями публикатор/подписчик также могут использоваться для достижения поставленных целей.")]),e._v(" "),r("p",[e._v("Рекомендую также прочитать статью "),r("a",{attrs:{href:"https://www.voxxed.com/blog/2015/04/coupling-versus-autonomy-in-microservices/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Coupling vs Autonomy in Microservices"),r("OutboundLink")],1),e._v(", в которой описано, какие паттерны коммуникации удобно применять с микросервисами.")])])}),[],!1,null,null,null);r.default=_.exports}}]);