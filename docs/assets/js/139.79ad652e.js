(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{412:function(_,e,t){"use strict";t.r(e);var n=t(14),r=Object(n.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("https://kernel.org/doc/html/next/userspace-api/netlink/intro.html")]),_._v(" "),e("h1",{attrs:{id:"введение-в-netlink"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#введение-в-netlink"}},[_._v("#")]),_._v(" Введение в Netlink "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#introduction-to-netlink",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Netlink часто называют заменой ioctl(). Он нацелен на замену структур C фиксированного формата, предоставляемых ioctl(), форматом, который позволяет легко добавлять или расширять аргументы.")]),_._v(" "),e("p",[_._v("Для этого Netlink использует минимальный заголовок метаданных фиксированного формата, за которым следует несколько атрибутов в формате TLV (тип, длина, значение).")]),_._v(" "),e("p",[_._v("К сожалению, с годами протокол развивался органичным и недокументированным образом, что затрудняет связное объяснение. Чтобы придать наиболее практический смысл, этот документ начинается с описания netlink в том виде, в каком он используется сегодня, и углубляется в более «исторические» варианты использования в последующих разделах.")]),_._v(" "),e("h2",{attrs:{id:"открытие-сокета"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#открытие-сокета"}},[_._v("#")]),_._v(" Открытие сокета "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#opening-a-socket",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Связь Netlink происходит через сокеты, сначала необходимо открыть сокет:")]),_._v(" "),e("p",[_._v("fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);")]),_._v(" "),e("p",[_._v("Использование сокетов обеспечивает естественный способ обмена информацией в обоих направлениях (в ядро ​​и из него). Операции по-прежнему выполняются синхронно, когда приложения посылают() запрос, но для чтения ответа требуется отдельный системный вызов recv().")]),_._v(" "),e("p",[_._v("Таким образом, очень упрощенный поток «вызова» Netlink будет выглядеть примерно так:")]),_._v(" "),e("p",[_._v("fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);")]),_._v(" "),e("p",[_._v("/* format the request "),e("em",[_._v("/\nsend(fd, &request, sizeof(request));\nn = recv(fd, &response, RSP_BUFFER_SIZE);\n/")]),_._v(" interpret the response */")]),_._v(" "),e("p",[_._v('Netlink также обеспечивает естественную поддержку "дампинга", т.е. передачи в пространство пользователя всех объектов определенного типа (например, сброса всех сетевых интерфейсов).')]),_._v(" "),e("p",[_._v("fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);")]),_._v(" "),e("p",[_._v("/* format the dump request "),e("em",[_._v("/\nsend(fd, &request, sizeof(request));\nwhile (1) {\nn = recv(fd, &buffer, RSP_BUFFER_SIZE);\n/")]),_._v(" one recv() call can read multiple messages, hence the loop below "),e("em",[_._v("/\nfor (nl_msg in buffer) {\nif (nl_msg.nlmsg_type == NLMSG_DONE)\ngoto dump_finished;\n/")]),_._v(" process the object */\n}\n}\ndump_finished:")]),_._v(" "),e("p",[_._v("Первые два аргумента вызова socket() требуют небольшого объяснения — это открытие сокета Netlink со всеми заголовками, предоставленными пользователем (отсюда NETLINK, RAW). Последний аргумент — это протокол в Netlink. Это поле используется для идентификации подсистемы, с которой сокет будет взаимодействовать.")]),_._v(" "),e("h3",{attrs:{id:"классическии-и-универсальныи-netlink"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#классическии-и-универсальныи-netlink"}},[_._v("#")]),_._v(" Классический и универсальный Netlink "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#classic-vs-generic-netlink",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Первоначальная реализация Netlink зависела от статического распределения идентификаторов подсистемам и обеспечивала небольшую вспомогательную инфраструктуру. Давайте будем называть эти протоколы вместе "),e("strong",[_._v("классическим Netlink")]),_._v(" . Их список определяется в верхней части "),e("code",[_._v("include/uapi/linux/netlink.h")]),_._v(" файла, среди прочего они включают в себя общую сеть (NETLINK_ROUTE), iSCSI (NETLINK_ISCSI) и аудит (NETLINK_AUDIT).")]),_._v(" "),e("p",[e("strong",[_._v("Generic Netlink")]),_._v(" (представленный в 2005 г.) позволяет динамически регистрировать подсистемы (и выделять идентификаторы подсистем), проводить самоанализ и упрощает реализацию интерфейса на стороне ядра.")]),_._v(" "),e("p",[_._v("В следующем разделе описывается, как использовать Generic Netlink, поскольку количество подсистем, использующих Generic Netlink, на порядок превышает количество старых протоколов. Также нет планов по добавлению в ядро ​​дополнительных протоколов Classic Netlink. Основная информация о том, чем взаимодействие с основными сетевыми частями ядра Linux (или другой из 20 подсистем, использующих Classic Netlink) отличается от Generic Netlink, представлена ​​далее в этом документе.")]),_._v(" "),e("h2",{attrs:{id:"общая-сетевая-ссылка"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#общая-сетевая-ссылка"}},[_._v("#")]),_._v(" Общая сетевая ссылка "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#generic-netlink",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("В дополнение к фиксированному заголовку метаданных Netlink каждый протокол Netlink определяет свой собственный фиксированный заголовок метаданных. (Подобно стеку сетевых заголовков — Ethernet > IP > TCP, у нас есть Netlink > Generic N. > Family.)")]),_._v(" "),e("p",[_._v("Сообщение Netlink всегда начинается с , за которым следует заголовок, относящийся к протоколу. В случае Generic Netlink заголовок протокола имеет вид struct genlmsghdr."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Практическое значение полей в случае Generic Netlink следующее:")]),_._v(" "),e("p",[_._v("struct nlmsghdr {\n__u32   nlmsg_len;      /* Length of message including headers "),e("em",[_._v("/\n__u16   nlmsg_type;     /")]),_._v(" Generic Netlink Family (subsystem) ID "),e("em",[_._v("/\n__u16   nlmsg_flags;    /")]),_._v(" Flags - request or dump "),e("em",[_._v("/\n__u32   nlmsg_seq;      /")]),_._v(" Sequence number "),e("em",[_._v("/\n__u32   nlmsg_pid;      /")]),_._v(" Port ID, set to 0 "),e("em",[_._v("/\n};\nstruct genlmsghdr {\n__u8    cmd;            /")]),_._v(" Command, as defined by the Family "),e("em",[_._v("/\n__u8    version;        /")]),_._v(" Irrelevant, set to 1 "),e("em",[_._v("/\n__u16   reserved;       /")]),_._v(" Reserved, set to 0 "),e("em",[_._v("/\n};\n/")]),_._v(" TLV attributes follow... */")]),_._v(" "),e("p",[_._v("В Classic Netlink "),e("code",[_._v("nlmsghdr.nlmsg_type")]),_._v("используется для определения того, к какой операции внутри подсистемы относится сообщение (например, для получения информации о netdev). Generic Netlink необходимо мультиплексировать несколько подсистем в одном протоколе, поэтому он использует это поле для идентификации подсистемы и "),e("code",[_._v("genlmsghdr.cmd")]),_._v("вместо этого идентифицирует операцию. (См. "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#res-fam",target:"_blank",rel:"noopener noreferrer"}},[_._v("Разрешение идентификатора семейства"),e("OutboundLink")],1),_._v(" для получения информации о том, как найти идентификатор семейства интересующей подсистемы.) Обратите внимание, что первые 16 значений (0–15) этого поля зарезервированы для управляющих сообщений как в Classic Netlink, так и в Generic Netlink. Дополнительные сведения см. в "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#nl-msg-type",target:"_blank",rel:"noopener noreferrer"}},[_._v("разделе Типы сообщений Netlink ."),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("В сокете Netlink существует 3 обычных типа обмена сообщениями:")]),_._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[_._v("выполнение одного действия ( "),e("code",[_._v("do")]),_._v(");")])]),_._v(" "),e("li",[e("p",[_._v("информация о сбросе ( "),e("code",[_._v("dump")]),_._v(");")])]),_._v(" "),e("li",[e("p",[_._v("получение асинхронных уведомлений ( "),e("code",[_._v("multicast")]),_._v(").")])])])]),_._v(" "),e("p",[_._v("Классический Netlink очень гибок и, по-видимому, допускает другие типы обмена, но на практике используются только эти три.")]),_._v(" "),e("p",[_._v("Асинхронные уведомления отправляются ядром и принимаются пользовательскими сокетами, подписавшимися на них. "),e("code",[_._v("do")]),_._v("и "),e("code",[_._v("dump")]),_._v("запросы инициируются пользователем. "),e("code",[_._v("nlmsghdr.nlmsg_flags")]),_._v("следует установить следующим образом:")]),_._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[_._v("для "),e("code",[_._v("do")]),_._v(":"),e("code",[_._v("NLM_F_REQUEST | NLM_F_ACK")])])]),_._v(" "),e("li",[e("p",[_._v("для "),e("code",[_._v("dump")]),_._v(":"),e("code",[_._v("NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP")])])])])]),_._v(" "),e("p",[e("code",[_._v("nlmsghdr.nlmsg_seq")]),_._v("должно быть установлено монотонно возрастающее значение. Это значение отображается в ответах и ​​на практике не имеет значения, но установка его на возрастающее значение для каждого отправленного сообщения считается хорошей гигиеной. Назначение поля — сопоставление ответов на запросы. Асинхронные уведомления будут "),e("code",[_._v("nlmsghdr.nlmsg_seq")]),_._v("иметь "),e("code",[_._v("0")]),_._v(".")]),_._v(" "),e("p",[e("code",[_._v("nlmsghdr.nlmsg_pid")]),_._v("является Netlink-эквивалентом адреса. Это поле может быть установлено "),e("code",[_._v("0")]),_._v("при общении с ядром. См. "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#nlmsg-pid",target:"_blank",rel:"noopener noreferrer"}},[_._v("nlmsg_pid"),e("OutboundLink")],1),_._v(" для (необычного) использования поля.")]),_._v(" "),e("p",[_._v("Ожидаемое использование "),e("code",[_._v("genlmsghdr.version")]),_._v("состояло в том, чтобы разрешить управление версиями API, предоставляемых подсистемами. На сегодняшний день ни одна подсистема не использовала это поле в значительной степени, поэтому установка его на "),e("code",[_._v("1")]),_._v("кажется беспроигрышной ставкой.")]),_._v(" "),e("h3",{attrs:{id:"типы-сообщении-netlink"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#типы-сообщении-netlink"}},[_._v("#")]),_._v(" Типы сообщений Netlink "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#netlink-message-types",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Как упоминалось ранее, "),e("code",[_._v("nlmsghdr.nlmsg_type")]),_._v("содержит значения, специфичные для протокола, но первые 16 идентификаторов зарезервированы (первый тип сообщения, специфичный для подсистемы, должен быть равен "),e("code",[_._v("NLMSG_MIN_TYPE")]),_._v(") "),e("code",[_._v("0x10")]),_._v(".")]),_._v(" "),e("p",[_._v("Определено только 4 управляющих сообщения Netlink:")]),_._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[e("code",[_._v("NLMSG_NOOP")]),_._v("- игнорировать сообщение, не используемое на практике;")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("NLMSG_ERROR")]),_._v("- содержит код возврата операции;")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("NLMSG_DONE")]),_._v("- отмечает конец дампа;")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("NLMSG_OVERRUN")]),_._v("- буфер сокета переполнен, до сих пор не использовался.")])])])]),_._v(" "),e("p",[e("code",[_._v("NLMSG_ERROR")]),_._v("и "),e("code",[_._v("NLMSG_DONE")]),_._v("имеют практическое значение. Они несут коды возврата для операций. Обратите внимание, что если "),e("code",[_._v("NLM_F_ACK")]),_._v("флаг не установлен в запросе, Netlink не будет отвечать, "),e("code",[_._v("NLMSG_ERROR")]),_._v("если нет ошибки. Чтобы избежать особого случая этой причуды, рекомендуется всегда устанавливать "),e("code",[_._v("NLM_F_ACK")]),_._v(".")]),_._v(" "),e("p",[_._v("Формат "),e("code",[_._v("NLMSG_ERROR")]),_._v("описывается структурой nlmsgerr:")]),_._v(" "),e("hr"),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("struct nlmsghdr - response header")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("int error")])])])]),_._v(" "),e("hr"),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("struct nlmsghdr - original request header")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("** optionally (1) payload of the request")])])])]),_._v(" "),e("hr"),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("** optionally (2) extended ACK")])])]),_._v(" "),e("tbody")]),_._v(" "),e("p",[_._v("Здесь есть два экземпляра : первый ответ и второй запрос. несет информацию о запросе, который привел к ошибке. Это может быть полезно при попытке сопоставить запросы с ответами или повторно проанализировать запрос, чтобы вывести его в журналы."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1),e("code",[_._v("NLMSG_ERROR")])]),_._v(" "),e("p",[_._v("Полезная нагрузка запроса не отображается в сообщениях, сообщающих об успешном выполнении ( ), или если установлена ​​функция setsockopt(). Последнее распространено и, возможно, рекомендуется, так как чтение копии каждого запроса из ядра довольно расточительно. Отсутствие полезной нагрузки запроса указывается в ."),e("code",[_._v("error == 0``NETLINK_CAP_ACK``NLM_F_CAPPED``nlmsghdr.nlmsg_flags")])]),_._v(" "),e("p",[_._v("Вторым необязательным элементом "),e("code",[_._v("NLMSG_ERROR")]),_._v("являются расширенные атрибуты ACK. Дополнительные сведения см. в "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#ext-ack",target:"_blank",rel:"noopener noreferrer"}},[_._v("разделе Расширенный ACK ."),e("OutboundLink")],1),_._v(" Наличие расширенного ACK указано "),e("code",[_._v("NLM_F_ACK_TLVS")]),_._v("в "),e("code",[_._v("nlmsghdr.nlmsg_flags")]),_._v(".")]),_._v(" "),e("p",[e("code",[_._v("NLMSG_DONE")]),_._v("проще, запрос никогда не повторяется, но могут присутствовать расширенные атрибуты ACK:")]),_._v(" "),e("hr"),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("struct nlmsghdr - response header")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("int error")])])])]),_._v(" "),e("hr"),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("** optionally extended ACK")])])]),_._v(" "),e("tbody")]),_._v(" "),e("h3",{attrs:{id:"разрешение-семеиного-идентификатора"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#разрешение-семеиного-идентификатора"}},[_._v("#")]),_._v(" Разрешение семейного идентификатора "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#resolving-the-family-id",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("В этом разделе объясняется, как найти Family ID подсистемы. Он также служит примером связи Generic Netlink.")]),_._v(" "),e("p",[_._v("Generic Netlink сама по себе является подсистемой, предоставляемой через Generic Netlink API. Чтобы избежать циклической зависимости, Generic Netlink имеет статически выделенный Family ID ( "),e("code",[_._v("GENL_ID_CTRL")]),_._v("который равен "),e("code",[_._v("NLMSG_MIN_TYPE")]),_._v("). Семейство Generic Netlink реализует команду, используемую для получения информации о других семействах ( "),e("code",[_._v("CTRL_CMD_GETFAMILY")]),_._v(").")]),_._v(" "),e("p",[_._v("Чтобы получить информацию о названном семействе Generic Netlink, например, "),e("code",[_._v('"test1"')]),_._v("нам нужно отправить сообщение на ранее открытый сокет Generic Netlink. Сообщение должно быть нацелено на семейство Generic Netlink (1), быть "),e("code",[_._v("do")]),_._v("(2) вызовом "),e("code",[_._v("CTRL_CMD_GETFAMILY")]),_._v("(3). Версия "),e("code",[_._v("dump")]),_._v("этого вызова заставит ядро ​​ответить информацией обо "),e("em",[_._v("всех")]),_._v(" известных ему семействах. И последнее, но не менее важное: имя рассматриваемого семейства должно быть указано (4) в качестве атрибута соответствующего типа:")]),_._v(" "),e("p",[_._v("struct nlmsghdr:\n__u32 nlmsg_len:    32\n__u16 nlmsg_type:   GENL_ID_CTRL               // (1)\n__u16 nlmsg_flags:  NLM_F_REQUEST | NLM_F_ACK  // (2)\n__u32 nlmsg_seq:    1\n__u32 nlmsg_pid:    0")]),_._v(" "),e("p",[_._v("struct genlmsghdr:\n__u8 cmd:           CTRL_CMD_GETFAMILY         // (3)\n__u8 version:       2 /* or 1, doesn't matter */\n__u16 reserved:     0")]),_._v(" "),e("p",[_._v("struct nlattr:                                   // (4)\n__u16 nla_len:      10\n__u16 nla_type:     CTRL_ATTR_FAMILY_NAME\nchar data:          test1\\0")]),_._v(" "),e("p",[_._v("(padding:)\nchar data:          \\0\\0")]),_._v(" "),e("p",[_._v("Поля длины в Netlink ( "),e("code",[_._v("nlmsghdr.nlmsg_len")]),_._v(" и "),e("code",[_._v("nlattr.nla_len")]),_._v(") всегда "),e("em",[_._v("включают")]),_._v(" заголовок. Заголовки атрибутов в netlink должны быть выровнены по 4 байтам от начала сообщения, поэтому "),e("code",[_._v("\\0\\0")]),_._v("после "),e("code",[_._v("CTRL_ATTR_FAMILY_NAME")]),_._v(". Длины атрибутов "),e("em",[_._v("исключают")]),_._v(" заполнение.")]),_._v(" "),e("p",[_._v("Если семейство найдено, ядро ​​ответит двумя сообщениями со всей информацией о семействе:")]),_._v(" "),e("p",[_._v("/* Message #1 - reply "),e("em",[_._v("/\nstruct nlmsghdr:\n__u32 nlmsg_len:    136\n__u16 nlmsg_type:   GENL_ID_CTRL\n__u16 nlmsg_flags:  0\n__u32 nlmsg_seq:    1    /")]),_._v(" echoed from our request "),e("em",[_._v("/\n__u32 nlmsg_pid:    5831 /")]),_._v(" The PID of our user space process */")]),_._v(" "),e("p",[_._v("struct genlmsghdr:\n__u8 cmd:           CTRL_CMD_GETFAMILY\n__u8 version:       2\n__u16 reserved:     0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      10\n__u16 nla_type:     CTRL_ATTR_FAMILY_NAME\nchar data:          test1\\0")]),_._v(" "),e("p",[_._v("(padding:)\ndata:               \\0\\0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      6\n__u16 nla_type:     CTRL_ATTR_FAMILY_ID\n__u16:              123  /* The Family ID we are after */")]),_._v(" "),e("p",[_._v("(padding:)\nchar data:          \\0\\0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      9\n__u16 nla_type:     CTRL_ATTR_FAMILY_VERSION\n__u16:              1")]),_._v(" "),e("p",[_._v("/* ... etc, more attributes will follow. */")]),_._v(" "),e("p",[_._v("И код ошибки (успех) с тех пор "),e("code",[_._v("NLM_F_ACK")]),_._v("был установлен по запросу:")]),_._v(" "),e("p",[_._v("/* Message #2 - the ACK "),e("em",[_._v("/\nstruct nlmsghdr:\n__u32 nlmsg_len:    36\n__u16 nlmsg_type:   NLMSG_ERROR\n__u16 nlmsg_flags:  NLM_F_CAPPED /")]),_._v(" There won't be a payload "),e("em",[_._v("/\n__u32 nlmsg_seq:    1    /")]),_._v(" echoed from our request "),e("em",[_._v("/\n__u32 nlmsg_pid:    5831 /")]),_._v(" The PID of our user space process */")]),_._v(" "),e("p",[_._v("int error:            0")]),_._v(" "),e("p",[_._v("struct nlmsghdr: /* Copy of the request header as we sent it */\n__u32 nlmsg_len:    32\n__u16 nlmsg_type:   GENL_ID_CTRL\n__u16 nlmsg_flags:  NLM_F_REQUEST | NLM_F_ACK\n__u32 nlmsg_seq:    1\n__u32 nlmsg_pid:    0")]),_._v(" "),e("p",[_._v("Порядок атрибутов (struct nlattr) не гарантируется, поэтому пользователю приходится просматривать атрибуты и анализировать их.")]),_._v(" "),e("p",[_._v("Обратите внимание, что сокеты Generic Netlink не связаны и не привязаны к одному семейству. Сокет можно использовать для обмена сообщениями со многими различными семействами, выбирая семейство получателей для каждого сообщения с помощью поля "),e("code",[_._v("nlmsghdr.nlmsg_type")]),_._v(".")]),_._v(" "),e("h3",{attrs:{id:"расширенныи-ack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#расширенныи-ack"}},[_._v("#")]),_._v(" Расширенный ACK "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#extended-ack",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Расширенный ACK управляет отчетами о дополнительных ошибках/предупреждениях TLV в "),e("code",[_._v("NLMSG_ERROR")]),_._v("сообщениях "),e("code",[_._v("NLMSG_DONE")]),_._v(". Для обеспечения обратной совместимости эту функцию необходимо явно включить, установив "),e("code",[_._v("NETLINK_EXT_ACK")]),_._v("для setsockopt() значение "),e("code",[_._v("1")]),_._v(".")]),_._v(" "),e("p",[_._v("Типы расширенных атрибутов ack определены в . Наиболее часто используемые атрибуты , и ."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsgerr_attrs",title:"nlmsgerr_attrs",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("enum nlmsgerr_attrs")]),e("OutboundLink")],1),e("code",[_._v("NLMSGERR_ATTR_MSG``NLMSGERR_ATTR_OFFS``NLMSGERR_ATTR_MISS_*")])]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MSG")]),_._v("содержит сообщение на английском языке с описанием возникшей проблемы. Эти сообщения гораздо более подробны, чем то, что может быть выражено с помощью стандартных кодов ошибок UNIX.")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_OFFS")]),_._v("указывает на атрибут, вызвавший проблему.")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MISS_TYPE")]),_._v("и "),e("code",[_._v("NLMSGERR_ATTR_MISS_NEST")]),_._v(" сообщить об отсутствующем атрибуте.")]),_._v(" "),e("p",[_._v("Расширенные ACK могут сообщаться об ошибках, а также в случае успеха. Последнее следует рассматривать как предупреждение.")]),_._v(" "),e("p",[_._v("Расширенные ACK значительно повышают удобство использования Netlink и всегда должны быть включены, должным образом анализироваться и сообщаться пользователю.")]),_._v(" "),e("h2",{attrs:{id:"дополнительные-темы"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#дополнительные-темы"}},[_._v("#")]),_._v(" Дополнительные темы "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#advanced-topics",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("h3",{attrs:{id:"согласованность-дампа"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#согласованность-дампа"}},[_._v("#")]),_._v(" Согласованность дампа "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#dump-consistency",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Некоторые структуры данных, используемые ядром для хранения объектов, затрудняют предоставление атомарного снимка всех объектов в дампе (без влияния на быстрые пути их обновления).")]),_._v(" "),e("p",[_._v("Ядро может установить "),e("code",[_._v("NLM_F_DUMP_INTR")]),_._v("флаг для любого сообщения в дампе (включая "),e("code",[_._v("NLMSG_DONE")]),_._v("сообщение), если дамп был прерван и может быть несогласованным (например, отсутствующие объекты). Пользовательское пространство должно повторить попытку создания дампа, если оно увидит установленный флаг.")]),_._v(" "),e("h3",{attrs:{id:"самоанализ"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#самоанализ"}},[_._v("#")]),_._v(" Самоанализ "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#introspection",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Основные возможности самоанализа активируются при доступе к объекту «Семья», как указано в "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#res-fam",target:"_blank",rel:"noopener noreferrer"}},[_._v("разделе «Разрешение идентификатора семьи»"),e("OutboundLink")],1),_._v(" . Пользователь может запросить информацию о семействе Generic Netlink, в том числе о том, какие операции поддерживаются ядром и какие атрибуты понимает ядро. Информация о семействе включает самый высокий идентификатор атрибута, который может анализировать ядро, отдельная команда ( "),e("code",[_._v("CTRL_CMD_GETPOLICY")]),_._v(") предоставляет подробную информацию о поддерживаемых атрибутах, включая диапазоны значений, которые принимает ядро.")]),_._v(" "),e("p",[_._v("Запрос информации о семействе полезен в тех случаях, когда пользовательскому пространству необходимо убедиться, что ядро ​​​​поддерживает какую-либо функцию, прежде чем выдавать запрос.")]),_._v(" "),e("h3",{attrs:{id:"nlmsg-pid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nlmsg-pid"}},[_._v("#")]),_._v(" nlmsg_pid "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#nlmsg-pid",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[e("code",[_._v("nlmsghdr.nlmsg_pid")]),_._v("является Netlink-эквивалентом адреса. Он называется идентификатором порта, иногда идентификатором процесса, потому что по историческим причинам, если приложение не выбирает (bind() to) явный идентификатор порта, ядро ​​автоматически назначит ему идентификатор, равный его идентификатору процесса (как сообщает getpid( ) системный вызов).")]),_._v(" "),e("p",[_._v("Подобно семантике bind() сетевых протоколов TCP/IP, нулевое значение означает «назначать автоматически», поэтому приложения обычно оставляют поле "),e("code",[_._v("nlmsghdr.nlmsg_pid")]),_._v("инициализированным до "),e("code",[_._v("0")]),_._v(".")]),_._v(" "),e("p",[_._v("Поле до сих пор используется в редких случаях, когда ядру необходимо отправить одноадресное уведомление. Приложение пользовательского пространства может использовать bind(), чтобы связать свой сокет с определенным PID, а затем передать свой PID ядру. Таким образом ядро ​​​​может получить доступ к конкретному процессу пользовательского пространства.")]),_._v(" "),e("p",[_._v("Этот тип связи используется в сценариях, подобных UMH (User Mode Helper), когда ядру необходимо инициировать обработку пользовательского пространства или запрашивать пользовательское пространство для решения политики.")]),_._v(" "),e("h3",{attrs:{id:"многоадресные-уведомления"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#многоадресные-уведомления"}},[_._v("#")]),_._v(" Многоадресные уведомления "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#multicast-notifications",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Одной из сильных сторон Netlink является возможность отправки уведомлений о событиях в пространство пользователя. Это однонаправленная форма связи (ядро -> пользователь) и не включает никаких управляющих сообщений, таких как "),e("code",[_._v("NLMSG_ERROR")]),_._v("или "),e("code",[_._v("NLMSG_DONE")]),_._v(".")]),_._v(" "),e("p",[_._v("Например, само семейство Generic Netlink определяет набор многоадресных уведомлений о зарегистрированных семействах. При добавлении нового семейства сокеты, подписанные на уведомления, получат следующее сообщение:")]),_._v(" "),e("p",[_._v("struct nlmsghdr:\n__u32 nlmsg_len:    136\n__u16 nlmsg_type:   GENL_ID_CTRL\n__u16 nlmsg_flags:  0\n__u32 nlmsg_seq:    0\n__u32 nlmsg_pid:    0")]),_._v(" "),e("p",[_._v("struct genlmsghdr:\n__u8 cmd:           CTRL_CMD_NEWFAMILY\n__u8 version:       2\n__u16 reserved:     0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      10\n__u16 nla_type:     CTRL_ATTR_FAMILY_NAME\nchar data:          test1\\0")]),_._v(" "),e("p",[_._v("(padding:)\ndata:               \\0\\0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      6\n__u16 nla_type:     CTRL_ATTR_FAMILY_ID\n__u16:              123  /* The Family ID we are after */")]),_._v(" "),e("p",[_._v("(padding:)\nchar data:          \\0\\0")]),_._v(" "),e("p",[_._v("struct nlattr:\n__u16 nla_len:      9\n__u16 nla_type:     CTRL_ATTR_FAMILY_VERSION\n__u16:              1")]),_._v(" "),e("p",[_._v("/* ... etc, more attributes will follow. */")]),_._v(" "),e("p",[_._v("Уведомление содержит ту же информацию, что и ответ на "),e("code",[_._v("CTRL_CMD_GETFAMILY")]),_._v("запрос.")]),_._v(" "),e("p",[_._v("Заголовки Netlink уведомления в основном равны 0 и не имеют значения. Может "),e("code",[_._v("nlmsghdr.nlmsg_seq")]),_._v("быть либо нулем, либо монотонно возрастающим порядковым номером уведомления, поддерживаемым семейством.")]),_._v(" "),e("p",[_._v("Для получения уведомлений пользовательский сокет должен подписаться на соответствующую группу уведомлений. Как и идентификатор семьи, идентификатор группы для данной многоадресной группы является динамическим и может быть найден в информации о семье. Атрибут "),e("code",[_._v("CTRL_ATTR_MCAST_GROUPS")]),_._v("содержит гнезда с именами ( "),e("code",[_._v("CTRL_ATTR_MCAST_GRP_NAME")]),_._v(") и идентификаторами ( "),e("code",[_._v("CTRL_ATTR_MCAST_GRP_ID")]),_._v(") семейства групп.")]),_._v(" "),e("p",[_._v("Как только идентификатор группы известен, вызов setsockopt() добавляет сокет в группу:")]),_._v(" "),e("p",[_._v("unsigned int group_id;")]),_._v(" "),e("p",[_._v("/* .. find the group ID... */")]),_._v(" "),e("p",[_._v("setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP,\n&group_id, sizeof(group_id));")]),_._v(" "),e("p",[_._v("Сокет теперь будет получать уведомления.")]),_._v(" "),e("p",[_._v("Рекомендуется использовать отдельные сокеты для получения уведомлений и отправки запросов к ядру. Асинхронный характер уведомлений означает, что они могут смешиваться с ответами, что значительно усложняет обработку сообщений.")]),_._v(" "),e("h3",{attrs:{id:"размер-буфера"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#размер-буфера"}},[_._v("#")]),_._v(" Размер буфера "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#buffer-sizing",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Сокеты Netlink — это сокеты дейтаграмм, а не потоковые сокеты, что означает, что каждое сообщение должно быть получено полностью с помощью одного системного вызова recv()/recvmsg(). Если предоставленный пользователем буфер слишком короткий, сообщение будет усечено, а флаг "),e("code",[_._v("MSG_TRUNC")]),_._v("будет установлен в структуре msghdr (структура msghdr является вторым аргументом системного вызова recvmsg(), "),e("em",[_._v("а не")]),_._v(" заголовком Netlink).")]),_._v(" "),e("p",[_._v("После усечения оставшаяся часть сообщения отбрасывается.")]),_._v(" "),e("p",[_._v("Netlink ожидает, что пользовательский буфер будет не менее 8 КБ или размер страницы архитектуры ЦП, в зависимости от того, что больше. Однако некоторым семействам Netlink может потребоваться буфер большего размера. Буфер размером 32 КБ рекомендуется для наиболее эффективной обработки дампов (больший буфер подходит для большего количества объектов дампа и, следовательно, требуется меньше вызовов recvmsg()).")]),_._v(" "),e("h2",{attrs:{id:"классическии-нетлинк"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#классическии-нетлинк"}},[_._v("#")]),_._v(" Классический нетлинк "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#classic-netlink",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Основными отличиями между Classic и Generic Netlink являются динамическое выделение идентификаторов подсистем и доступность самоанализа. Теоретически протокол существенно не отличается, однако на практике Classic Netlink экспериментировал с концепциями, от которых отказались в Generic Netlink (на самом деле они обычно находили применение только в небольшом уголке одной подсистемы). Этот раздел предназначен для объяснения некоторых из таких концепций с явной целью дать пользователям Generic Netlink уверенность в том, что они будут игнорировать их при чтении заголовков uAPI.")]),_._v(" "),e("p",[_._v("Большинство понятий и примеров здесь относятся к "),e("code",[_._v("NETLINK_ROUTE")]),_._v("семейству, которое охватывает большую часть конфигурации сетевого стека Linux. Реальная документация этого семейства заслуживает отдельной главы (или книги).")]),_._v(" "),e("h3",{attrs:{id:"семьи"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#семьи"}},[_._v("#")]),_._v(" Семьи "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#families",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Netlink относится к подсистемам как к семействам. Это пережиток использования сокетов и концепции семейств протоколов, которые являются частью демультиплексирования сообщений в "),e("code",[_._v("NETLINK_ROUTE")]),_._v(".")]),_._v(" "),e("p",[_._v("К сожалению, каждый уровень инкапсуляции любит называть все, что он несет, «семействами», что делает этот термин очень запутанным:")]),_._v(" "),e("blockquote",[e("ol",[e("li",[e("p",[_._v("AF_NETLINK — это добросовестное семейство протоколов сокетов.")])]),_._v(" "),e("li",[e("p",[_._v("В документации AF_NETLINK то, что идет после собственного заголовка ( ) в сообщении, называется «семейным заголовком»."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1)])]),_._v(" "),e("li",[e("p",[_._v("Generic Netlink — это семейство для AF_NETLINK (следует структура genlmsghdr ), но оно также называет своих пользователей «Семействами»."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1)])])])]),_._v(" "),e("p",[_._v("Обратите внимание, что идентификаторы семейства Generic Netlink находятся в другом «пространстве идентификаторов» и перекрываются с номерами протокола Classic Netlink (например, "),e("code",[_._v("NETLINK_CRYPTO")]),_._v(" имеет идентификатор протокола Classic Netlink, равный 21, который Generic Netlink с радостью присвоит одному из своих семейств).")]),_._v(" "),e("h3",{attrs:{id:"строгая-проверка"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#строгая-проверка"}},[_._v("#")]),_._v(" Строгая проверка "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#strict-checking",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Опция "),e("code",[_._v("NETLINK_GET_STRICT_CHK")]),_._v("socket включает строгую проверку ввода "),e("code",[_._v("NETLINK_ROUTE")]),_._v(". Это было необходимо, потому что исторически ядро ​​не проверяло поля структур, которые оно не обрабатывало. Это сделало невозможным начать использовать эти поля позже, не рискуя регрессией в приложениях, которые инициализировали их неправильно или вообще не инициализировали.")]),_._v(" "),e("p",[e("code",[_._v("NETLINK_GET_STRICT_CHK")]),_._v("объявляет, что приложение правильно инициализирует все поля. Он также выбирает проверку того, что сообщение не содержит завершающих данных, и запрашивает, чтобы ядро ​​​​отклоняло атрибуты с типом выше, чем самый большой тип атрибута, известный ядру.")]),_._v(" "),e("p",[e("code",[_._v("NETLINK_GET_STRICT_CHK")]),_._v("не используется вне "),e("code",[_._v("NETLINK_ROUTE")]),_._v(".")]),_._v(" "),e("h3",{attrs:{id:"неизвестные-атрибуты"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#неизвестные-атрибуты"}},[_._v("#")]),_._v(" Неизвестные атрибуты "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#unknown-attributes",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Исторически Netlink игнорировал все неизвестные атрибуты. Мысль заключалась в том, что это избавит приложение от необходимости проверять, что поддерживает ядро. Приложение могло сделать запрос на изменение состояния и проверить, какие части запроса «зависли».")]),_._v(" "),e("p",[_._v("Это больше не относится к новым семействам Generic Netlink и тем, кто выбирает строгую проверку. См. enum netlink_validation для типов выполненных проверок.")]),_._v(" "),e("h3",{attrs:{id:"фиксированные-метаданные-и-структуры"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#фиксированные-метаданные-и-структуры"}},[_._v("#")]),_._v(" Фиксированные метаданные и структуры "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#fixed-metadata-and-structures",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Классический Netlink широко использовал структуры фиксированного формата в сообщениях. Сообщения обычно имеют структуру со значительным количеством полей после . Также было принято размещать структуры с несколькими элементами внутри атрибутов, не разбивая каждый элемент на отдельный атрибут."),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Это вызвало проблемы с проверкой и расширяемостью, поэтому использование двоичных структур для новых атрибутов активно не рекомендуется.")]),_._v(" "),e("h3",{attrs:{id:"типы-запросов"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#типы-запросов"}},[_._v("#")]),_._v(" Типы запросов "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#request-types",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[e("code",[_._v("NETLINK_ROUTE")]),_._v("классифицирует запросы на 4 типа "),e("code",[_._v("NEW")]),_._v(", "),e("code",[_._v("DEL")]),_._v(", "),e("code",[_._v("GET")]),_._v("и "),e("code",[_._v("SET")]),_._v(". Каждый объект может обрабатывать все или некоторые из этих запросов (объектами являются netdev, маршруты, адреса, qdisc и т. д.). Тип запроса определяется двумя младшими битами типа сообщения, поэтому команды для новых объектов всегда будут выделяться с шагом 4.")]),_._v(" "),e("p",[_._v("Каждый объект также будет иметь собственные фиксированные метаданные, общие для всех типов запросов (например, struct ifinfomsg для запросов netdev, struct ifaddrmsg для запросов адреса, struct tcmsg для запросов qdisc).")]),_._v(" "),e("p",[_._v("Несмотря на то, что другие протоколы и команды Generic Netlink часто используют одни и те же глаголы в именах сообщений ( "),e("code",[_._v("GET")]),_._v(", "),e("code",[_._v("SET")]),_._v("), концепция типов запросов не нашла широкого применения.")]),_._v(" "),e("h3",{attrs:{id:"эхо-уведомление"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#эхо-уведомление"}},[_._v("#")]),_._v(" Эхо-уведомление "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#notification-echo",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[e("code",[_._v("NLM_F_ECHO")]),_._v("запросы на уведомления, полученные в результате запроса, должны быть поставлены в очередь на запрашивающий сокет. Это полезно для обнаружения влияния запроса.")]),_._v(" "),e("p",[_._v("Обратите внимание, что эта функция реализована не повсеместно.")]),_._v(" "),e("h3",{attrs:{id:"другие-флаги-специфичные-для-типа-запроса"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#другие-флаги-специфичные-для-типа-запроса"}},[_._v("#")]),_._v(" Другие флаги, специфичные для типа запроса "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#other-request-type-specific-flags",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Классический Netlink определил различные флаги для своих "),e("code",[_._v("GET")]),_._v("и запросов в старшем байте nlmsg_flags в . Поскольку типы запросов не были обобщены, флаги конкретных типов запросов используются редко (и считаются устаревшими для новых семейств)."),e("code",[_._v("NEW``DEL")]),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"nlmsghdr",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("struct nlmsghdr")]),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("Ибо "),e("code",[_._v("GET")]),_._v("- "),e("code",[_._v("NLM_F_ROOT")]),_._v("и "),e("code",[_._v("NLM_F_MATCH")]),_._v("объединяются в "),e("code",[_._v("NLM_F_DUMP")]),_._v(", а по отдельности не употребляются. "),e("code",[_._v("NLM_F_ATOMIC")]),_._v("никогда не используется.")]),_._v(" "),e("p",[_._v("For "),e("code",[_._v("DEL")]),_._v("- "),e("code",[_._v("NLM_F_NONREC")]),_._v("используется только nftables и "),e("code",[_._v("NLM_F_BULK")]),_._v(" только некоторыми операциями FDB.")]),_._v(" "),e("p",[_._v("Флаги для "),e("code",[_._v("NEW")]),_._v("чаще всего используются в классическом Netlink. К сожалению, смысл не кристально ясен. Следующее описание основано на наилучшем предположении о замысле авторов, и на практике все семьи так или иначе отклоняются от него. "),e("code",[_._v("NLM_F_REPLACE")]),_._v("запрашивает замену существующего объекта, если совпадающий объект не существует, операция должна завершиться ошибкой. "),e("code",[_._v("NLM_F_EXCL")]),_._v("имеет противоположную семантику и завершается успешно только в том случае, если объект уже существует. "),e("code",[_._v("NLM_F_CREATE")]),_._v("просит создать объект, если он не существует, его можно комбинировать с "),e("code",[_._v("NLM_F_REPLACE")]),_._v("и "),e("code",[_._v("NLM_F_EXCL")]),_._v(".")]),_._v(" "),e("p",[_._v("Комментарий в основном заголовке Netlink uAPI гласит:")]),_._v(" "),e("p",[_._v("4.4BSD ADD           NLM_F_CREATE|NLM_F_EXCL\n4.4BSD CHANGE        NLM_F_REPLACE")]),_._v(" "),e("p",[_._v("True CHANGE          NLM_F_CREATE|NLM_F_REPLACE\nAppend               NLM_F_CREATE\nCheck                NLM_F_EXCL")]),_._v(" "),e("p",[_._v("что, по-видимому, указывает на то, что эти флаги предшествуют типам запросов. "),e("code",[_._v("NLM_F_REPLACE")]),_._v("без "),e("code",[_._v("NLM_F_CREATE")]),_._v("изначально использовалось вместо "),e("code",[_._v("SET")]),_._v("команд. "),e("code",[_._v("NLM_F_EXCL")]),_._v("без "),e("code",[_._v("NLM_F_CREATE")]),_._v("использовался для проверки существования объекта без его создания, предположительно до появления "),e("code",[_._v("GET")]),_._v("команд.")]),_._v(" "),e("p",[e("code",[_._v("NLM_F_APPEND")]),_._v("указывает, что если с одним ключом может быть связано несколько объектов (например, несколько объектов следующего перехода для маршрута), новый объект должен быть добавлен в список, а не заменять весь список.")]),_._v(" "),e("h2",{attrs:{id:"справочник-по-uapi"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#справочник-по-uapi"}},[_._v("#")]),_._v(" Справочник по uAPI "),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#uapi-reference",title:"Постоянная ссылка на этот заголовок",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("структура nlmsghdr"),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsghdr",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("заголовок метаданных фиксированного формата сообщений Netlink")]),_._v(" "),e("p",[e("strong",[_._v("Определение")]),_._v(" :")]),_._v(" "),e("p",[_._v("struct nlmsghdr {\n__u32 nlmsg_len;\n__u16 nlmsg_type;\n__u16 nlmsg_flags;\n__u32 nlmsg_seq;\n__u32 nlmsg_pid;\n};")]),_._v(" "),e("p",[e("strong",[_._v("Члены")])]),_._v(" "),e("p",[e("code",[_._v("nlmsg_len")])]),_._v(" "),e("p",[_._v("Длина сообщения, включая заголовок")]),_._v(" "),e("p",[e("code",[_._v("nlmsg_type")])]),_._v(" "),e("p",[_._v("Тип содержимого сообщения")]),_._v(" "),e("p",[e("code",[_._v("nlmsg_flags")])]),_._v(" "),e("p",[_._v("Дополнительные флаги")]),_._v(" "),e("p",[e("code",[_._v("nlmsg_seq")])]),_._v(" "),e("p",[_._v("Порядковый номер")]),_._v(" "),e("p",[e("code",[_._v("nlmsg_pid")])]),_._v(" "),e("p",[_._v("Отправка идентификатора порта процесса")]),_._v(" "),e("p",[_._v("перечисление nlmsgerr_attrs"),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsgerr_attrs",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.nlmsgerr_attrs",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("атрибуты nlmsgerr")]),_._v(" "),e("p",[e("strong",[_._v("Константы")])]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_UNUSED")])]),_._v(" "),e("p",[_._v("неиспользованный")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MSG")])]),_._v(" "),e("p",[_._v("строка сообщения об ошибке (строка)")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_OFFS")])]),_._v(" "),e("p",[_._v("смещение недопустимого атрибута в исходном сообщении, считая от начала заголовка (u32)")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_COOKIE")])]),_._v(" "),e("p",[_._v("произвольный файл cookie, специфичный для подсистемы, который будет использоваться - в случае успеха - для идентификации созданного объекта или операции или аналогичного (двоичного)")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_POLICY")])]),_._v(" "),e("p",[_._v("политика для отклоненного атрибута")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MISS_TYPE")])]),_._v(" "),e("p",[_._v("тип отсутствующего обязательного атрибута, "),e("code",[_._v("NLMSGERR_ATTR_MISS_NEST")]),_._v("не будет присутствовать, если атрибут отсутствовал на уровне сообщения")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MISS_NEST")])]),_._v(" "),e("p",[_._v("смещение гнезда, где отсутствовал атрибут")]),_._v(" "),e("p",[e("code",[_._v("__NLMSGERR_ATTR_MAX")])]),_._v(" "),e("p",[_._v("количество атрибутов")]),_._v(" "),e("p",[e("code",[_._v("NLMSGERR_ATTR_MAX")])]),_._v(" "),e("p",[_._v("наивысший номер атрибута")]),_._v(" "),e("p",[_._v("enum netlink_attribute_type"),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.netlink_attribute_type",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.netlink_attribute_type",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("тип атрибута")]),_._v(" "),e("p",[e("strong",[_._v("Константы")])]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_INVALID")])]),_._v(" "),e("p",[_._v("неиспользованный")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_FLAG")])]),_._v(" "),e("p",[_._v("атрибут флага (присутствует/отсутствует)")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_U8")])]),_._v(" "),e("p",[_._v("8-битный беззнаковый атрибут")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_U16")])]),_._v(" "),e("p",[_._v("16-битный беззнаковый атрибут")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_U32")])]),_._v(" "),e("p",[_._v("32-битный беззнаковый атрибут")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_U64")])]),_._v(" "),e("p",[_._v("64-битный беззнаковый атрибут")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_S8")])]),_._v(" "),e("p",[_._v("8-битный атрибут со знаком")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_S16")])]),_._v(" "),e("p",[_._v("16-битный атрибут со знаком")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_S32")])]),_._v(" "),e("p",[_._v("32-битный атрибут со знаком")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_S64")])]),_._v(" "),e("p",[_._v("64-битный атрибут со знаком")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_BINARY")])]),_._v(" "),e("p",[_._v("двоичные данные, минимальная/максимальная длина может быть указана")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_STRING")])]),_._v(" "),e("p",[_._v("строка, минимальная/максимальная длина может быть указана")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_NUL_STRING")])]),_._v(" "),e("p",[_._v("Строка с нулевым завершением, может быть указана минимальная/максимальная длина")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_NESTED")])]),_._v(" "),e("p",[_._v("вложенный, т.е. содержимое этого атрибута состоит из податрибутов. Вложенная политика и maxtype внутри могут быть указаны.")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_NESTED_ARRAY")])]),_._v(" "),e("p",[_._v("вложенный массив, т. е. содержимое этого атрибута содержит вложенные атрибуты, тип которых не имеет значения (просто используется для разделения элементов массива), и каждый такой элемент массива снова имеет атрибуты, может быть указана политика для этих внутренних атрибутов и соответствующий maxtype.")]),_._v(" "),e("p",[e("code",[_._v("NL_ATTR_TYPE_BITFIELD32")])]),_._v(" "),e("p",[e("code",[_._v("struct nla_bitfield32")]),_._v("атрибут")]),_._v(" "),e("p",[_._v("enum netlink_policy_type_attr"),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.netlink_policy_type_attr",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.netlink_policy_type_attr",title:"Постоянная ссылка на это определение",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("атрибуты типа политики")]),_._v(" "),e("p",[e("strong",[_._v("Константы")])]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_UNSPEC")])]),_._v(" "),e("p",[_._v("неиспользованный")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_TYPE")])]),_._v(" "),e("p",[_._v("тип атрибута, (U32)"),e("a",{attrs:{href:"https://kernel.org/doc/html/next/userspace-api/netlink/intro.html#c.netlink_attribute_type",title:"netlink_attribute_type",target:"_blank",rel:"noopener noreferrer"}},[e("code",[_._v("enum netlink_attribute_type")]),e("OutboundLink")],1)]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MIN_VALUE_S")])]),_._v(" "),e("p",[_._v("минимальное значение для целых чисел со знаком (S64)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MAX_VALUE_S")])]),_._v(" "),e("p",[_._v("максимальное значение для целых чисел со знаком (S64)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MIN_VALUE_U")])]),_._v(" "),e("p",[_._v("минимальное значение для целых чисел без знака (U64)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MAX_VALUE_U")])]),_._v(" "),e("p",[_._v("максимальное значение для целых чисел без знака (U64)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MIN_LENGTH")])]),_._v(" "),e("p",[_._v("минимальная длина для бинарных атрибутов, без минимальной длины, если она не указана (U32)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MAX_LENGTH")])]),_._v(" "),e("p",[_._v("максимальная длина для бинарных атрибутов, максимума нет, если он не указан (U32)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_POLICY_IDX")])]),_._v(" "),e("p",[_._v("подполитика для вложенных и вложенных типов массивов (U32)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE")])]),_._v(" "),e("p",[_._v("максимальный атрибут подполитики для вложенных и вложенных типов массивов, теоретически он может быть < размера политики, на которую указывает индекс, если он ограничен внутри вложенности (U32)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_BITFIELD32_MASK")])]),_._v(" "),e("p",[_._v("допустимая маска для типа bitfield32 (U32)")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_PAD")])]),_._v(" "),e("p",[_._v("атрибут pad для 64-битного выравнивания")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MASK")])]),_._v(" "),e("p",[_._v("маска допустимых битов для целых чисел без знака (U64)")]),_._v(" "),e("p",[e("code",[_._v("__NL_POLICY_TYPE_ATTR_MAX")])]),_._v(" "),e("p",[_._v("количество атрибутов")]),_._v(" "),e("p",[e("code",[_._v("NL_POLICY_TYPE_ATTR_MAX")])]),_._v(" "),e("p",[_._v("наивысший номер атрибута")])])}),[],!1,null,null,null);e.default=r.exports}}]);