(window.webpackJsonp=window.webpackJsonp||[]).push([[257],{526:function(e,n,t){"use strict";t.r(n);var r=t(14),s=Object(r.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("div",{pre:!0},[n("p",[e._v("https://habr.com/ru/articles/337046/")]),e._v(" "),n("p",[e._v("Порой при разработке API случается так, что необходимо не только лишь получать данные, но и вносить определенные изменения. Именно для этой цели существует то, что в GraphQL называется странным словом "),n("a",{pre:!0,attrs:{href:"http://graphql.org/learn/queries/#mutations",target:"_blank",rel:"noopener noreferrer"}},[e._v('"мутация"'),n("OutboundLink",{pre:!0})],1),e._v(".")]),e._v(" "),n("h2",{pre:!0,attrs:{id:"сервер"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#сервер"}},[e._v("#")]),e._v(" Сервер")]),e._v(" "),n("p",[e._v("Вдоволь наигравшись с клиентской частью, вернемся таки к нашему серверу и добавим несколько мутаций. Для мутаций нам необходимо иметь отдельную от query точку входа (MutationType), а сам функционал реализуется через параметры полей args и resolve.")]),e._v(" "),n("p",[n("em",[e._v("Вопрос: Могу ли я реализовать мутации через поля секции query?")]),e._v(" Хороший вопрос. Дело в том, что гипотетически это возможно, но архитектурно неправильно. А еще библиотека Apollo любит делать корневой запрос, т.е. имея всю структуру, запрашивает все, что возможно. Зачем она это делает, я не знаю, но предположительно, если засунуть в query методы вроде delete(), можете случайно лишиться ценного.")]),e._v(" "),n("h3",{pre:!0,attrs:{id:"шаг-1-создадим-необходимые-типы"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-1-создадим-необходимые-типы"}},[e._v("#")]),e._v(" Шаг 1. Создадим необходимые типы")]),e._v(" "),n("p",[e._v("/schema/mutations/UserMutationType.php:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema\\mutations;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse app\\models\\User;\n\nclass UserMutationType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    // для теста реализуем здесь\n                    // один метод для изменения данных\n                    // объекта User\n                    'update' => [\n                        // какой должен быть возвращаемый тип\n                        // здесь 2 варианта - либо\n                        // булев - удача / неудача\n                        // либо же сам объект типа User.\n                        // позже мы поговорим о валидации\n                        // тогда всё станет яснее, а пока\n                        // оставим булев для простоты\n                        'type' => Type::boolean(),\n                        'description' => 'Update user data.',\n                        'args' => [\n                            // сюда засунем все то, что\n                            // разрешаем изменять у User.\n                            // в примере оставим все поля необязательными\n                            // но просто если нужно, то можно\n                            'firstname' => Type::string(),\n                            'lastname' => Type::string(),\n                            'status' => Type::int(),\n                        ],\n                        'resolve' => function(User $user, $args) {\n                            // ну а здесь всё проще простого,\n                            // т.к. библиотека уже все проверила за нас:\n                            // есть ли у нас юзер, правильные ли у нас\n                            // аргументы и всё ли пришло, что необходимо\n                            $user->setAttributes($args);\n                            return $user->save();\n                        }\n                    ],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n}\n")])])]),n("p",[n("em",[e._v("Совет. Старайтесь делать ваши функции resolve() как можно менее нагруженными. Как видите, GraphQL позволяет это сделать максимально. Переносите максимально всю логику в модели. Схема и API это лишь связующее звено между клиентом и сервером. Этот принцип касается не только GraphQL, а и любой серверной архитектуры.")])]),e._v(" "),n("p",[e._v("Аналогично /schema/mutations/AddressMutationType.php:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema\\mutations;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse app\\models\\Address;\nuse app\\schema\\Types;\n\nclass AddressMutationType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    'update' => [\n                        'type' => Type::boolean(),\n                        'description' => 'Update address.',\n                        'args' => [\n                            'street' => Type::string(),\n                            'zip' => Type::string(),\n                            'status' => Type::int(),\n                        ],\n                        'resolve' => function(Address $address, $args) {\n                            $address->setAttributes($args);\n                            return $address->save();\n                        },\n                    ],\n\n                    // так как у нас адрес имеет поле \n                    // user, то можем позволить редактировать\n                    // его прямо отсюда\n                    // как именно, посмотрим на этапе тестирования\n                    'user' => [\n                        'type' => Types::userMutation(),\n                        'description' => 'Edit user directly from his address',\n                        // а вот поле relove должно возвращать\n                        // что, как думаете?\n                        'resolve' => function(Address $address) {\n                            // именно!\n                            // юзера из связки нашего адреса\n                            // (кстати, если связка окажется пуста -\n                            // не страшно, GraphQL, все это корректно\n                            // кушает, а вот если она окажется типа\n                            // отличного от User, тогда он скажет, что мол\n                            // что-то пошло не так)\n                            return $address->user;\n                        }\n                    ],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n}\n")])])]),n("p",[e._v("Во время разработки своего сервера, внимательно следите за тем, чтоб не использовать мутацию для выборки, или query для изменения данных, потому что жесткой привязки, как таковой нет.")]),e._v(" "),n("p",[e._v("Ну и корневой тип: /schema/MutationType.php:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("<?php\n\nnamespace app\\schema;\n\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse app\\models\\User;\nuse app\\models\\Address;\n\nclass MutationType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'fields' => function() {\n                return [\n                    'user' => [\n                        'type' => Types::userMutation(),\n                        'args' => [\n                            'id' => Type::nonNull(Type::int()),\n                        ],\n                        'resolve' => function($root, $args) {\n                            return User::find()->where($args)->one();\n                        },\n                    ],\n                    'address' => [\n                        'type' => Types::addressMutation(),\n                        'args' => [\n                            'id' => Type::nonNull(Type::int()),\n                        ],\n                        'resolve' => function($root, $args) {\n                            return Address::find()->where($args)->one();\n                        },\n                    ],\n                ];\n            }\n        ];\n\n        parent::__construct($config);\n    }\n}\n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-2-добавим-созданные-типы-types-php"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-2-добавим-созданные-типы-types-php"}},[e._v("#")]),e._v(" Шаг 2. Добавим созданные типы Types.php")]),e._v(" "),n("p",[e._v("Если вы заметили, на прошлом шаге мы уже использовали кастомные типы из Types, хотя еще и не создали их. Этим собственно сейчас и займемся.")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("... \n\n// т.к. наши мутации в другом неймспейсе\n// необходимо их подключить\nuse app\\schema\\mutations\\UserMutationType;\nuse app\\schema\\mutations\\AddressMutationType;\n\n... \n\n    private static $userMutation;\n    private static $addressMutation;\n\n... \n\n    public static function mutation()\n    {\n        return self::$mutation ?: (self::$mutation = new MutationType());\n    }\n\n    public static function userMutation()\n    {\n        return self::$userMutation ?: (self::$userMutation = new UserMutationType());\n    }\n\n    public static function addressMutation()\n    {\n        return self::$addressMutation ?: (self::$addressMutation = new AddressMutationType());\n    }\n\n... \n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-3-добавим-корневои-тип-в-точку-входа-graphqlcontroller-php"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-3-добавим-корневои-тип-в-точку-входа-graphqlcontroller-php"}},[e._v("#")]),e._v(" Шаг 3. Добавим корневой тип в точку входа GraphqlController.php")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("... \n        $schema = new Schema([\n            'query' => Types::query(),\n            'mutation' => Types::mutation(),\n        ]);\n... \n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-4-тестируем"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-4-тестируем"}},[e._v("#")]),e._v(" Шаг 4. Тестируем")]),e._v(" "),n("p",[e._v("Откроем же наш GraphiQL (а в соседней вкладке наш новосозданный клиент, чтобы убедиться, что данные таки меняются) и посмотрим на результат:")]),e._v(" "),n("p",[e._v("Запрос:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v('mutation {\n  user(id:1) {\n    update(firstname:"Stan")\n  }\n}\n')])])]),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/81e/238/112/81e2381129bfe4fe7b01319ade1ae98a.png",alt:"image"}})]),e._v(" "),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/c52/762/592/c52762592c250e00128c9e124668b437.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Теперь попробуем изменить адрес и привязанного к нему юзера одним запросом:")]),e._v(" "),n("p",[e._v("Запрос:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v('mutation {\n  address(id:0) {\n    update(zip: "56844")\n    user {\n        update(firstname:"Michael")\n    }\n  }\n}\n')])])]),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/982/61f/c2c/98261fc2cf7ede5125f335f1be4ddea2.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Чтобы увидеть изменения адреса, немного изменим наш шаблон:")]),e._v(" "),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/712/0f0/7a0/7120f07a08b98f6059c109913aeb04e2.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Сразу попытаемся представить и сравнить с тем, как нужно изощриться, чтоб провернуть что-то подобное в RESTful архитектуре. А вообще, подобные вещи, насколько мне известно, перечат концепции REST-а, а в GraphQL это изначально заложено архитектурно.")]),e._v(" "),n("h2",{pre:!0,attrs:{id:"переменные"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#переменные"}},[e._v("#")]),e._v(" Переменные")]),e._v(" "),n("p",[e._v("Пока мы не перешли к клиенту разберемся что такое "),n("a",{pre:!0,attrs:{href:"http://graphql.org/learn/queries/#variables",target:"_blank",rel:"noopener noreferrer"}},[e._v("variables в GraphQL"),n("OutboundLink",{pre:!0})],1),e._v(". С практическим их применением вы познакомитесь при использовании в мутациях в клиенте, а пока не заморачивайтесь над этим, т.к. изначально их польза не так заметна.")]),e._v(" "),n("p",[e._v("Изменим немного нашу мутацию с использованием переменных:")]),e._v(" "),n("p",[e._v("Запрос:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("mutation ($id:Int, $zip: String, $firstname: String) {\n  address(id: $id) {\n    update(zip: $zip)\n    user {\n        update(firstname: $firstname)\n    }\n  }\n}\n")])])]),n("p",[e._v("Переменные:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v('{\n  "id": 1,\n  "zip": "87444",\n  "firstname": "Steve"\n}\n')])])]),n("p",[n("em",[e._v("Примечание. Технически, переменные приходят отдельным POST-параметром variables.")])]),e._v(" "),n("p",[e._v("Окно GraphiQL (поле для ввода переменных нужно просто вытянуть снизу, да, оно у вас тоже есть):")]),e._v(" "),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/417/87d/24a/41787d24a70b32a82d0792e9c83dc361.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Может показаться, что переменные удобны, когда в нескольких местах используется одно и то же значение, но на самом деле, на практике это редкая ситуация, и нет, это не основное их предназначение.")]),e._v(" "),n("p",[e._v("Более полезным является возможность сразу же произвести валидацию поля. Если попытаться в переменную передать неверный тип и/или если вовсе не передать, в случае когда поле обязательное, запрос на сервер не уйдет.")]),e._v(" "),n("p",[e._v("Но основное удобство (я бы даже сказал необходимость) использования вы ощутите в клиенте.")]),e._v(" "),n("h2",{pre:!0,attrs:{id:"клиент"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#клиент"}},[e._v("#")]),e._v(" Клиент")]),e._v(" "),n("h3",{pre:!0,attrs:{id:"шаг-1-добавим-мутацию-в-models-user-js"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-1-добавим-мутацию-в-models-user-js"}},[e._v("#")]),e._v(" Шаг 1. Добавим мутацию в models/user.js")]),e._v(" "),n("p",[e._v("Как вы помните, все наши GraphQL-запросы мы договорились хранить в models (не почти все, а все-все), посему добавим нашу новую мутацию.")]),e._v(" "),n("p",[e._v("models/user.js:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("... \n\n// не забываем присваивать алиасы\n// мутациям они тоже необходимы\nexport const updateAddressAndUserMutation = gql`\n    mutation updateAddressAndUser(\n        $id: Int!, \n        $zip: String, \n        $street: String, \n        $firstname: String, \n        $lastname: String\n    ) {\n        address(id: $id) {\n            update(zip: $zip, street: $street)\n            user {\n                update(\n                    firstname: $firstname, \n                    lastname: $lastname\n                )\n            }\n        }\n    }\n`;\n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-2-компонент"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-2-компонент"}},[e._v("#")]),e._v(" Шаг 2. Компонент")]),e._v(" "),n("p",[e._v("Чтобы было интереснее, создадим новый компонент, заодно посмотрим как работаем механизм событий для общения между компонентами (никакого отношения к GraphQL, поэтому без энтузиазма).")]),e._v(" "),n("p",[e._v("Создаем директорию /src/update-user-address и ложим туда традиционно 2 файла: update-user-address.html и update-user-address.js.")]),e._v(" "),n("p",[n("em",[e._v('Примечание. Если хотите назвать свой компонент как-нибудь по-другому, имейте ввиду, что существует неочевидное требование к именованию. Дело в том, что кастомный компонент в имени должен обязательно содержать "-". Вот так.')])]),e._v(" "),n("p",[e._v("/src/update-user-address/update-user-address.js:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("import { PolymerApolloMixin } from 'polymer-apollo';\nimport { apolloClient } from '../client';\n// не забываем заимпортить все необходимые запросы\nimport { \n    getUserInfoQuery,\n    updateAddressAndUserMutation\n} from '../models/user';\n\nclass UpdateAddressUser extends PolymerApolloMixin({ apolloClient }, Polymer.Element) {\n\n    static get is() { return 'update-address-user'; }\n\n    static get properties() {\n        return {\n            user: {\n                type: Object,\n                value: {},\n                // observer это метод\n                // что будет вызываться при изменении\n                // свойства\n                // зачем это нужно читаем ниже\n                observer: \"_updateProperties\",\n            },\n\n            // перечислим тут все наши поля\n            // данные свойства работают в обе\n            // стороны, т.е. при изменении полей\n            // в шаблоне, они будут изменяться\n            // в объекте\n            zip: { type: String, value: \"\" },\n            street: { type: String, value: \"\" },\n            firstname: { type: String, value: \"\" },\n            lastname: { type: String, value: \"\" },\n        };\n    }\n\n    get apollo() {\n        return {\n            getUserInfo: {\n                query: getUserInfoQuery\n            }\n        };\n    }\n\n    _updateProperties() {\n        // все что делаем в этом методе\n        // это парсим все необходимые значения\n        // из объекта в отдельные\n        // свойства.\n        // нужно это по той причине\n        // что изменить из шаблона\n        // аттрибуты внутри объекта\n        // (user = {...}) невозможно\n        if (this.user.firstname != undefined) {\n            // использовать индексы плохая практика\n            // не делайте так\n            this.zip = this.user.addresses[0].zip;\n            this.street = this.user.addresses[0].street;\n            this.firstname = this.user.firstname;\n            this.lastname = this.user.lastname;\n        }\n    }\n\n    // ну и собственно наш виновник торжества\n    // (вариант очень базовый, за более широкими\n    // возможностями почитайте документацию к polymer-apollo\n    // (https://github.com/aruntk/polymer-apollo#mutations)\n    _sendAddressUserMutation() {\n        this.$apollo.mutate({\n            mutation: updateAddressAndUserMutation,\n            // то, чего вы так ждали\n            // да, это они\n            variables: {\n                id: 1,\n                zip: this.zip,\n                street: this.street,\n                firstname: this.firstname,\n                lastname: this.lastname,\n            },\n        }).then((data) => {\n            // тут можно проверить что же нам пришло\n            // но мы этого делать, конечно же,\n            // не будем\n\n            // вызовем обновление компонента\n            // который выведет наши изменения\n            document.getElementById('view-block').dispatchEvent(new CustomEvent('refetch'));\n        })\n    }\n\n}\n\nwindow.customElements.define(UpdateAddressUser.is, UpdateAddressUser);\n")])])]),n("p",[e._v("/src/update-user-address/update-user-address.html:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v('<dom-module id="update-address-user">\n    <template>\n        \x3c!-- поля со свойствами из компонента\n        (работают в обе стороны) --\x3e\n        ZIP Code: <input value="{{zip::input}}"><br>\n        Street: <input value="{{street::input}}"><br>\n        First Name: <input value="{{firstname::input}}"><br>\n        Last Name: <input value="{{lastname::input}}"><br>\n\n        \x3c!-- по нажатию на кнопку шлём данные\n        на сервер --\x3e\n        <button on-click="_sendAddressUserMutation">Send</button>\n    </template>\n</dom-module>\n')])])]),n("h3",{pre:!0,attrs:{id:"шаг-3-добавим-event-listener-в-основнои-компонент"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-3-добавим-event-listener-в-основнои-компонент"}},[e._v("#")]),e._v(" Шаг 3. Добавим event listener в основной компонент")]),e._v(" "),n("p",[e._v("Чтобы мы могли тут же обновить данные в соседнем компоненте для их вывода после изменения, добавим в него event listener и метод для обновления GraphQL-запроса.")]),e._v(" "),n("p",[e._v("src/graphql-client-demo-app/graphql-client-demo-app.js:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("...\n\n    // добавим eventListener для \n    // внешних компонентов\n\n    ready() {\n        super.ready();\n        this.addEventListener('refetch', e => this._refetch(e));\n    }\n\n...\n\n    // метод для обновления данных сервера\n    _refetch() {\n        this.$apollo.refetch('getUserInfo');\n    }\n\n...\n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-4-подключаем-новосозданныи-компонент"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-4-подключаем-новосозданныи-компонент"}},[e._v("#")]),e._v(" Шаг 4. Подключаем новосозданный компонент")]),e._v(" "),n("p",[e._v("index.html:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v('...\n\n    <link rel="import" href="/src/graphql-client-demo-app/graphql-client-demo-app.html">\n    <link rel="import" href="/src/update-address-user/update-address-user.html">\n\n    <script src="bundle.js"><\/script>\n  </head>\n  <body>\n    <graphql-client-demo-app id="view-block"></graphql-client-demo-app>\n    <update-address-user></update-address-user>\n  </body>\n</html>\n')])])]),n("p",[e._v("entry.js:")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("import './src/client.js';\nimport './src/graphql-client-demo-app/graphql-client-demo-app.js';\nimport './src/update-address-user/update-address-user.js';\n")])])]),n("h3",{pre:!0,attrs:{id:"шаг-5-тестируем"}},[n("a",{pre:!0,attrs:{class:"header-anchor",href:"#шаг-5-тестируем"}},[e._v("#")]),e._v(" Шаг 5. Тестируем")]),e._v(" "),n("p",[e._v("Ну и для начала соберем webpack (если вы все еще не избавились от него):")]),e._v(" "),n("div",{pre:!0,attrs:{class:"language- extra-class"}},[n("pre",{pre:!0,attrs:{"v-pre":"",class:"language-text"}},[n("code",[e._v("$> webpack\n")])])]),n("p",[e._v("Открываем браузер и получаем что-то подобное:")]),e._v(" "),n("p",[n("img",{pre:!0,attrs:{src:"https://habrastorage.org/r/w1560/getpro/habr/post_images/31c/7a9/69f/31c7a969f522eba978d8ece992b4edf3.png",alt:"image"}})]),e._v(" "),n("p",[e._v("Конечно же картинка не позволяет доказать, что данные в верхней части меняются сразу же после нажатия на кнопку Send, но вам ничего не стоит попробовать это самому. К слову, все изменения предусмотрительно залиты на github: "),n("a",{pre:!0,attrs:{href:"https://github.com/timur560/graphql-client-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("клиент"),n("OutboundLink",{pre:!0})],1),e._v(" и "),n("a",{pre:!0,attrs:{href:"https://github.com/timur560/graphql-server-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("сервер"),n("OutboundLink",{pre:!0})],1),e._v(".")]),e._v(" "),n("p",[e._v("Говоря откровенно, данная архитектура совсем не оптимальна, т.к. необходимо доработать ее таким образом, чтобы выполнялся один запрос и данные подтягивались во все места интерфейса. Но это уже проблема не GraphQL.")]),e._v(" "),n("p",[e._v("В следующей (заключительной) части статьи мы рассмотрим, как реализовать валидацию в мутациях, и наконец сделаем выводы по преимуществам и недостатками перехода на GraphQL на основе полученного опыта.")])])])}),[],!1,null,null,null);n.default=s.exports}}]);