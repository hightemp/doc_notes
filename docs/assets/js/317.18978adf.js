(window.webpackJsonp=window.webpackJsonp||[]).push([[317],{600:function(s,t,e){"use strict";e.r(t);var a=e(14),r=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"что-делает-left-join-lateral-в-чем-отличие-от-обычного-left-в-sql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#что-делает-left-join-lateral-в-чем-отличие-от-обычного-left-в-sql"}},[s._v("#")]),s._v(" что делает LEFT JOIN LATERAL в чем отличие от обычного LEFT в SQL")]),s._v(" "),t("p",[s._v("LEFT JOIN LATERAL - это расширение стандартного оператора LEFT JOIN в SQL, которое позволяет выполнить подзапрос на каждой строке таблицы, находящейся в левой части оператора LEFT JOIN. Результаты подзапроса затем объединяются с правой таблицей, используя стандартный оператор LEFT JOIN.")]),s._v(" "),t("p",[s._v("Основное отличие между LEFT JOIN LATERAL и обычным LEFT JOIN заключается в том, что LEFT JOIN LATERAL позволяет выполнить подзапрос на каждой строке таблицы, находящейся в левой части оператора LEFT JOIN, в то время как обычный LEFT JOIN выполняет подзапрос только один раз для всей левой таблицы.")]),s._v(" "),t("p",[s._v("Пример использования LEFT JOIN LATERAL:")]),s._v(" "),t("p",[s._v('Пусть у нас есть таблица "users" и таблица "orders", и мы хотим получить список всех пользователей и последний заказ каждого пользователя. Мы можем использовать LEFT JOIN LATERAL для выполнения подзапроса на каждой строке таблицы "users":')]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" u"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" o"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" users u\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LEFT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("JOIN")]),s._v(" LATERAL "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" orders o\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" o"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("user_id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" u"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("id\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ORDER")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("BY")]),s._v(" o"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("created_at "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("DESC")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LIMIT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" o "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ON")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v('В этом примере мы выполняем подзапрос на каждой строке таблицы "users", чтобы получить последний заказ каждого пользователя. Затем мы объединяем результаты подзапросов с таблицей "users" с помощью оператора LEFT JOIN. Результатом будет таблица, содержащая все строки из таблицы "users" и соответствующие им последние заказы каждого пользователя, если они есть. Если у пользователя нет заказов, то вместо значений из таблицы "orders" будут использоваться NULL-значения.')]),s._v(" "),t("h2",{attrs:{id:"в-чем-преимущество-left-join-lateral-в-отличие-от-обычного-left-в-sql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#в-чем-преимущество-left-join-lateral-в-отличие-от-обычного-left-в-sql"}},[s._v("#")]),s._v(" в чем преимущество LEFT JOIN LATERAL в отличие от обычного LEFT в SQL")]),s._v(" "),t("p",[s._v("LEFT JOIN LATERAL в SQL позволяет выполнить подзапрос для каждой строки основной таблицы и использовать результаты подзапроса вместе с основной таблицей в результирующем наборе.")]),s._v(" "),t("p",[s._v("Преимущества LEFT JOIN LATERAL перед обычным LEFT заключаются в следующем:")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("Гибкость. LEFT JOIN LATERAL позволяет выполнять более сложные запросы, чем обычный LEFT JOIN. Это может быть полезно, например, для получения агрегированных данных по каждому элементу основной таблицы.")])]),s._v(" "),t("li",[t("p",[s._v("Эффективность. LEFT JOIN LATERAL может быть более эффективным, чем обычный LEFT JOIN, поскольку он позволяет выполнять запрос только для нужных строк основной таблицы.")])]),s._v(" "),t("li",[t("p",[s._v("Удобство. LEFT JOIN LATERAL может быть более удобным, чем обычный LEFT JOIN, поскольку он позволяет использовать результаты подзапроса непосредственно в запросе. Это может упростить написание запроса и сделать его более читаемым.")])]),s._v(" "),t("li",[t("p",[s._v("Расширяемость. LEFT JOIN LATERAL может быть использован для решения широкого круга задач, включая построение иерархических структур, выполнение аналитических функций и многого другого.")])])]),s._v(" "),t("h2",{attrs:{id:"какие-изменения-произошли-в-языке-sql-за-последние-5-лет-2021"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#какие-изменения-произошли-в-языке-sql-за-последние-5-лет-2021"}},[s._v("#")]),s._v(" какие изменения произошли в языке SQL за последние 5 лет (2021)")]),s._v(" "),t("p",[s._v("За последние 5 лет в языке SQL произошло несколько изменений и добавлений. Некоторые из них:")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("Версия SQL:2016 была выпущена в 2016 году и включала новые функции, такие как JSON-обработка и расширение для работы с графами.")])]),s._v(" "),t("li",[t("p",[s._v("В SQL Server 2017 была добавлена поддержка графовой базы данных.")])]),s._v(" "),t("li",[t("p",[s._v("В PostgreSQL 10 была добавлена поддержка партиционирования, что позволяет хранить данные в разных таблицах в зависимости от их значения.")])]),s._v(" "),t("li",[t("p",[s._v("В MySQL 8.0 была добавлена поддержка аналитических функций, таких как RANK и ROW_NUMBER.")])]),s._v(" "),t("li",[t("p",[s._v("В Oracle 20c была добавлена поддержка SQL для графов.")])]),s._v(" "),t("li",[t("p",[s._v("В SQLite была добавлена поддержка оконных функций.")])]),s._v(" "),t("li",[t("p",[s._v("В Microsoft SQL Server была добавлена возможность выполнения запросов на графических процессорах с помощью технологии SQL Server Machine Learning Services.")])]),s._v(" "),t("li",[t("p",[s._v("В PostgreSQL была добавлена поддержка хранимых процедур на языке JavaScript.")])])]),s._v(" "),t("p",[s._v("В целом, можно сказать, что язык SQL стал более мощным и гибким за последние 5 лет, что позволяет разрабатывать более сложные и эффективные приложения для работы с базами данных.")]),s._v(" "),t("h2",{attrs:{id:"что-делает-foreign-key-в-sql-и-почему-с-ним-лучше-чем-без"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#что-делает-foreign-key-в-sql-и-почему-с-ним-лучше-чем-без"}},[s._v("#")]),s._v(" что делает foreign key в SQL и почему с ним лучше, чем без")]),s._v(" "),t("p",[s._v("Foreign key в SQL определяет связь между двумя таблицами в базе данных. Он указывает на столбец в одной таблице (родительской) и связывает его со столбцом в другой таблице (дочерней).")]),s._v(" "),t("p",[s._v("Преимущества использования foreign key:")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("Защита целостности данных: при наличии связи между таблицами, foreign key не позволяет добавлять, изменять или удалять записи в родительской таблице, если есть связанные записи в дочерней таблице. Это помогает сохранить целостность данных и избежать ошибок.")])]),s._v(" "),t("li",[t("p",[s._v("Улучшение производительности: при использовании foreign key, запросы к базе данных могут быть оптимизированы, так как база данных знает, как связаны таблицы и может избежать лишних операций.")])]),s._v(" "),t("li",[t("p",[s._v("Упрощение работы с данными: использование foreign key упрощает работу с данными, так как связанные данные могут быть легко извлечены из разных таблиц.")])]),s._v(" "),t("li",[t("p",[s._v("Улучшение структуры базы данных: использование foreign key помогает упорядочить данные в базе данных и сделать ее более логичной и структурированной.")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);