(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{567:function(e,t,o){"use strict";o.r(t);var n=o(14),a=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://codevoweb.com/build-a-simple-api-with-rust-and-actix-web/")]),e._v(" "),t("p",[e._v("In this comprehensive guide, you’ll build a simple CRUD API in Rust using the Actix Web framework and an in-memory database. To summarise, we’ll create a RESTful API with the Actix Web framework that supports CRUD functionalities for handling "),t("strong",[e._v("Create")]),e._v(", "),t("strong",[e._v("Read")]),e._v(", "),t("strong",[e._v("Update")]),e._v(", and "),t("strong",[e._v("Delete")]),e._v(" operations against a centralized data store.")]),e._v(" "),t("p",[e._v("What is Actix Web in Rust? Actix Web is an HTTP web framework written in Rust. It is built on top of the "),t("a",{attrs:{href:"https://docs.rs/actix/latest/actix/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Actix actor framework"),t("OutboundLink")],1),e._v(" and is designed to be extremely fast, secure, scalable, performant, flexible, and easy to use. Also, it has a built-in HTTP server which is fully asynchronous, making it well-suited for building high-performance and high-concurrency web applications.")]),e._v(" "),t("p",[e._v("Actix web has features like routing, logging, middleware, WebSockets, and static file serving support. Its design was inspired by "),t("a",{attrs:{href:"https://flask.palletsprojects.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flask"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://fastapi.tiangolo.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("FastAPI"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://rubyonrails.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rails"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://bottlepy.org/docs/dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bottle"),t("OutboundLink")],1),e._v(", and "),t("a",{attrs:{href:"https://expressjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Express.js"),t("OutboundLink")],1),e._v(". So you’ll feel at home when already have some experience with those frameworks.")]),e._v(" "),t("p",[e._v("More practice:")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-simple-api-in-rust",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a Simple API in Rust"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-simple-api-with-rust-and-rocket",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a Simple API with Rust and Rocket"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-api-with-nodejs-and-sequelize",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD API with Node.js and Sequelize"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-app-with-fastapi-and-sqlalchemy",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD App with FastAPI and SQLAlchemy"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-app-with-fastapi-and-pymongo",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD App with FastAPI and PyMongo"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-crud-api-with-django-rest-framework",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build CRUD API with Django REST framework"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/crud-restful-api-server-with-golang-and-mongodb",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build CRUD RESTful API Server with Golang, Gin, and MongoDB"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"prerequisites"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites"}},[e._v("#")]),e._v(" Prerequisites")]),e._v(" "),t("p",[e._v("To fully grasp the concepts presented in this tutorial, these prerequisites are needed.")]),e._v(" "),t("ul",[t("li",[e._v("Basic experience with Rust")]),e._v(" "),t("li",[e._v("Basic knowledge of REST architecture")]),e._v(" "),t("li",[e._v("Prior knowledge of creating an API in Rust or other languages will be beneficial.")])]),e._v(" "),t("h2",{attrs:{id:"run-the-rust-actix-web-api-locally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#run-the-rust-actix-web-api-locally"}},[e._v("#")]),e._v(" Run the Rust Actix Web API Locally")]),e._v(" "),t("ul",[t("li",[e._v("Download or clone the Rust Actix Web API project from "),t("a",{attrs:{href:"https://github.com/wpcodevo/simple-api-actix-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/wpcodevo/simple-api-actix-web"),t("OutboundLink")],1),e._v(" and open the source code in a code editor.")]),e._v(" "),t("li",[e._v("Run "),t("code",[e._v("cargo r -r")]),e._v(" in the console of the root directory to install the required crates and start the Actix Web HTTP server.")]),e._v(" "),t("li",[e._v("Open Postman or Thunder Client VS Code extension and import the "),t("code",[e._v("Todo.postman_collection.json")]),e._v(" file provided in the project’s root folder to have access to the collection used in testing the API.")]),e._v(" "),t("li",[e._v("Once you have access to the Postman collection, test the individual endpoints of the Actix Web API.")])]),e._v(" "),t("h2",{attrs:{id:"initialize-the-rust-project"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialize-the-rust-project"}},[e._v("#")]),e._v(" Initialize the Rust Project")]),e._v(" "),t("p",[e._v("At the end of this tutorial, you’ll have a folder structure that looks like the screenshot below excluding the "),t("strong",[e._v("Makefile")]),e._v(" and "),t("strong",[e._v("Todo.postman_collection.json files")]),e._v(".")]),e._v(" "),t("p",[e._v("To begin, navigate to a desired location on your machine and run the following commands.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nmkdir simple-api-actix-web\ncd simple-api-actix-web && code .\n")])])]),t("p",[e._v("This will create a new directory called "),t("code",[e._v("simple-api-actix-web")]),e._v(" , navigate into the newly-created folder, and open the folder in VS Code. Feel free to use any IDE or text editor you are more comfortable with.")]),e._v(" "),t("p",[e._v("Now open the integrated terminal in your code editor and run "),t("a",{attrs:{href:"https://doc.rust-lang.org/cargo/commands/cargo-init.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cargo’s init function"),t("OutboundLink")],1),e._v(" to initialize the Rust project in the current directory.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo init\n")])])]),t("p",[e._v("In the console of the root directory, run these commands to add the following dependencies to the "),t("code",[e._v("Cargo.toml")]),e._v(" manifest file.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo add actix-web\ncargo add actix-cors\ncargo add serde --features derive\ncargo add chrono --features serde\ncargo add env_logger\ncargo add uuid --features v4\n")])])]),t("ul",[t("li",[t("code",[e._v("[actix-web](https://crates.io/crates/actix-web)")]),e._v(" – A web framework for Rust.")]),e._v(" "),t("li",[t("code",[e._v("[actix-cors](https://crates.io/crates/actix-cors)")]),e._v(" – This crate provides CORS (Cross-Origin Resource Sharing) support for the Actix web framework.")]),e._v(" "),t("li",[t("code",[e._v("[serde](https://crates.io/crates/serde)")]),e._v(" – This crate provides a framework to convert Rust data structures to and from various formats such as JSON, YAML, TOML, and more.")]),e._v(" "),t("li",[t("code",[e._v("[chrono](https://crates.io/crates/chrono)")]),e._v(" – This crate provides a set of types for representing and manipulating dates, times, durations, and time zones in Rust.")]),e._v(" "),t("li",[t("code",[e._v("[env_logger](https://crates.io/crates/env_logger)")]),e._v(" – This crate is built on top of the "),t("code",[e._v("[log](https://crates.io/crates/log)")]),e._v(" crate and it allows you to initialize and configure a logger via environment variables.")]),e._v(" "),t("li",[t("code",[e._v("[uuid](https://crates.io/crates/uuid)")]),e._v(" – This crate provides a simple and efficient way to generate and parse UUIDs in Rust.")])]),e._v(" "),t("p",[e._v("In case the latest versions of the above dependencies break your app, you can replace the content of your "),t("code",[e._v("Cargo.toml")]),e._v(" file with the code below.")]),e._v(" "),t("p",[t("strong",[e._v("Cargo.toml")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n[package]\nname = "simple-api-actix-web"\nversion = "0.1.0"\nedition = "2021"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nactix-cors = "0.6.4"\nactix-web = "4.2.1"\nchrono = { version = "0.4.23", features = ["serde"] }\nenv_logger = "0.10.0"\nserde = { version = "1.0.152", features = ["derive"] }\nuuid = { version = "1.2.2", features = ["v4"] }\n')])])]),t("p",[e._v("Now let’s create a simple HTTP server with Actix web to get our hands dirty. To do this, open the "),t("code",[e._v("src/main.rs")]),e._v(" file and replace its content with the following code snippets.")]),e._v(" "),t("p",[t("strong",[e._v("src/main.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nuse actix_web::middleware::Logger;\nuse actix_web::{get, App, HttpResponse, HttpServer, Responder};\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct GenericResponse {\n    pub status: String,\n    pub message: String,\n}\n\n#[get("/api/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    if std::env::var_os("RUST_LOG").is_none() {\n        std::env::set_var("RUST_LOG", "actix_web=info");\n    }\n    env_logger::init();\n\n    println!("🚀 Server started successfully");\n\n    HttpServer::new(move || {\n        App::new()\n            .service(health_checker_handler)\n            .wrap(Logger::default())\n    })\n    .bind(("127.0.0.1", 8000))?\n    .run()\n    .await\n}\n')])])]),t("p",[e._v("In the above code, we created a "),t("code",[e._v("GenericResponse")]),e._v(" struct that implements the "),t("strong",[e._v("Serialize")]),e._v(" trait of the Serde crate. Then, we created a "),t("code",[e._v("/api/healthchecker")]),e._v(" route to respond with a JSON object containing a “"),t("em",[e._v("message")]),e._v("” property with the value “Build Simple CRUD API with Rust and Actix Web“.")]),e._v(" "),t("p",[e._v("If you have a Node.js background, you may be familiar with the Nodemon package which restarts the server when files change. Well, in Rust, we have a command-line tool called "),t("code",[e._v("[cargo-watch](https://crates.io/crates/cargo-watch)")]),e._v(" that can watch the source code for changes and hot-reload the server.")]),e._v(" "),t("p",[e._v("You can install "),t("code",[e._v("cargo-watch")]),e._v(" with this command:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo install cargo-watch \n")])])]),t("p",[e._v("Once installed, you can run this command to start the Actix Web HTTP server and restart the server when a file in the "),t("strong",[e._v("src")]),e._v(" directory changes. Feel free to use the Cargo CLI instead.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo watch -q -c -w src/ -x run\n")])])]),t("p",[e._v("Now that the Actix Web server is up and running, send a "),t("strong",[e._v("GET")]),e._v(" request to "),t("code",[e._v("http://localhost:8000/api/healthchecker")]),e._v(" and you should receive a JSON object with the message “Build Simple CRUD API with Rust and Actix Web“.")]),e._v(" "),t("p",[e._v("![testing the health checker route of the actix web api](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22977%22%20height=%22316%22%3E%3C/svg%3E)")]),e._v(" "),t("h2",{attrs:{id:"setup-the-database-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup-the-database-model"}},[e._v("#")]),e._v(" Setup the Database Model")]),e._v(" "),t("p",[e._v("Let me clear the air first. We won’t use a real database in this project to keep things simple. However, you’ll create a centralized data store that will be shared across the route handlers using a Mutex, vector, and Rust’s smart pointer called Arc.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://doc.rust-lang.org/std/sync/struct.Arc.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arc"),t("OutboundLink")],1),e._v(" will allow the in-memory database to be shared across multiple threads and "),t("a",{attrs:{href:"https://doc.rust-lang.org/std/sync/struct.Mutex.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mutex"),t("OutboundLink")],1),e._v(" will enable safe access to the data store even if multiple threads are accessing it at the same time.")]),e._v(" "),t("p",[e._v("To set up the in-memory database, create a "),t("code",[e._v("model.rs")]),e._v(" file in the "),t("strong",[e._v("src")]),e._v(" directory and add the following code.")]),e._v(" "),t("p",[t("strong",[e._v("src/model.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse chrono::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, Mutex};\n\n#[allow(non_snake_case)]\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Todo {\n    pub id: Option<String>,\n    pub title: String,\n    pub content: String,\n    pub completed: Option<bool>,\n    pub createdAt: Option<DateTime<Utc>>,\n    pub updatedAt: Option<DateTime<Utc>>,\n}\n\npub struct AppState {\n    pub todo_db: Arc<Mutex<Vec<Todo>>>,\n}\n\nimpl AppState {\n    pub fn init() -> AppState {\n        AppState {\n            todo_db: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct QueryOptions {\n    pub page: Option<usize>,\n    pub limit: Option<usize>,\n}\n\n#[allow(non_snake_case)]\n#[derive(Debug, Deserialize)]\npub struct UpdateTodoSchema {\n    pub title: Option<String>,\n    pub content: Option<String>,\n    pub completed: Option<bool>,\n}\n")])])]),t("p",[e._v("Above, we defined a "),t("strong",[e._v("Todo")]),e._v(" struct to represent the structure of a Todo item. Then, we created an "),t("strong",[e._v("AppState")]),e._v(" struct which has a "),t("code",[e._v("Arc<Mutex<Vec<Todo>>>")]),e._v(" field called "),t("code",[e._v("todo_db")]),e._v(" that stores the data.")]),e._v(" "),t("p",[e._v("The "),t("strong",[e._v("AppState")]),e._v(" struct has an "),t("strong",[e._v("init")]),e._v(" function that creates a new instance of the "),t("strong",[e._v("AppState")]),e._v(" struct and initializes it with an empty vector. At the bottom, we created "),t("code",[e._v("QueryOptions")]),e._v(" and "),t("code",[e._v("UpdateTodoSchema")]),e._v(" structs to help us deserialize the incoming request bodies into structs.")]),e._v(" "),t("h2",{attrs:{id:"create-the-api-response-structs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#create-the-api-response-structs"}},[e._v("#")]),e._v(" Create the API Response Structs")]),e._v(" "),t("p",[e._v("Now that we’ve set up the data store, let’s create structs that implement Serde’s "),t("strong",[e._v("Serialize")]),e._v(" trait. This is required because Actix-web’s "),t("code",[e._v("HttpResponseBuilder")]),e._v(" function experts structs that implement the "),t("strong",[e._v("Serialize")]),e._v(" trait.")]),e._v(" "),t("p",[t("strong",[e._v("src/response.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse serde::Serialize;\n\nuse crate::model::Todo;\n\n#[derive(Serialize)]\npub struct GenericResponse {\n    pub status: String,\n    pub message: String,\n}\n\n#[derive(Serialize, Debug)]\npub struct TodoData {\n    pub todo: Todo,\n}\n\n#[derive(Serialize, Debug)]\npub struct SingleTodoResponse {\n    pub status: String,\n    pub data: TodoData,\n}\n\n#[derive(Serialize, Debug)]\npub struct TodoListResponse {\n    pub status: String,\n    pub results: usize,\n    pub todos: Vec<Todo>,\n}\n")])])]),t("h2",{attrs:{id:"add-the-crud-functionalities"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-the-crud-functionalities"}},[e._v("#")]),e._v(" Add the CRUD Functionalities")]),e._v(" "),t("p",[e._v("When building APIs, it is common to add CRUD functionalities to interact with the data. This can be done by creating higher-level CRUD functions that implement the lower-level CRUD functions provided by an ORM or a database driver.")]),e._v(" "),t("p",[e._v("Implementing CRUD functionalities can be a complex task, but it is a fundamental aspect of any API that needs to persist data. In this section, we’ll create route handlers to add CRUD functionalities to the Actix Web API. Below is the list of routes the API will have.")]),e._v(" "),t("ul",[t("li",[t("code",[e._v('#[get("/healthchecker")]')]),e._v(" – This route will send a JSON object that contains a message field.")]),e._v(" "),t("li",[t("code",[e._v('#[get("/todos")]')]),e._v(" – This route will retrieve a list of Todo items from the data store and send them in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[post("/todos")]')]),e._v(" – This route will add a new Todo item to the data store and return the newly-created item in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[get("/todos/{id}")]')]),e._v(" – This route will find a Todo item by ID and return the found item in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[patch("/todos/{id}")]')]),e._v(" – This route will find a Todo item by ID and edit the fields of the found item based on the request payload.")]),e._v(" "),t("li",[t("code",[e._v('#[delete("/todos/{id}")]')]),e._v(" – This route will find a Todo item by ID and delete it from the data store.")])]),e._v(" "),t("p",[e._v("To begin, go into the "),t("strong",[e._v("src")]),e._v(" directory and create a "),t("code",[e._v("handler.rs")]),e._v(" file. Within the "),t("code",[e._v("handler.rs")]),e._v(" file, add the following modules and dependencies.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse crate::{\n    model::{AppState, QueryOptions, Todo, UpdateTodoSchema},\n    response::{GenericResponse, SingleTodoResponse, TodoData, TodoListResponse},\n};\nuse actix_web::{delete, get, patch, post, web, HttpResponse, Responder};\nuse chrono::prelude::*;\nuse uuid::Uuid;\n")])])]),t("h3",{attrs:{id:"health-checker-route"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#health-checker-route"}},[e._v("#")]),e._v(" Health Checker Route")]),e._v(" "),t("p",[e._v("This route controller will be called to return a simple JSON object when the Actix Web server receives a "),t("strong",[e._v("GET")]),e._v(" request on the "),t("code",[e._v("/api/healthchecker")]),e._v(" path.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n')])])]),t("p",[e._v("The "),t("code",[e._v("HttpResponse::Ok().json(response_json)")]),e._v(" method will serialize the "),t("strong",[e._v("GenericResponse")]),e._v(" struct, set the correct headers, and return the JSON object to the client.")]),e._v(" "),t("h3",{attrs:{id:"fetch-all-records"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch-all-records"}},[e._v("#")]),e._v(" Fetch All Records")]),e._v(" "),t("p",[e._v("The first CRUD functionality we’ll implement is "),t("strong",[e._v("READ")]),e._v(". This route function will be called to return a list of Todo items when the Actix Web server receives a "),t("strong",[e._v("GET")]),e._v(" request on the "),t("code",[e._v("/api/todos")]),e._v(" path.")]),e._v(" "),t("p",[e._v("The route handler will have a pagination feature where the user can request a selected list of records. This will improve the performance of the API when dealing with large datasets.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/todos")]\npub async fn todos_list_handler(\n    opts: web::Query<QueryOptions>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let todos = data.todo_db.lock().unwrap();\n\n    let limit = opts.limit.unwrap_or(10);\n    let offset = (opts.page.unwrap_or(1) - 1) * limit;\n\n    let todos: Vec<Todo> = todos.clone().into_iter().skip(offset).take(limit).collect();\n\n    let json_response = TodoListResponse {\n        status: "success".to_string(),\n        results: todos.len(),\n        todos,\n    };\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Above, we fetched the list of Todo items from the data store, skipped a number of elements based on the "),t("code",[e._v("offset")]),e._v(" value, limited the number of results based on the "),t("code",[e._v("limit")]),e._v(" value, and returned the resulting list of Todo items in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"create-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#create-a-record"}},[e._v("#")]),e._v(" Create a Record")]),e._v(" "),t("p",[e._v("The next CRUD functionality is "),t("strong",[e._v("CREATE")]),e._v(". Actix Web will call this route function to add a Todo item to the data store when a "),t("strong",[e._v("POST")]),e._v(" request is made to the "),t("code",[e._v("/api/todos")]),e._v(" endpoint.")]),e._v(" "),t("p",[e._v("To prevent duplicates in the data store, we’ll first check if a record with that "),t("strong",[e._v("title")]),e._v(" already exists. If a Todo item with that title already exists, a "),t("strong",[e._v("409 Conflict error")]),e._v(" will be sent to the client.")]),e._v(" "),t("p",[e._v("Otherwise, a "),t("strong",[e._v("UUID")]),e._v(" will be generated for the new record and persisted in the in-memory database. After that, the newly-added record will be returned in the JSON response.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[post("/todos")]\nasync fn create_todo_handler(\n    mut body: web::Json<Todo>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let todo = vec.iter().find(|todo| todo.title == body.title);\n\n    if todo.is_some() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with title: \'{}\' already exists", body.title),\n        };\n        return HttpResponse::Conflict().json(error_response);\n    }\n\n    let uuid_id = Uuid::new_v4();\n    let datetime = Utc::now();\n\n    body.id = Some(uuid_id.to_string());\n    body.completed = Some(false);\n    body.createdAt = Some(datetime);\n    body.updatedAt = Some(datetime);\n\n    let todo = body.to_owned();\n\n    vec.push(body.into_inner());\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("h3",{attrs:{id:"retrieve-a-single-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-a-single-record"}},[e._v("#")]),e._v(" Retrieve a Single Record")]),e._v(" "),t("p",[e._v("Now let’s perform the second "),t("strong",[e._v("READ")]),e._v(" operation. To do this, we’ll create a route function that Actix Web will use to retrieve a single record by "),t("strong",[e._v("ID")]),e._v(" from the data store and return the found record to the client.")]),e._v(" "),t("p",[e._v("This route handler will be called when a "),t("strong",[e._v("GET")]),e._v(" request hits the server at the"),t("code",[e._v("/api/todos/{id}")]),e._v(" endpoint. If no record with that "),t("strong",[e._v("ID")]),e._v(" was found, a "),t("strong",[e._v("404 Not Found error")]),e._v(" will be sent to the client.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/todos/{id}")]\nasync fn get_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Otherwise, the Todo item that matches the query will be returned to the client in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"edit-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#edit-a-record"}},[e._v("#")]),e._v(" Edit a Record")]),e._v(" "),t("p",[e._v("It’s now time to perform the "),t("strong",[e._v("UPDATE")]),e._v(" operation. When a "),t("strong",[e._v("PATCH")]),e._v(" request is made to the "),t("code",[e._v("/api/todos/{id}")]),e._v(" endpoint, Actix Web will evoke this route handler to process the request.")]),e._v(" "),t("p",[e._v("When Actix Web delegates the "),t("strong",[e._v("PATCH")]),e._v(" request to this route function, it will query the data store to find the record by the provided "),t("strong",[e._v("ID")]),e._v(" and update its fields based on the data available in the request body.")]),e._v(" "),t("p",[e._v("If no record with that ID exists in the in-memory database, a "),t("strong",[e._v("404 Not Found error")]),e._v(" will be returned to the client.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[patch("/todos/{id}")]\nasync fn edit_todo_handler(\n    path: web::Path<String>,\n    body: web::Json<UpdateTodoSchema>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let datetime = Utc::now();\n    let title = body.title.to_owned().unwrap_or(todo.title.to_owned());\n    let content = body.content.to_owned().unwrap_or(todo.content.to_owned());\n    let payload = Todo {\n        id: todo.id.to_owned(),\n        title: if !title.is_empty() {\n            title\n        } else {\n            todo.title.to_owned()\n        },\n        content: if !content.is_empty() {\n            content\n        } else {\n            todo.content.to_owned()\n        },\n        completed: if body.completed.is_some() {\n            body.completed\n        } else {\n            todo.completed\n        },\n        createdAt: todo.createdAt,\n        updatedAt: Some(datetime),\n    };\n    *todo = payload;\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Otherwise, the newly-updated record will be sent to the client in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"delete-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delete-a-record"}},[e._v("#")]),e._v(" Delete a Record")]),e._v(" "),t("p",[e._v("Finally, let’s perform the last CRUD operation which is "),t("strong",[e._v("DELETE")]),e._v(". When the Actix Web server receives a "),t("strong",[e._v("DELETE")]),e._v(" request on the "),t("code",[e._v("/api/todos/{id}")]),e._v(" endpoint, it will call this route function to remove the record that matches the provided "),t("strong",[e._v("ID")]),e._v(" from the data store.")]),e._v(" "),t("p",[e._v("If no record was found, a "),t("strong",[e._v("404 Not Found error")]),e._v(" will be returned to the client. Otherwise a 204 No Content response will be sent.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[delete("/todos/{id}")]\nasync fn delete_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    vec.retain(|todo| todo.id != Some(id.to_owned()));\n    HttpResponse::NoContent().finish()\n}\n')])])]),t("h3",{attrs:{id:"merge-the-routes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#merge-the-routes"}},[e._v("#")]),e._v(" Merge the Routes")]),e._v(" "),t("p",[e._v("Now that we’ve defined all the route functions, let’s use Actix-web’s "),t("code",[e._v('web::scope("")')]),e._v(" function to group them under a "),t("code",[e._v("/api")]),e._v(" prefix.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\npub fn config(conf: &mut web::ServiceConfig) {\n    let scope = web::scope("/api")\n        .service(health_checker_handler)\n        .service(todos_list_handler)\n        .service(create_todo_handler)\n        .service(get_todo_handler)\n        .service(edit_todo_handler)\n        .service(delete_todo_handler);\n\n    conf.service(scope);\n}\n')])])]),t("h3",{attrs:{id:"complete-route-controllers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#complete-route-controllers"}},[e._v("#")]),e._v(" Complete Route Controllers")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nuse crate::{\n    model::{AppState, QueryOptions, Todo, UpdateTodoSchema},\n    response::{GenericResponse, SingleTodoResponse, TodoData, TodoListResponse},\n};\nuse actix_web::{delete, get, patch, post, web, HttpResponse, Responder};\nuse chrono::prelude::*;\nuse uuid::Uuid;\n\n#[get("/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n\n#[get("/todos")]\npub async fn todos_list_handler(\n    opts: web::Query<QueryOptions>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let todos = data.todo_db.lock().unwrap();\n\n    let limit = opts.limit.unwrap_or(10);\n    let offset = (opts.page.unwrap_or(1) - 1) * limit;\n\n    let todos: Vec<Todo> = todos.clone().into_iter().skip(offset).take(limit).collect();\n\n    let json_response = TodoListResponse {\n        status: "success".to_string(),\n        results: todos.len(),\n        todos,\n    };\n    HttpResponse::Ok().json(json_response)\n}\n\n#[post("/todos")]\nasync fn create_todo_handler(\n    mut body: web::Json<Todo>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let todo = vec.iter().find(|todo| todo.title == body.title);\n\n    if todo.is_some() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with title: \'{}\' already exists", body.title),\n        };\n        return HttpResponse::Conflict().json(error_response);\n    }\n\n    let uuid_id = Uuid::new_v4();\n    let datetime = Utc::now();\n\n    body.id = Some(uuid_id.to_string());\n    body.completed = Some(false);\n    body.createdAt = Some(datetime);\n    body.updatedAt = Some(datetime);\n\n    let todo = body.to_owned();\n\n    vec.push(body.into_inner());\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[get("/todos/{id}")]\nasync fn get_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[patch("/todos/{id}")]\nasync fn edit_todo_handler(\n    path: web::Path<String>,\n    body: web::Json<UpdateTodoSchema>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let datetime = Utc::now();\n    let title = body.title.to_owned().unwrap_or(todo.title.to_owned());\n    let content = body.content.to_owned().unwrap_or(todo.content.to_owned());\n    let payload = Todo {\n        id: todo.id.to_owned(),\n        title: if !title.is_empty() {\n            title\n        } else {\n            todo.title.to_owned()\n        },\n        content: if !content.is_empty() {\n            content\n        } else {\n            todo.content.to_owned()\n        },\n        completed: if body.completed.is_some() {\n            body.completed\n        } else {\n            todo.completed\n        },\n        createdAt: todo.createdAt,\n        updatedAt: Some(datetime),\n    };\n    *todo = payload;\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[delete("/todos/{id}")]\nasync fn delete_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    vec.retain(|todo| todo.id != Some(id.to_owned()));\n    HttpResponse::NoContent().finish()\n}\n\npub fn config(conf: &mut web::ServiceConfig) {\n    let scope = web::scope("/api")\n        .service(health_checker_handler)\n        .service(todos_list_handler)\n        .service(create_todo_handler)\n        .service(get_todo_handler)\n        .service(edit_todo_handler)\n        .service(delete_todo_handler);\n\n    conf.service(scope);\n}\n')])])]),t("h2",{attrs:{id:"add-cors-to-the-actix-web-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-cors-to-the-actix-web-server"}},[e._v("#")]),e._v(" Add CORS to the Actix Web Server")]),e._v(" "),t("p",[e._v("Now that we’ve created the route handlers, in-memory database, and response structs, let’s import their respective files as modules into the "),t("code",[e._v("src/main.rs")]),e._v(" file and add CORS headers to the Actix Web server.")]),e._v(" "),t("p",[e._v("To add CORS headers, we’ll use the "),t("code",[e._v("Cors")]),e._v(" struct middleware provided by the "),t("code",[e._v("actix_cors")]),e._v(" crate to define the headers and wrap them around the routes. So, open the "),t("strong",[e._v("src/main.rs")]),e._v(" file and replace its content with the following code.")]),e._v(" "),t("p",[t("strong",[e._v("src/main.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nmod handler;\nmod model;\nmod response;\n\nuse actix_cors::Cors;\nuse actix_web::middleware::Logger;\nuse actix_web::{http::header, web, App, HttpServer};\nuse model::AppState;\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    if std::env::var_os("RUST_LOG").is_none() {\n        std::env::set_var("RUST_LOG", "actix_web=info");\n    }\n    env_logger::init();\n\n    let todo_db = AppState::init();\n    let app_data = web::Data::new(todo_db);\n\n    println!("🚀 Server started successfully");\n\n    HttpServer::new(move || {\n        let cors = Cors::default()\n            .allowed_origin("http://localhost:3000")\n            .allowed_origin("http://localhost:3000/")\n            .allowed_methods(vec!["GET", "POST"])\n            .allowed_headers(vec![\n                header::CONTENT_TYPE,\n                header::AUTHORIZATION,\n                header::ACCEPT,\n            ])\n            .supports_credentials();\n        App::new()\n            .app_data(app_data.clone())\n            .configure(handler::config)\n            .wrap(cors)\n            .wrap(Logger::default())\n    })\n    .bind(("127.0.0.1", 8000))?\n    .run()\n    .await\n}\n')])])]),t("p",[e._v("With that out of the way, run the command below to start the Actix Web HTTP server again.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo watch -q -c -w src/ -x run\n")])])]),t("h2",{attrs:{id:"test-the-actix-web-crud-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#test-the-actix-web-crud-api"}},[e._v("#")]),e._v(" Test the Actix Web CRUD API")]),e._v(" "),t("p",[e._v("Now that the Actix Web HTTP server is ready to accept requests, clone the project, import the "),t("code",[e._v("Todo.postman_collection.json")]),e._v(" file into Postman, and test the endpoints.")]),e._v(" "),t("h3",{attrs:{id:"add-a-new-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-a-new-todo-item"}},[e._v("#")]),e._v(" Add a New Todo Item")]),e._v(" "),t("p",[e._v("To create a new Todo item, add a JSON object that contains “"),t("strong",[e._v("title")]),e._v("” and “"),t("strong",[e._v("content")]),e._v("” fields to the request body and make a "),t("strong",[e._v("POST")]),e._v(" request to the "),t("code",[e._v("http://localhost:8000/api/todos")]),e._v(" endpoint.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n{\n    "title": "Learn how to build a CRUD API with Actix Web framework in Rust",\n    "content": "Rust a system programming language"\n}\n')])])]),t("p",[e._v("The Actix Web server will call the appropriate route handler to add the new item to the data store and return the newly-added item in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api add a new record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22926%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"edit-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#edit-a-todo-item"}},[e._v("#")]),e._v(" Edit a Todo Item")]),e._v(" "),t("p",[e._v("To edit the fields of a Todo item in the data store, add the edited JSON object to the request body and make a "),t("strong",[e._v("PATCH")]),e._v(" request to the "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v(" endpoint.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n{\n    "title": "New title for the Actix Web CRUD API ✅🚀",\n    "completed": true\n}\n')])])]),t("p",[e._v("The Actix web server will call the appropriate route handler to edit the fields of the item that matches the ID parameter and return the newly-updated item in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api edit a record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22893%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"retrieve-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-a-todo-item"}},[e._v("#")]),e._v(" Retrieve a Todo Item")]),e._v(" "),t("p",[e._v("Here, you can append the ID of a record to the URL parameter and make a "),t("strong",[e._v("GET")]),e._v(" request to the "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v(" endpoint. This will return the Todo item that matches the ID in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api retrieve a single record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22908%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"retrieve-all-todo-items"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-all-todo-items"}},[e._v("#")]),e._v(" Retrieve All Todo Items")]),e._v(" "),t("p",[e._v("Now let’s perform the "),t("strong",[e._v("READ")]),e._v(" operation of CRUD to retrieve a paginated list of Todo items from the in-memory database. To do that, add "),t("strong",[e._v("limit")]),e._v(" and "),t("strong",[e._v("page")]),e._v(" query parameters to the request URL and make a "),t("strong",[e._v("GET")]),e._v(" request to the "),t("code",[e._v("http://localhost:8000/api/todos?page=1&limit=10")]),e._v(" endpoint.")]),e._v(" "),t("p",[e._v("If the "),t("strong",[e._v("limit")]),e._v(" and "),t("strong",[e._v("page")]),e._v(" query parameters are absent in the URL, the Actix Web server will only return the first 10 results.")]),e._v(" "),t("p",[e._v("![actix web crud api fetch all records](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22963%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"delete-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delete-a-todo-item"}},[e._v("#")]),e._v(" Delete a Todo Item")]),e._v(" "),t("p",[e._v("Finally, let’s perform the "),t("strong",[e._v("DELETE")]),e._v(" operation of CRUD. So, add the Todo item’s ID to the URL parameter and make a "),t("strong",[e._v("DELETE")]),e._v(" request to the "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v(" endpoint. The Actix web server will find the Todo item by ID and delete it from the data store.")]),e._v(" "),t("p",[e._v("![actix web crud api delete a record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22886%22%20height=%22670%22%3E%3C/svg%3E)")]),e._v(" "),t("h2",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),t("p",[e._v("Congrats on making it to the end. In this article, you learned how to build a simple CRUD API in Rust using the Actix Web framework. In addition, you learned how to set up an in-memory database with a struct, Arc, and Mutex.")]),e._v(" "),t("p",[e._v("You can find the complete source code of the Actix Web API on "),t("a",{attrs:{href:"https://github.com/wpcodevo/simple-api-actix-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=a.exports}}]);