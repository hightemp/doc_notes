(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{567:function(e,t,o){"use strict";o.r(t);var n=o(14),a=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://codevoweb.com/build-a-simple-api-with-rust-and-actix-web/")]),e._v(" "),t("p",[e._v("In this comprehensive guide, youâ€™ll build a simple CRUD API in Rust using the Actix Web framework and an in-memory database. To summarise, weâ€™ll create a RESTful API with the Actix Web framework that supports CRUD functionalities for handlingÂ "),t("strong",[e._v("Create")]),e._v(",Â "),t("strong",[e._v("Read")]),e._v(",Â "),t("strong",[e._v("Update")]),e._v(", andÂ "),t("strong",[e._v("Delete")]),e._v("Â operations against a centralized data store.")]),e._v(" "),t("p",[e._v("What is Actix Web in Rust? Actix Web is an HTTP web framework written in Rust. It is built on top of theÂ "),t("a",{attrs:{href:"https://docs.rs/actix/latest/actix/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Actix actor framework"),t("OutboundLink")],1),e._v("Â and is designed to be extremely fast, secure, scalable, performant, flexible, and easy to use. Also, it has a built-in HTTP server which is fully asynchronous, making it well-suited for building high-performance and high-concurrency web applications.")]),e._v(" "),t("p",[e._v("Actix web has features like routing, logging, middleware, WebSockets, and static file serving support. Its design was inspired byÂ "),t("a",{attrs:{href:"https://flask.palletsprojects.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flask"),t("OutboundLink")],1),e._v(",Â "),t("a",{attrs:{href:"https://fastapi.tiangolo.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("FastAPI"),t("OutboundLink")],1),e._v(",Â "),t("a",{attrs:{href:"https://rubyonrails.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rails"),t("OutboundLink")],1),e._v(",Â "),t("a",{attrs:{href:"https://bottlepy.org/docs/dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bottle"),t("OutboundLink")],1),e._v(", andÂ "),t("a",{attrs:{href:"https://expressjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Express.js"),t("OutboundLink")],1),e._v(". So youâ€™ll feel at home when already have some experience with those frameworks.")]),e._v(" "),t("p",[e._v("More practice:")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-simple-api-in-rust",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a Simple API in Rust"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-simple-api-with-rust-and-rocket",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a Simple API with Rust and Rocket"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-api-with-nodejs-and-sequelize",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD API with Node.js and Sequelize"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-app-with-fastapi-and-sqlalchemy",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD App with FastAPI and SQLAlchemy"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-a-crud-app-with-fastapi-and-pymongo",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build a CRUD App with FastAPI and PyMongo"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/build-crud-api-with-django-rest-framework",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build CRUD API with Django REST framework"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://codevoweb.com/crud-restful-api-server-with-golang-and-mongodb",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build CRUD RESTful API Server with Golang, Gin, and MongoDB"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"prerequisites"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites"}},[e._v("#")]),e._v(" Prerequisites")]),e._v(" "),t("p",[e._v("To fully grasp the concepts presented in this tutorial, these prerequisites are needed.")]),e._v(" "),t("ul",[t("li",[e._v("Basic experience with Rust")]),e._v(" "),t("li",[e._v("Basic knowledge of REST architecture")]),e._v(" "),t("li",[e._v("Prior knowledge of creating an API in Rust or other languages will be beneficial.")])]),e._v(" "),t("h2",{attrs:{id:"run-the-rust-actix-web-api-locally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#run-the-rust-actix-web-api-locally"}},[e._v("#")]),e._v(" Run the Rust Actix Web API Locally")]),e._v(" "),t("ul",[t("li",[e._v("Download or clone the Rust Actix Web API project fromÂ "),t("a",{attrs:{href:"https://github.com/wpcodevo/simple-api-actix-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/wpcodevo/simple-api-actix-web"),t("OutboundLink")],1),e._v("Â and open the source code in a code editor.")]),e._v(" "),t("li",[e._v("RunÂ "),t("code",[e._v("cargo r -r")]),e._v("Â in the console of the root directory to install the required crates and start the Actix Web HTTP server.")]),e._v(" "),t("li",[e._v("Open Postman or Thunder Client VS Code extension and import theÂ "),t("code",[e._v("Todo.postman_collection.json")]),e._v("Â file provided in the projectâ€™s root folder to have access to the collection used in testing the API.")]),e._v(" "),t("li",[e._v("Once you have access to the Postman collection, test the individual endpoints of the Actix Web API.")])]),e._v(" "),t("h2",{attrs:{id:"initialize-the-rust-project"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialize-the-rust-project"}},[e._v("#")]),e._v(" Initialize the Rust Project")]),e._v(" "),t("p",[e._v("At the end of this tutorial, youâ€™ll have a folder structure that looks like the screenshot below excluding theÂ "),t("strong",[e._v("Makefile")]),e._v("Â andÂ "),t("strong",[e._v("Todo.postman_collection.json files")]),e._v(".")]),e._v(" "),t("p",[e._v("To begin, navigate to a desired location on your machine and run the following commands.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nmkdir simple-api-actix-web\ncd simple-api-actix-web && code .\n")])])]),t("p",[e._v("This will create a new directory calledÂ "),t("code",[e._v("simple-api-actix-web")]),e._v("Â , navigate into the newly-created folder, and open the folder in VS Code. Feel free to use any IDE or text editor you are more comfortable with.")]),e._v(" "),t("p",[e._v("Now open the integrated terminal in your code editor and runÂ "),t("a",{attrs:{href:"https://doc.rust-lang.org/cargo/commands/cargo-init.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cargoâ€™s init function"),t("OutboundLink")],1),e._v("Â to initialize the Rust project in the current directory.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo init\n")])])]),t("p",[e._v("In the console of the root directory, run these commands to add the following dependencies to theÂ "),t("code",[e._v("Cargo.toml")]),e._v("Â manifest file.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo add actix-web\ncargo add actix-cors\ncargo add serde --features derive\ncargo add chrono --features serde\ncargo add env_logger\ncargo add uuid --features v4\n")])])]),t("ul",[t("li",[t("code",[e._v("[actix-web](https://crates.io/crates/actix-web)")]),e._v("Â â€“ A web framework for Rust.")]),e._v(" "),t("li",[t("code",[e._v("[actix-cors](https://crates.io/crates/actix-cors)")]),e._v("Â â€“ This crate provides CORS (Cross-Origin Resource Sharing) support for the Actix web framework.")]),e._v(" "),t("li",[t("code",[e._v("[serde](https://crates.io/crates/serde)")]),e._v("Â â€“ This crate provides a framework to convert Rust data structures to and from various formats such as JSON, YAML, TOML, and more.")]),e._v(" "),t("li",[t("code",[e._v("[chrono](https://crates.io/crates/chrono)")]),e._v("Â â€“ This crate provides a set of types for representing and manipulating dates, times, durations, and time zones in Rust.")]),e._v(" "),t("li",[t("code",[e._v("[env_logger](https://crates.io/crates/env_logger)")]),e._v("Â â€“ This crate is built on top of theÂ "),t("code",[e._v("[log](https://crates.io/crates/log)")]),e._v("Â crate and it allows you to initialize and configure a logger via environment variables.")]),e._v(" "),t("li",[t("code",[e._v("[uuid](https://crates.io/crates/uuid)")]),e._v("Â â€“ This crate provides a simple and efficient way to generate and parse UUIDs in Rust.")])]),e._v(" "),t("p",[e._v("In case the latest versions of the above dependencies break your app, you can replace the content of yourÂ "),t("code",[e._v("Cargo.toml")]),e._v("Â file with the code below.")]),e._v(" "),t("p",[t("strong",[e._v("Cargo.toml")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n[package]\nname = "simple-api-actix-web"\nversion = "0.1.0"\nedition = "2021"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nactix-cors = "0.6.4"\nactix-web = "4.2.1"\nchrono = { version = "0.4.23", features = ["serde"] }\nenv_logger = "0.10.0"\nserde = { version = "1.0.152", features = ["derive"] }\nuuid = { version = "1.2.2", features = ["v4"] }\n')])])]),t("p",[e._v("Now letâ€™s create a simple HTTP server with Actix web to get our hands dirty. To do this, open theÂ "),t("code",[e._v("src/main.rs")]),e._v("Â file and replace its content with the following code snippets.")]),e._v(" "),t("p",[t("strong",[e._v("src/main.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nuse actix_web::middleware::Logger;\nuse actix_web::{get, App, HttpResponse, HttpServer, Responder};\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct GenericResponse {\n    pub status: String,\n    pub message: String,\n}\n\n#[get("/api/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    if std::env::var_os("RUST_LOG").is_none() {\n        std::env::set_var("RUST_LOG", "actix_web=info");\n    }\n    env_logger::init();\n\n    println!("ğŸš€ Server started successfully");\n\n    HttpServer::new(move || {\n        App::new()\n            .service(health_checker_handler)\n            .wrap(Logger::default())\n    })\n    .bind(("127.0.0.1", 8000))?\n    .run()\n    .await\n}\n')])])]),t("p",[e._v("In the above code, we created aÂ "),t("code",[e._v("GenericResponse")]),e._v("Â struct that implements theÂ "),t("strong",[e._v("Serialize")]),e._v("Â trait of the Serde crate. Then, we created aÂ "),t("code",[e._v("/api/healthchecker")]),e._v("Â route to respond with a JSON object containing a â€œ"),t("em",[e._v("message")]),e._v("â€ property with the value â€œBuild Simple CRUD API with Rust and Actix Webâ€œ.")]),e._v(" "),t("p",[e._v("If you have a Node.js background, you may be familiar with the Nodemon package which restarts the server when files change. Well, in Rust, we have a command-line tool calledÂ "),t("code",[e._v("[cargo-watch](https://crates.io/crates/cargo-watch)")]),e._v("Â that can watch the source code for changes and hot-reload the server.")]),e._v(" "),t("p",[e._v("You can installÂ "),t("code",[e._v("cargo-watch")]),e._v("Â with this command:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo install cargo-watch \n")])])]),t("p",[e._v("Once installed, you can run this command to start the Actix Web HTTP server and restart the server when a file in theÂ "),t("strong",[e._v("src")]),e._v("Â directory changes. Feel free to use the Cargo CLI instead.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo watch -q -c -w src/ -x run\n")])])]),t("p",[e._v("Now that the Actix Web server is up and running, send aÂ "),t("strong",[e._v("GET")]),e._v("Â request toÂ "),t("code",[e._v("http://localhost:8000/api/healthchecker")]),e._v("Â and you should receive a JSON object with the message â€œBuild Simple CRUD API with Rust and Actix Webâ€œ.")]),e._v(" "),t("p",[e._v("![testing the health checker route of the actix web api](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22977%22%20height=%22316%22%3E%3C/svg%3E)")]),e._v(" "),t("h2",{attrs:{id:"setup-the-database-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup-the-database-model"}},[e._v("#")]),e._v(" Setup the Database Model")]),e._v(" "),t("p",[e._v("Let me clear the air first. We wonâ€™t use a real database in this project to keep things simple. However, youâ€™ll create a centralized data store that will be shared across the route handlers using a Mutex, vector, and Rustâ€™s smart pointer called Arc.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://doc.rust-lang.org/std/sync/struct.Arc.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arc"),t("OutboundLink")],1),e._v("Â will allow the in-memory database to be shared across multiple threads andÂ "),t("a",{attrs:{href:"https://doc.rust-lang.org/std/sync/struct.Mutex.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mutex"),t("OutboundLink")],1),e._v("Â will enable safe access to the data store even if multiple threads are accessing it at the same time.")]),e._v(" "),t("p",[e._v("To set up the in-memory database, create aÂ "),t("code",[e._v("model.rs")]),e._v("Â file in theÂ "),t("strong",[e._v("src")]),e._v("Â directory and add the following code.")]),e._v(" "),t("p",[t("strong",[e._v("src/model.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse chrono::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, Mutex};\n\n#[allow(non_snake_case)]\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Todo {\n    pub id: Option<String>,\n    pub title: String,\n    pub content: String,\n    pub completed: Option<bool>,\n    pub createdAt: Option<DateTime<Utc>>,\n    pub updatedAt: Option<DateTime<Utc>>,\n}\n\npub struct AppState {\n    pub todo_db: Arc<Mutex<Vec<Todo>>>,\n}\n\nimpl AppState {\n    pub fn init() -> AppState {\n        AppState {\n            todo_db: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct QueryOptions {\n    pub page: Option<usize>,\n    pub limit: Option<usize>,\n}\n\n#[allow(non_snake_case)]\n#[derive(Debug, Deserialize)]\npub struct UpdateTodoSchema {\n    pub title: Option<String>,\n    pub content: Option<String>,\n    pub completed: Option<bool>,\n}\n")])])]),t("p",[e._v("Above, we defined aÂ "),t("strong",[e._v("Todo")]),e._v("Â struct to represent the structure of a Todo item. Then, we created anÂ "),t("strong",[e._v("AppState")]),e._v("Â struct which has aÂ "),t("code",[e._v("Arc<Mutex<Vec<Todo>>>")]),e._v("Â field calledÂ "),t("code",[e._v("todo_db")]),e._v("Â that stores the data.")]),e._v(" "),t("p",[e._v("TheÂ "),t("strong",[e._v("AppState")]),e._v("Â struct has anÂ "),t("strong",[e._v("init")]),e._v("Â function that creates a new instance of theÂ "),t("strong",[e._v("AppState")]),e._v("Â struct and initializes it with an empty vector. At the bottom, we createdÂ "),t("code",[e._v("QueryOptions")]),e._v("Â andÂ "),t("code",[e._v("UpdateTodoSchema")]),e._v("Â structs to help us deserialize the incoming request bodies into structs.")]),e._v(" "),t("h2",{attrs:{id:"create-the-api-response-structs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#create-the-api-response-structs"}},[e._v("#")]),e._v(" Create the API Response Structs")]),e._v(" "),t("p",[e._v("Now that weâ€™ve set up the data store, letâ€™s create structs that implement Serdeâ€™sÂ "),t("strong",[e._v("Serialize")]),e._v("Â trait. This is required because Actix-webâ€™sÂ "),t("code",[e._v("HttpResponseBuilder")]),e._v("Â function experts structs that implement theÂ "),t("strong",[e._v("Serialize")]),e._v("Â trait.")]),e._v(" "),t("p",[t("strong",[e._v("src/response.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse serde::Serialize;\n\nuse crate::model::Todo;\n\n#[derive(Serialize)]\npub struct GenericResponse {\n    pub status: String,\n    pub message: String,\n}\n\n#[derive(Serialize, Debug)]\npub struct TodoData {\n    pub todo: Todo,\n}\n\n#[derive(Serialize, Debug)]\npub struct SingleTodoResponse {\n    pub status: String,\n    pub data: TodoData,\n}\n\n#[derive(Serialize, Debug)]\npub struct TodoListResponse {\n    pub status: String,\n    pub results: usize,\n    pub todos: Vec<Todo>,\n}\n")])])]),t("h2",{attrs:{id:"add-the-crud-functionalities"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-the-crud-functionalities"}},[e._v("#")]),e._v(" Add the CRUD Functionalities")]),e._v(" "),t("p",[e._v("When building APIs, it is common to add CRUD functionalities to interact with the data. This can be done by creating higher-level CRUD functions that implement the lower-level CRUD functions provided by an ORM or a database driver.")]),e._v(" "),t("p",[e._v("Implementing CRUD functionalities can be a complex task, but it is a fundamental aspect of any API that needs to persist data. In this section, weâ€™ll create route handlers to add CRUD functionalities to the Actix Web API. Below is the list of routes the API will have.")]),e._v(" "),t("ul",[t("li",[t("code",[e._v('#[get("/healthchecker")]')]),e._v("Â â€“ This route will send a JSON object that contains a message field.")]),e._v(" "),t("li",[t("code",[e._v('#[get("/todos")]')]),e._v("Â â€“ This route will retrieve a list of Todo items from the data store and send them in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[post("/todos")]')]),e._v("Â â€“ This route will add a new Todo item to the data store and return the newly-created item in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[get("/todos/{id}")]')]),e._v("Â â€“ This route will find a Todo item by ID and return the found item in the JSON response.")]),e._v(" "),t("li",[t("code",[e._v('#[patch("/todos/{id}")]')]),e._v("Â â€“ This route will find a Todo item by ID and edit the fields of the found item based on the request payload.")]),e._v(" "),t("li",[t("code",[e._v('#[delete("/todos/{id}")]')]),e._v("Â â€“ This route will find a Todo item by ID and delete it from the data store.")])]),e._v(" "),t("p",[e._v("To begin, go into theÂ "),t("strong",[e._v("src")]),e._v("Â directory and create aÂ "),t("code",[e._v("handler.rs")]),e._v("Â file. Within theÂ "),t("code",[e._v("handler.rs")]),e._v("Â file, add the following modules and dependencies.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nuse crate::{\n    model::{AppState, QueryOptions, Todo, UpdateTodoSchema},\n    response::{GenericResponse, SingleTodoResponse, TodoData, TodoListResponse},\n};\nuse actix_web::{delete, get, patch, post, web, HttpResponse, Responder};\nuse chrono::prelude::*;\nuse uuid::Uuid;\n")])])]),t("h3",{attrs:{id:"health-checker-route"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#health-checker-route"}},[e._v("#")]),e._v(" Health Checker Route")]),e._v(" "),t("p",[e._v("This route controller will be called to return a simple JSON object when the Actix Web server receives aÂ "),t("strong",[e._v("GET")]),e._v("Â request on theÂ "),t("code",[e._v("/api/healthchecker")]),e._v("Â path.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n')])])]),t("p",[e._v("TheÂ "),t("code",[e._v("HttpResponse::Ok().json(response_json)")]),e._v("Â method will serialize theÂ "),t("strong",[e._v("GenericResponse")]),e._v("Â struct, set the correct headers, and return the JSON object to the client.")]),e._v(" "),t("h3",{attrs:{id:"fetch-all-records"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch-all-records"}},[e._v("#")]),e._v(" Fetch All Records")]),e._v(" "),t("p",[e._v("The first CRUD functionality weâ€™ll implement isÂ "),t("strong",[e._v("READ")]),e._v(". This route function will be called to return a list of Todo items when the Actix Web server receives aÂ "),t("strong",[e._v("GET")]),e._v("Â request on theÂ "),t("code",[e._v("/api/todos")]),e._v("Â path.")]),e._v(" "),t("p",[e._v("The route handler will have a pagination feature where the user can request a selected list of records. This will improve the performance of the API when dealing with large datasets.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/todos")]\npub async fn todos_list_handler(\n    opts: web::Query<QueryOptions>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let todos = data.todo_db.lock().unwrap();\n\n    let limit = opts.limit.unwrap_or(10);\n    let offset = (opts.page.unwrap_or(1) - 1) * limit;\n\n    let todos: Vec<Todo> = todos.clone().into_iter().skip(offset).take(limit).collect();\n\n    let json_response = TodoListResponse {\n        status: "success".to_string(),\n        results: todos.len(),\n        todos,\n    };\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Above, we fetched the list of Todo items from the data store, skipped a number of elements based on theÂ "),t("code",[e._v("offset")]),e._v("Â value, limited the number of results based on theÂ "),t("code",[e._v("limit")]),e._v("Â value, and returned the resulting list of Todo items in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"create-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#create-a-record"}},[e._v("#")]),e._v(" Create a Record")]),e._v(" "),t("p",[e._v("The next CRUD functionality isÂ "),t("strong",[e._v("CREATE")]),e._v(". Actix Web will call this route function to add a Todo item to the data store when aÂ "),t("strong",[e._v("POST")]),e._v("Â request is made to theÂ "),t("code",[e._v("/api/todos")]),e._v("Â endpoint.")]),e._v(" "),t("p",[e._v("To prevent duplicates in the data store, weâ€™ll first check if a record with thatÂ "),t("strong",[e._v("title")]),e._v("Â already exists. If a Todo item with that title already exists, aÂ "),t("strong",[e._v("409 Conflict error")]),e._v("Â will be sent to the client.")]),e._v(" "),t("p",[e._v("Otherwise, aÂ "),t("strong",[e._v("UUID")]),e._v("Â will be generated for the new record and persisted in the in-memory database. After that, the newly-added record will be returned in the JSON response.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[post("/todos")]\nasync fn create_todo_handler(\n    mut body: web::Json<Todo>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let todo = vec.iter().find(|todo| todo.title == body.title);\n\n    if todo.is_some() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with title: \'{}\' already exists", body.title),\n        };\n        return HttpResponse::Conflict().json(error_response);\n    }\n\n    let uuid_id = Uuid::new_v4();\n    let datetime = Utc::now();\n\n    body.id = Some(uuid_id.to_string());\n    body.completed = Some(false);\n    body.createdAt = Some(datetime);\n    body.updatedAt = Some(datetime);\n\n    let todo = body.to_owned();\n\n    vec.push(body.into_inner());\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("h3",{attrs:{id:"retrieve-a-single-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-a-single-record"}},[e._v("#")]),e._v(" Retrieve a Single Record")]),e._v(" "),t("p",[e._v("Now letâ€™s perform the secondÂ "),t("strong",[e._v("READ")]),e._v("Â operation. To do this, weâ€™ll create a route function that Actix Web will use to retrieve a single record byÂ "),t("strong",[e._v("ID")]),e._v("Â from the data store and return the found record to the client.")]),e._v(" "),t("p",[e._v("This route handler will be called when aÂ "),t("strong",[e._v("GET")]),e._v("Â request hits the server at the"),t("code",[e._v("/api/todos/{id}")]),e._v("Â endpoint. If no record with thatÂ "),t("strong",[e._v("ID")]),e._v("Â was found, aÂ "),t("strong",[e._v("404 Not Found error")]),e._v("Â will be sent to the client.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[get("/todos/{id}")]\nasync fn get_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Otherwise, the Todo item that matches the query will be returned to the client in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"edit-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#edit-a-record"}},[e._v("#")]),e._v(" Edit a Record")]),e._v(" "),t("p",[e._v("Itâ€™s now time to perform theÂ "),t("strong",[e._v("UPDATE")]),e._v("Â operation. When aÂ "),t("strong",[e._v("PATCH")]),e._v("Â request is made to theÂ "),t("code",[e._v("/api/todos/{id}")]),e._v("Â endpoint, Actix Web will evoke this route handler to process the request.")]),e._v(" "),t("p",[e._v("When Actix Web delegates theÂ "),t("strong",[e._v("PATCH")]),e._v("Â request to this route function, it will query the data store to find the record by the providedÂ "),t("strong",[e._v("ID")]),e._v("Â and update its fields based on the data available in the request body.")]),e._v(" "),t("p",[e._v("If no record with that ID exists in the in-memory database, aÂ "),t("strong",[e._v("404 Not Found error")]),e._v("Â will be returned to the client.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[patch("/todos/{id}")]\nasync fn edit_todo_handler(\n    path: web::Path<String>,\n    body: web::Json<UpdateTodoSchema>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let datetime = Utc::now();\n    let title = body.title.to_owned().unwrap_or(todo.title.to_owned());\n    let content = body.content.to_owned().unwrap_or(todo.content.to_owned());\n    let payload = Todo {\n        id: todo.id.to_owned(),\n        title: if !title.is_empty() {\n            title\n        } else {\n            todo.title.to_owned()\n        },\n        content: if !content.is_empty() {\n            content\n        } else {\n            todo.content.to_owned()\n        },\n        completed: if body.completed.is_some() {\n            body.completed\n        } else {\n            todo.completed\n        },\n        createdAt: todo.createdAt,\n        updatedAt: Some(datetime),\n    };\n    *todo = payload;\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n')])])]),t("p",[e._v("Otherwise, the newly-updated record will be sent to the client in the JSON response.")]),e._v(" "),t("h3",{attrs:{id:"delete-a-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delete-a-record"}},[e._v("#")]),e._v(" Delete a Record")]),e._v(" "),t("p",[e._v("Finally, letâ€™s perform the last CRUD operation which isÂ "),t("strong",[e._v("DELETE")]),e._v(". When the Actix Web server receives aÂ "),t("strong",[e._v("DELETE")]),e._v("Â request on theÂ "),t("code",[e._v("/api/todos/{id}")]),e._v("Â endpoint, it will call this route function to remove the record that matches the providedÂ "),t("strong",[e._v("ID")]),e._v("Â from the data store.")]),e._v(" "),t("p",[e._v("If no record was found, aÂ "),t("strong",[e._v("404 Not Found error")]),e._v("Â will be returned to the client. Otherwise a 204 No Content response will be sent.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n#[delete("/todos/{id}")]\nasync fn delete_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    vec.retain(|todo| todo.id != Some(id.to_owned()));\n    HttpResponse::NoContent().finish()\n}\n')])])]),t("h3",{attrs:{id:"merge-the-routes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#merge-the-routes"}},[e._v("#")]),e._v(" Merge the Routes")]),e._v(" "),t("p",[e._v("Now that weâ€™ve defined all the route functions, letâ€™s use Actix-webâ€™sÂ "),t("code",[e._v('web::scope("")')]),e._v("Â function to group them under aÂ "),t("code",[e._v("/api")]),e._v("Â prefix.")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\npub fn config(conf: &mut web::ServiceConfig) {\n    let scope = web::scope("/api")\n        .service(health_checker_handler)\n        .service(todos_list_handler)\n        .service(create_todo_handler)\n        .service(get_todo_handler)\n        .service(edit_todo_handler)\n        .service(delete_todo_handler);\n\n    conf.service(scope);\n}\n')])])]),t("h3",{attrs:{id:"complete-route-controllers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#complete-route-controllers"}},[e._v("#")]),e._v(" Complete Route Controllers")]),e._v(" "),t("p",[t("strong",[e._v("src/handler.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nuse crate::{\n    model::{AppState, QueryOptions, Todo, UpdateTodoSchema},\n    response::{GenericResponse, SingleTodoResponse, TodoData, TodoListResponse},\n};\nuse actix_web::{delete, get, patch, post, web, HttpResponse, Responder};\nuse chrono::prelude::*;\nuse uuid::Uuid;\n\n#[get("/healthchecker")]\nasync fn health_checker_handler() -> impl Responder {\n    const MESSAGE: &str = "Build Simple CRUD API with Rust and Actix Web";\n\n    let response_json = &GenericResponse {\n        status: "success".to_string(),\n        message: MESSAGE.to_string(),\n    };\n    HttpResponse::Ok().json(response_json)\n}\n\n#[get("/todos")]\npub async fn todos_list_handler(\n    opts: web::Query<QueryOptions>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let todos = data.todo_db.lock().unwrap();\n\n    let limit = opts.limit.unwrap_or(10);\n    let offset = (opts.page.unwrap_or(1) - 1) * limit;\n\n    let todos: Vec<Todo> = todos.clone().into_iter().skip(offset).take(limit).collect();\n\n    let json_response = TodoListResponse {\n        status: "success".to_string(),\n        results: todos.len(),\n        todos,\n    };\n    HttpResponse::Ok().json(json_response)\n}\n\n#[post("/todos")]\nasync fn create_todo_handler(\n    mut body: web::Json<Todo>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let todo = vec.iter().find(|todo| todo.title == body.title);\n\n    if todo.is_some() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with title: \'{}\' already exists", body.title),\n        };\n        return HttpResponse::Conflict().json(error_response);\n    }\n\n    let uuid_id = Uuid::new_v4();\n    let datetime = Utc::now();\n\n    body.id = Some(uuid_id.to_string());\n    body.completed = Some(false);\n    body.createdAt = Some(datetime);\n    body.updatedAt = Some(datetime);\n\n    let todo = body.to_owned();\n\n    vec.push(body.into_inner());\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[get("/todos/{id}")]\nasync fn get_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[patch("/todos/{id}")]\nasync fn edit_todo_handler(\n    path: web::Path<String>,\n    body: web::Json<UpdateTodoSchema>,\n    data: web::Data<AppState>,\n) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    let todo = todo.unwrap();\n    let datetime = Utc::now();\n    let title = body.title.to_owned().unwrap_or(todo.title.to_owned());\n    let content = body.content.to_owned().unwrap_or(todo.content.to_owned());\n    let payload = Todo {\n        id: todo.id.to_owned(),\n        title: if !title.is_empty() {\n            title\n        } else {\n            todo.title.to_owned()\n        },\n        content: if !content.is_empty() {\n            content\n        } else {\n            todo.content.to_owned()\n        },\n        completed: if body.completed.is_some() {\n            body.completed\n        } else {\n            todo.completed\n        },\n        createdAt: todo.createdAt,\n        updatedAt: Some(datetime),\n    };\n    *todo = payload;\n\n    let json_response = SingleTodoResponse {\n        status: "success".to_string(),\n        data: TodoData { todo: todo.clone() },\n    };\n\n    HttpResponse::Ok().json(json_response)\n}\n\n#[delete("/todos/{id}")]\nasync fn delete_todo_handler(path: web::Path<String>, data: web::Data<AppState>) -> impl Responder {\n    let mut vec = data.todo_db.lock().unwrap();\n\n    let id = path.into_inner();\n    let todo = vec.iter_mut().find(|todo| todo.id == Some(id.to_owned()));\n\n    if todo.is_none() {\n        let error_response = GenericResponse {\n            status: "fail".to_string(),\n            message: format!("Todo with ID: {} not found", id),\n        };\n        return HttpResponse::NotFound().json(error_response);\n    }\n\n    vec.retain(|todo| todo.id != Some(id.to_owned()));\n    HttpResponse::NoContent().finish()\n}\n\npub fn config(conf: &mut web::ServiceConfig) {\n    let scope = web::scope("/api")\n        .service(health_checker_handler)\n        .service(todos_list_handler)\n        .service(create_todo_handler)\n        .service(get_todo_handler)\n        .service(edit_todo_handler)\n        .service(delete_todo_handler);\n\n    conf.service(scope);\n}\n')])])]),t("h2",{attrs:{id:"add-cors-to-the-actix-web-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-cors-to-the-actix-web-server"}},[e._v("#")]),e._v(" Add CORS to the Actix Web Server")]),e._v(" "),t("p",[e._v("Now that weâ€™ve created the route handlers, in-memory database, and response structs, letâ€™s import their respective files as modules into theÂ "),t("code",[e._v("src/main.rs")]),e._v("Â file and add CORS headers to the Actix Web server.")]),e._v(" "),t("p",[e._v("To add CORS headers, weâ€™ll use theÂ "),t("code",[e._v("Cors")]),e._v("Â struct middleware provided by theÂ "),t("code",[e._v("actix_cors")]),e._v("Â crate to define the headers and wrap them around the routes. So, open theÂ "),t("strong",[e._v("src/main.rs")]),e._v("Â file and replace its content with the following code.")]),e._v(" "),t("p",[t("strong",[e._v("src/main.rs")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nmod handler;\nmod model;\nmod response;\n\nuse actix_cors::Cors;\nuse actix_web::middleware::Logger;\nuse actix_web::{http::header, web, App, HttpServer};\nuse model::AppState;\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    if std::env::var_os("RUST_LOG").is_none() {\n        std::env::set_var("RUST_LOG", "actix_web=info");\n    }\n    env_logger::init();\n\n    let todo_db = AppState::init();\n    let app_data = web::Data::new(todo_db);\n\n    println!("ğŸš€ Server started successfully");\n\n    HttpServer::new(move || {\n        let cors = Cors::default()\n            .allowed_origin("http://localhost:3000")\n            .allowed_origin("http://localhost:3000/")\n            .allowed_methods(vec!["GET", "POST"])\n            .allowed_headers(vec![\n                header::CONTENT_TYPE,\n                header::AUTHORIZATION,\n                header::ACCEPT,\n            ])\n            .supports_credentials();\n        App::new()\n            .app_data(app_data.clone())\n            .configure(handler::config)\n            .wrap(cors)\n            .wrap(Logger::default())\n    })\n    .bind(("127.0.0.1", 8000))?\n    .run()\n    .await\n}\n')])])]),t("p",[e._v("With that out of the way, run the command below to start the Actix Web HTTP server again.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\ncargo watch -q -c -w src/ -x run\n")])])]),t("h2",{attrs:{id:"test-the-actix-web-crud-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#test-the-actix-web-crud-api"}},[e._v("#")]),e._v(" Test the Actix Web CRUD API")]),e._v(" "),t("p",[e._v("Now that the Actix Web HTTP server is ready to accept requests, clone the project, import theÂ "),t("code",[e._v("Todo.postman_collection.json")]),e._v("Â file into Postman, and test the endpoints.")]),e._v(" "),t("h3",{attrs:{id:"add-a-new-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#add-a-new-todo-item"}},[e._v("#")]),e._v(" Add a New Todo Item")]),e._v(" "),t("p",[e._v("To create a new Todo item, add a JSON object that contains â€œ"),t("strong",[e._v("title")]),e._v("â€ and â€œ"),t("strong",[e._v("content")]),e._v("â€ fields to the request body and make aÂ "),t("strong",[e._v("POST")]),e._v("Â request to theÂ "),t("code",[e._v("http://localhost:8000/api/todos")]),e._v("Â endpoint.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n{\n    "title": "Learn how to build a CRUD API with Actix Web framework in Rust",\n    "content": "Rust a system programming language"\n}\n')])])]),t("p",[e._v("The Actix Web server will call the appropriate route handler to add the new item to the data store and return the newly-added item in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api add a new record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22926%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"edit-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#edit-a-todo-item"}},[e._v("#")]),e._v(" Edit a Todo Item")]),e._v(" "),t("p",[e._v("To edit the fields of a Todo item in the data store, add the edited JSON object to the request body and make aÂ "),t("strong",[e._v("PATCH")]),e._v("Â request to theÂ "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v("Â endpoint.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n{\n    "title": "New title for the Actix Web CRUD API âœ…ğŸš€",\n    "completed": true\n}\n')])])]),t("p",[e._v("The Actix web server will call the appropriate route handler to edit the fields of the item that matches the ID parameter and return the newly-updated item in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api edit a record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22893%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"retrieve-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-a-todo-item"}},[e._v("#")]),e._v(" Retrieve a Todo Item")]),e._v(" "),t("p",[e._v("Here, you can append the ID of a record to the URL parameter and make aÂ "),t("strong",[e._v("GET")]),e._v("Â request to theÂ "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v("Â endpoint. This will return the Todo item that matches the ID in the JSON response.")]),e._v(" "),t("p",[e._v("![actix web crud api retrieve a single record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22908%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"retrieve-all-todo-items"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#retrieve-all-todo-items"}},[e._v("#")]),e._v(" Retrieve All Todo Items")]),e._v(" "),t("p",[e._v("Now letâ€™s perform theÂ "),t("strong",[e._v("READ")]),e._v("Â operation of CRUD to retrieve a paginated list of Todo items from the in-memory database. To do that, addÂ "),t("strong",[e._v("limit")]),e._v("Â andÂ "),t("strong",[e._v("page")]),e._v("Â query parameters to the request URL and make aÂ "),t("strong",[e._v("GET")]),e._v("Â request to theÂ "),t("code",[e._v("http://localhost:8000/api/todos?page=1&limit=10")]),e._v("Â endpoint.")]),e._v(" "),t("p",[e._v("If theÂ "),t("strong",[e._v("limit")]),e._v("Â andÂ "),t("strong",[e._v("page")]),e._v("Â query parameters are absent in the URL, the Actix Web server will only return the first 10 results.")]),e._v(" "),t("p",[e._v("![actix web crud api fetch all records](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%221024%22%20height=%22963%22%3E%3C/svg%3E)")]),e._v(" "),t("h3",{attrs:{id:"delete-a-todo-item"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delete-a-todo-item"}},[e._v("#")]),e._v(" Delete a Todo Item")]),e._v(" "),t("p",[e._v("Finally, letâ€™s perform theÂ "),t("strong",[e._v("DELETE")]),e._v("Â operation of CRUD. So, add the Todo itemâ€™s ID to the URL parameter and make aÂ "),t("strong",[e._v("DELETE")]),e._v("Â request to theÂ "),t("code",[e._v("http://localhost:8000/api/todos/{id}")]),e._v("Â endpoint. The Actix web server will find the Todo item by ID and delete it from the data store.")]),e._v(" "),t("p",[e._v("![actix web crud api delete a record](data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%22886%22%20height=%22670%22%3E%3C/svg%3E)")]),e._v(" "),t("h2",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),t("p",[e._v("Congrats on making it to the end. In this article, you learned how to build a simple CRUD API in Rust using the Actix Web framework. In addition, you learned how to set up an in-memory database with a struct, Arc, and Mutex.")]),e._v(" "),t("p",[e._v("You can find the complete source code of the Actix Web API onÂ "),t("a",{attrs:{href:"https://github.com/wpcodevo/simple-api-actix-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=a.exports}}]);