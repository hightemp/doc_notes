(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{308:function(t,e,v){"use strict";v.r(e);var a=v(14),_=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Шаблоны проектирования — это многоразовые решения общих проблем с программным обеспечением, возникающих в процессе разработки. Они обеспечивают структурированный подход к решению этих проблем и позволяют разработчикам создавать более эффективное, удобное в сопровождении и масштабируемое программное обеспечение. Существует три основных категории шаблонов проектирования: творческие, структурные и поведенческие. Порождающие паттерны сосредоточены на создании объектов, в то время как структурные паттерны имеют дело с композицией объектов. Поведенческие паттерны связаны с общением между объектами и тем, как они взаимодействуют друг с другом. Некоторые популярные шаблоны проектирования включают шаблон Singleton, шаблон Factory, шаблон Observer и шаблон Decorator. Важно отметить, что шаблоны проектирования не панацея, и их следует использовать с осторожностью. Они могут усложнить кодовую базу и вызвать проблемы с производительностью, если они не реализованы должным образом.")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Паттерн проектирования")]),t._v(" "),e("th",[t._v("Описание")]),t._v(" "),e("th",[t._v("Критерии использования")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("Синглтон (Singleton)")]),t._v(" "),e("td",[t._v("Гарантирует, что класс имеет только один экземпляр, и обеспечивает к нему глобальную точку доступа.")]),t._v(" "),e("td",[t._v("Когда нужен только один экземпляр класса в приложении, например, для доступа к базе данных.")])]),t._v(" "),e("tr",[e("td",[t._v("Фабричный метод (Factory Method)")]),t._v(" "),e("td",[t._v("Определяет интерфейс для создания объектов, но позволяет подклассам выбирать классы для создания.")]),t._v(" "),e("td",[t._v("Когда нужно создавать объекты на основе определенных условий, например, при создании продуктов в интернет-магазине.")])]),t._v(" "),e("tr",[e("td",[t._v("Абстрактная фабрика (Abstract Factory)")]),t._v(" "),e("td",[t._v("Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не указывая их конкретных классов.")]),t._v(" "),e("td",[t._v("Когда нужно создавать объекты, которые должны работать вместе, например, для создания компонентов интерфейса.")])]),t._v(" "),e("tr",[e("td",[t._v("Строитель (Builder)")]),t._v(" "),e("td",[t._v("Позволяет создавать сложные объекты пошагово, разделяя процесс конструирования и представление объекта.")]),t._v(" "),e("td",[t._v("Когда нужно создавать объекты с большим количеством параметров или настроек, например, для создания заказа в интернет-магазине.")])]),t._v(" "),e("tr",[e("td",[t._v("Прототип (Prototype)")]),t._v(" "),e("td",[t._v("Позволяет создавать новые объекты на основе уже существующих объектов-прототипов, избегая повторного создания объектов с нуля.")]),t._v(" "),e("td",[t._v("Когда нужно создавать множество похожих объектов с небольшими отличиями, например, для создания копий документов.")])]),t._v(" "),e("tr",[e("td",[t._v("Адаптер (Adapter)")]),t._v(" "),e("td",[t._v("Позволяет объектам с несовместимыми интерфейсами работать вместе.")]),t._v(" "),e("td",[t._v("Когда нужно использовать объекты с разными интерфейсами или сторонние библиотеки, которые не могут быть изменены.")])]),t._v(" "),e("tr",[e("td",[t._v("Мост (Bridge)")]),t._v(" "),e("td",[t._v("Отделяет абстракцию от ее реализации, позволяя им меняться независимо друг от друга.")]),t._v(" "),e("td",[t._v("Когда нужно связать две или более иерархии классов, например, для создания разных типов приложений на основе одной библиотеки.")])]),t._v(" "),e("tr",[e("td",[t._v("Компоновщик (Composite)")]),t._v(" "),e("td",[t._v("Позволяет объединять объекты в древовидные структуры для представления иерархий частей-целого.")]),t._v(" "),e("td",[t._v("Когда нужно работать с частями иерархической структуры как с единым целым, например, для работы с документами и их элементами.")])]),t._v(" "),e("tr",[e("td",[t._v("Декоратор (Decorator)")]),t._v(" "),e("td",[t._v("Динамически добавляет объектам новую функциональность, не изменяя их исходного кода.")]),t._v(" "),e("td",[t._v("Когда нужно добавлять дополнительную функциональность объектам без переписывания существующего кода, например, для добавления опций к платежам в интернет-магазине.")])]),t._v(" "),e("tr",[e("td",[t._v("Фасад (Facade)")]),t._v(" "),e("td",[t._v("Предоставляет простой интерфейс для сложной системы объектов, скрывая сложность и детали реализации.")]),t._v(" "),e("td",[t._v("Когда нужно предоставить простой интерфейс для работы с сложной системой, например, для работы с API.")])]),t._v(" "),e("tr",[e("td",[t._v("Прокси (Proxy)")]),t._v(" "),e("td",[t._v("Предоставляет заместитель для другого объекта, который может контролировать доступ к оригинальному объекту.")]),t._v(" "),e("td",[t._v("Когда нужно добавить дополнительную функциональность к объекту без изменения его кода, например, для реализации логирования или кэширования.")])]),t._v(" "),e("tr",[e("td",[t._v("Цепочка обязанностей (Chain of Responsibility)")]),t._v(" "),e("td",[t._v("Позволяет передавать запросы последовательно от одного объекта к другому, пока один из объектов не обработает запрос.")]),t._v(" "),e("td",[t._v("Когда нужно обработать запрос от одного из нескольких объектов, не зная заранее, какой объект обработает запрос.")])]),t._v(" "),e("tr",[e("td",[t._v("Команда (Command)")]),t._v(" "),e("td",[t._v("Инкапсулирует запрос в объект, позволяя запускать их независимо друг от друга.")]),t._v(" "),e("td",[t._v("Когда нужно параметризовать объекты событиями, чтобы их можно было запускать в разное время и с разными параметрами.")])]),t._v(" "),e("tr",[e("td",[t._v("Итератор (Iterator)")]),t._v(" "),e("td",[t._v("Предоставляет способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннего представления.")]),t._v(" "),e("td",[t._v("Когда нужно обеспечить единый способ обхода коллекции, независимо от ее типа.")])]),t._v(" "),e("tr",[e("td",[t._v("Посредник (Mediator)")]),t._v(" "),e("td",[t._v("Определяет объект, который инкапсулирует способ взаимодействия множества объектов, тем самым уменьшая связность между ними.")]),t._v(" "),e("td",[t._v("Когда нужно уменьшить связность между несколькими объектами, чтобы они могли взаимодействовать друг с другом без жесткой зависимости.")])]),t._v(" "),e("tr",[e("td",[t._v("Хранитель (Memento)")]),t._v(" "),e("td",[t._v("Позволяет сохранять и восстанавливать прошлые состояния объекта без раскрытия подробностей его реализации.")]),t._v(" "),e("td",[t._v("Когда нужно сохранять состояние объекта, чтобы его можно было восстановить позже, например, при отмене операции.")])]),t._v(" "),e("tr",[e("td",[t._v("Наблюдатель (Observer)")]),t._v(" "),e("td",[t._v("Определяет зависимость один-ко-многим между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты уведомляются об этом и автоматически обновляются.")]),t._v(" "),e("td",[t._v("Когда нужно реализовать способ уведомления объектов о изменении состояния других объектов без жесткой зависимости между ними.")])]),t._v(" "),e("tr",[e("td",[t._v("Состояние (State)")]),t._v(" "),e("td",[t._v("Позволяет объекту изменять свое поведение в зависимости от своего состояния, не меняя своего класса.")]),t._v(" "),e("td",[t._v("Когда нужно реализовать объект с изменяемым поведением, которое зависит от его состояния, и при этом избежать использования условных операторов.")])]),t._v(" "),e("tr",[e("td",[t._v("Стратегия (Strategy)")]),t._v(" "),e("td",[t._v("Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.")]),t._v(" "),e("td",[t._v("Когда нужно выбирать алгоритм из семейства алгоритмов в зависимости от условий, но при этом избежать использования условных операторов.")])]),t._v(" "),e("tr",[e("td",[t._v("Шаблонный метод (Template Method)")]),t._v(" "),e("td",[t._v("Определяет скелет алгоритма, но позволяет подклассам переопределять некоторые шаги алгоритма, не меняя его структуру в целом.")]),t._v(" "),e("td",[t._v("Когда нужно определить скелет алгоритма, но при этом разрешить подкл")])])])]),t._v(" "),e("ol",[e("li",[t._v("Шаблоны проектирования — это многоразовые решения общих проблем проектирования программного обеспечения.")]),t._v(" "),e("li",[t._v("Они помогают улучшить качество программного обеспечения, его ремонтопригодность и возможность повторного использования.")]),t._v(" "),e("li",[t._v("Они не привязаны к какому-либо конкретному языку программирования или технологии.")]),t._v(" "),e("li",[t._v("Они основаны на принципах объектно-ориентированного программирования (ООП).")]),t._v(" "),e("li",[t._v("Существует три основных категории шаблонов проектирования: творческие, структурные и поведенческие.")]),t._v(" "),e("li",[t._v("Шаблоны создания связаны с механизмами создания объектов.")]),t._v(" "),e("li",[t._v("Структурные паттерны связаны с составом объектов и отношениями.")]),t._v(" "),e("li",[t._v("Поведенческие паттерны сосредоточены на общении между объектами и классами.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования не панацея, и их следует использовать с осторожностью.")]),t._v(" "),e("li",[t._v("Они не заменяют хорошие принципы и методы проектирования.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования можно применять на разных уровнях абстракции, от классов до целых систем.")]),t._v(" "),e("li",[t._v("Их можно применять постепенно, по мере необходимости, и они могут развиваться с течением времени.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования могут помочь сократить время и стоимость разработки за счет повторного использования кода.")]),t._v(" "),e("li",[t._v("Они могут улучшить читаемость и удобство сопровождения кода, предоставляя общий словарь и структуру.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования также могут облегчить общение и сотрудничество между членами команды.")]),t._v(" "),e("li",[t._v("Некоторые популярные шаблоны проектирования включают шаблоны Singleton, Factory, Adapter, Observer и Strategy.")]),t._v(" "),e("li",[t._v("Существуют также анти-шаблоны, которые являются распространенными ошибками проектирования, которые могут привести к низкому качеству программного обеспечения и его ремонтопригодности.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования можно изучать с помощью книг, онлайн-ресурсов и практических занятий.")]),t._v(" "),e("li",[t._v("Они широко используются в промышленности и считаются важным навыком для инженеров-программистов.")]),t._v(" "),e("li",[t._v("Шаблоны проектирования не являются универсальным решением и должны быть адаптированы к конкретным потребностям и ограничениям каждого проекта.")])]),t._v(" "),e("p",[t._v("Вот алгоритм выбора шаблона проектирования при проектировании:")]),t._v(" "),e("ol",[e("li",[t._v("Определите проблему. Определите проблему, которую вы пытаетесь решить, или требование, которое вы пытаетесь выполнить.")]),t._v(" "),e("li",[t._v("Определите контекст: поймите контекст и ограничения проблемы, такие как бизнес-сфера, стек технологий и структура команды.")]),t._v(" "),e("li",[t._v("Проанализируйте проблему: проанализируйте проблему, чтобы определить ключевые требования и ограничения.")]),t._v(" "),e("li",[t._v("Определите соответствующие шаблоны проектирования. Определите шаблоны проектирования, которые могут иметь отношение к проблеме, обратившись к таким ресурсам, как каталоги шаблонов проектирования, книги или онлайн-ресурсы.")]),t._v(" "),e("li",[t._v("Оцените шаблоны проектирования. Оцените шаблоны проектирования на основе требований и ограничений проблемы, таких как пригодность, сложность и ремонтопригодность каждого шаблона.")]),t._v(" "),e("li",[t._v("Выберите наиболее подходящий шаблон проектирования. Выберите шаблон проектирования, который наилучшим образом соответствует требованиям и ограничениям проблемы, а также наиболее подходит для контекста и структуры команды.")]),t._v(" "),e("li",[t._v("Адаптируйте шаблон проектирования. Адаптируйте выбранный шаблон проектирования к конкретным потребностям и ограничениям проблемы, например, путем изменения реализации, добавления дополнительных компонентов или использования других шаблонов проектирования в сочетании.")]),t._v(" "),e("li",[t._v("Примените шаблон проектирования. Примените шаблон проектирования при разработке и реализации решения и убедитесь, что он хорошо задокументирован и понятен команде.")])]),t._v(" "),e("p",[t._v("Следуя этому алгоритму, разработчики могут выбрать наиболее подходящий шаблон проектирования для данной проблемы и обеспечить его эффективную и действенную реализацию.")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("Singleton Pattern: This pattern ensures that a class has only one instance, and provides a global point of access to that instance.")])]),t._v(" "),e("li",[e("p",[t._v("Factory Pattern: This pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.")])]),t._v(" "),e("li",[e("p",[t._v("Adapter Pattern: This pattern allows two incompatible interfaces to work together by creating a class that acts as a bridge between them.")])]),t._v(" "),e("li",[e("p",[t._v("Observer Pattern: This pattern defines a one-to-many relationship between objects, so that when one object changes state, all its dependents are notified and updated automatically.")])]),t._v(" "),e("li",[e("p",[t._v("Decorator Pattern: This pattern allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.")])]),t._v(" "),e("li",[e("p",[t._v("Proxy Pattern: This pattern provides a surrogate or placeholder object, which controls access to another object or resource.")])]),t._v(" "),e("li",[e("p",[t._v("Command Pattern: This pattern encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queues, and logging.")])]),t._v(" "),e("li",[e("p",[t._v("Facade Pattern: This pattern provides a unified interface to a set of interfaces in a subsystem, thereby simplifying the use of the subsystem.")])]),t._v(" "),e("li",[e("p",[t._v("Template Method Pattern: This pattern defines the skeleton of an algorithm in a superclass, but allows subclasses to override specific steps of the algorithm without changing its structure.")])]),t._v(" "),e("li",[e("p",[t._v("State Pattern: This pattern allows an object to alter its behavior when its internal state changes, thereby providing a way to change an object's behavior without changing its class.")])]),t._v(" "),e("li",[e("p",[t._v("Strategy Pattern: This pattern enables the selection of an algorithm at runtime, from a family of algorithms that can perform the same task.")])]),t._v(" "),e("li",[e("p",[t._v("Iterator Pattern: This pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.")])]),t._v(" "),e("li",[e("p",[t._v("Composite Pattern: This pattern composes objects into tree structures to represent part-whole hierarchies, and allows clients to treat individual objects and compositions uniformly.")])]),t._v(" "),e("li",[e("p",[t._v("Flyweight Pattern: This pattern minimizes memory usage by sharing common state between multiple similar objects.")])]),t._v(" "),e("li",[e("p",[t._v("Chain of Responsibility Pattern: This pattern allows an object to pass a request along a chain of potential handlers until one of them handles the request.")])]),t._v(" "),e("li",[e("p",[t._v("Bridge Pattern: This pattern decouples an abstraction from its implementation so that the two can vary independently.")])]),t._v(" "),e("li",[e("p",[t._v("Mediator Pattern: This pattern defines an object that encapsulates how a set of objects interact, thereby promoting loose coupling between the objects.")])]),t._v(" "),e("li",[e("p",[t._v("Interpreter Pattern: This pattern provides a way to evaluate language grammar or expressions.")])]),t._v(" "),e("li",[e("p",[t._v("Memento Pattern: This pattern provides the ability to restore an object to its previous state.")])]),t._v(" "),e("li",[e("p",[t._v("Visitor Pattern: This pattern allows for a new operation to be performed on an object structure without changing the objects themselves, by separating the algorithm from the objects.")])]),t._v(" "),e("li",[e("p",[t._v("Factory Method Pattern: Этот паттерн позволяет создавать объекты, не указывая конкретный класс создаваемого объекта.")])]),t._v(" "),e("li",[e("p",[t._v("Abstract Factory Pattern: Этот паттерн предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания конкретных классов.")])]),t._v(" "),e("li",[e("p",[t._v("Singleton Pattern: Этот паттерн гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.")])]),t._v(" "),e("li",[e("p",[t._v("Prototype Pattern: Этот паттерн позволяет создавать новые объекты путем копирования существующих объектов.")])]),t._v(" "),e("li",[e("p",[t._v("Builder Pattern: Этот паттерн позволяет создавать сложные объекты пошагово, независимо от их внутреннего представления.")])]),t._v(" "),e("li",[e("p",[t._v("Adapter Pattern: Этот паттерн позволяет объектам работать вместе, даже если у них разные интерфейсы.")])]),t._v(" "),e("li",[e("p",[t._v("Bridge Pattern: Этот паттерн отделяет абстракцию от ее реализации, позволяя им изменяться независимо друг от друга.")])]),t._v(" "),e("li",[e("p",[t._v("Decorator Pattern: Этот паттерн позволяет динамически добавлять новые функции объектам, не изменяя их базовой структуры.")])]),t._v(" "),e("li",[e("p",[t._v("Facade Pattern: Этот паттерн предоставляет унифицированный интерфейс для набора интерфейсов в системе.")])]),t._v(" "),e("li",[e("p",[t._v("Composite Pattern: Этот паттерн позволяет работать с объектами как с отдельными экземплярами и группами объектов одновременно.")])]),t._v(" "),e("li",[e("p",[t._v("Proxy Pattern: Этот паттерн позволяет создавать объект-заместитель, который может контролировать доступ к другому объекту.")])]),t._v(" "),e("li",[e("p",[t._v("Observer Pattern: Этот паттерн позволяет объектам наблюдать за изменениями в других объектах и реагировать на них.")])]),t._v(" "),e("li",[e("p",[t._v("Command Pattern: Этот паттерн представляет запросы как объекты, позволяя сохранять историю выполненных действий и отменять их при необходимости.")])]),t._v(" "),e("li",[e("p",[t._v("State Pattern: Этот паттерн позволяет объектам изменять свое поведение в зависимости от своего состояния.")])]),t._v(" "),e("li",[e("p",[t._v("Strategy Pattern: Этот паттерн позволяет выбирать алгоритмы в зависимости от ситуации, обеспечивая гибкость и легкость замены алгоритмов.")])]),t._v(" "),e("li",[e("p",[t._v("Template Method Pattern: Этот паттерн определяет скелет алгоритма в родительском классе, позволяя дочерним классам изменять отдельные шаги этого алгоритма.")])]),t._v(" "),e("li",[e("p",[t._v("Iterator Pattern: Этот паттерн предоставляет способ обхода элементов коллекции без раскрытия ее внутренней реализации.")])]),t._v(" "),e("li",[e("p",[t._v("Interpreter Pattern: Этот паттерн позволяет интерпретировать язык, представляя его грамматику в виде объектов.")])]),t._v(" "),e("li",[e("p",[t._v("Visitor Pattern: Этот паттерн позволяет добавлять новые операции в объектную структуру, не изменяя ее классы.")])]),t._v(" "),e("li",[e("p",[t._v("Chain of Responsibility Pattern: Этот паттерн позволяет последовательно передавать запросы от одного объекта к другому, пока один из объектов не обработает запрос.")])])])])}),[],!1,null,null,null);e.default=_.exports}}]);