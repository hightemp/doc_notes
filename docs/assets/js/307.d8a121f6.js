(window.webpackJsonp=window.webpackJsonp||[]).push([[307],{580:function(e,t,r){"use strict";r.r(t);var s=r(14),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://practice.rs/collections/vector.html")]),e._v(" "),t("p",[e._v("Vectors are resizable arrays. Like slices, their size is not known at compile time, but they can grow or shrink at any time.")]),e._v(" "),t("h3",{attrs:{id:"basic-operations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic-operations"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#basic-operations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Basic Operations"),t("OutboundLink")],1)]),e._v(" "),t("ol",[t("li",[e._v("ðŸŒŸðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('fn main() { let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v); let v = vec![1, 2, 3]; is_vec(v); // vec!(..) and vec![..] are same macros, so let v = vec!(1, 2, 3); is_vec(v); // In code below, v is Vec<[u8; 3]> , not Vec<u8> // USE Vec::new and `for` to rewrite the below code let v1 = vec!(arr); is_vec(v1); assert_eq!(v, v1); println!("Success!"); } fn is_vec(v: Vec<u8>) {}')])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("ðŸŒŸðŸŒŸ A Vec can be extended withÂ "),t("code",[e._v("extend")]),e._v("Â method")])]),e._v(" "),t("p",[t("code",[e._v('// FILL in the blank fn main() { let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.__; assert_eq!(v1, v2); println!("Success!"); }')])]),e._v(" "),t("h3",{attrs:{id:"turn-x-into-vec"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#turn-x-into-vec"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#turn-x-into-vec",target:"_blank",rel:"noopener noreferrer"}},[e._v("Turn X Into Vec"),t("OutboundLink")],1)]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("ðŸŒŸðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('// FILL in the blanks fn main() { // Array -> Vec // impl From<[T; N]> for Vec let arr = [1, 2, 3]; let v1 = __(arr); let v2: Vec<i32> = arr.__(); assert_eq!(v1, v2); // String -> Vec // impl From<String> for Vec let s = "hello".to_string(); let v1: Vec<u8> = s.__(); let s = "hello".to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); // impl<\'_> From<&\'_ str> for Vec let s = "hello"; let v3 = Vec::__(s); assert_eq!(v2, v3); // Iterators can be collected into vectors let v4: Vec<i32> = [0; 10].into_iter().collect(); assert_eq!(v4, vec![0; 10]); println!("Success!"); }')])]),e._v(" "),t("h3",{attrs:{id:"indexing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#indexing"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#indexing",target:"_blank",rel:"noopener noreferrer"}},[e._v("Indexing"),t("OutboundLink")],1)]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("ðŸŒŸðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('// FIX the error and IMPLEMENT the code fn main() { let mut v = Vec::from([1, 2, 3]); for i in 0..5 { println!("{:?}", v[i]) } for i in 0..5 { // IMPLEMENT the code here... } assert_eq!(v, vec![2, 3, 4, 5, 6]); println!("Success!"); }')])]),e._v(" "),t("h3",{attrs:{id:"slicing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slicing"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#slicing",target:"_blank",rel:"noopener noreferrer"}},[e._v("Slicing"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("A Vec can be mutable. On the other hand, slices are read-only objects. To get a slice, useÂ "),t("code",[e._v("&")]),e._v(".")]),e._v(" "),t("p",[e._v("In Rust, itâ€™s more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes forÂ "),t("code",[e._v("String")]),e._v("Â andÂ "),t("code",[e._v("&str")]),e._v(".")]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("ðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('// FIX the errors fn main() { let mut v = vec![1, 2, 3]; let slice1 = &v[..]; // Out of bounds will cause a panic // You must use `v.len` here let slice2 = &v[0..4]; assert_eq!(slice1, slice2); // Slices are read only // Note: slice and &Vec are different let vec_ref: &mut Vec<i32> = &mut v; (*vec_ref).push(4); let slice3 = &mut v[0..3]; slice3.push(4); assert_eq!(slice3, &[1, 2, 3, 4]); println!("Success!"); }')])]),e._v(" "),t("h3",{attrs:{id:"capacity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#capacity"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#capacity",target:"_blank",rel:"noopener noreferrer"}},[e._v("Capacity"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vectorâ€™s length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.")]),e._v(" "),t("p",[e._v("For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vectorâ€™s length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to useÂ "),t("code",[e._v("Vec::with_capacity")]),e._v("Â whenever possible to specify how big the vector is expected to get.")]),e._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[e._v("ðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('// FIX the errors fn main() { let mut vec = Vec::with_capacity(10); // The vector contains no items, even though it has capacity for more assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), 10); // These are all done without reallocating... for i in 0..10 { vec.push(i); } assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); // ...but this may make the vector reallocate vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() >= 11); // Fill in an appropriate value to make the `for` done without reallocating let mut vec = Vec::with_capacity(__); for i in 0..100 { vec.push(i); } assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); println!("Success!"); }')])]),e._v(" "),t("h3",{attrs:{id:"store-distinct-types-in-vector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#store-distinct-types-in-vector"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://practice.rs/collections/vector.html#store-distinct-types-in-vector",target:"_blank",rel:"noopener noreferrer"}},[e._v("Store distinct types in Vector"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The elements in a vector must be the same type, for example , the code below will cause an error:")]),e._v(" "),t("p",[t("code",[e._v("fn main() { let v = vec![1, 2.0, 3]; }")])]),e._v(" "),t("p",[e._v("But we can use enums or trait objects to store distinct types.")]),e._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[e._v("ðŸŒŸðŸŒŸ")])]),e._v(" "),t("p",[t("code",[e._v('#[derive(Debug)] enum IpAddr { V4(String), V6(String), } fn main() { // FILL in the blank let v : Vec<IpAddr>= __; // Comparing two enums need to derive the PartialEq trait assert_eq!(v[0], IpAddr::V4("127.0.0.1".to_string())); assert_eq!(v[1], IpAddr::V6("::1".to_string())); println!("Success!"); }')])])])}),[],!1,null,null,null);t.default=a.exports}}]);