(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{386:function(e,_,t){"use strict";t.r(_);var n=t(14),r=Object(n.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html")]),e._v(" "),_("h1",{attrs:{id:"linux-ip-networking"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux-ip-networking"}},[e._v("#")]),e._v(" **Linux IP Networking")]),e._v(" "),_("p",[e._v("Руководство по реализации и модификации стека протоколов Linux**")]),e._v(" "),_("h3",{attrs:{id:"гленн-херрин"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#гленн-херрин"}},[e._v("#")]),e._v(" "),_("em",[e._v("Гленн Херрин")])]),e._v(" "),_("p",[_("strong",[e._v("ТР 00-04")])]),e._v(" "),_("p",[_("a",{attrs:{href:"http://www.cs.unh.edu/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Департамент компьютерных наук"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"http://www.unh.edu/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Университета Нью-Гэмпшира"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/www.unh.edu",target:"_blank",rel:"noopener noreferrer"}},[_("OutboundLink")],1)]),e._v(" "),_("h3",{attrs:{id:"_31-мая-2000-г"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_31-мая-2000-г"}},[e._v("#")]),e._v(" "),_("em",[e._v("31 мая 2000 г.")])]),e._v(" "),_("p",[_("strong",[e._v("Абстрактный")])]),e._v(" "),_("p",[e._v("Этот документ представляет собой руководство по пониманию того, как ядро ​​Linux (в частности, версия 2.2.14) реализует сетевые протоколы, ориентированные в первую очередь на Интернет-протокол (IP). Он предназначен как полный справочник для экспериментаторов с обзорами, пошаговыми руководствами, объяснениями исходного кода и примерами. Первая часть содержит углубленное изучение кода, структур данных и функциональных возможностей, связанных с сетью. Есть главы об инициализации, соединениях и сокетах, а также о приеме, передаче и пересылке пакетов. Вторая часть содержит подробные инструкции по модификации исходного кода ядра и установке новых модулей. Есть главы по установке ядра, модулей, файловой системы "),_("em",[e._v("proc")]),e._v(" и полный пример.")]),e._v(" "),_("h1",{attrs:{id:"содержание"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#содержание"}},[e._v("#")]),e._v(" Содержание")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1 Введение"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1 Предыстория"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.2 Условные обозначения в документе"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.3 Пример сети"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4 Авторские права, лицензия и отказ от ответственности"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc1.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.5 Благодарности"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp2",target:"_blank",rel:"noopener noreferrer"}},[e._v("2 Обзор трафика сообщений"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1 Путь сетевого трафика"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2 Стек протоколов"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.3 Структура пакета 2.4"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Интернет-маршрутизация"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3 Инициализация сети"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2 Запуск"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.1 Сценарий сетевой инициализации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.2  "),_("em",[e._v("ifconfig")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.3  "),_("em",[e._v("route")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.2.4 Программы динамической маршрутизации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3 Примеры"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.1 Домашний компьютер"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.2 Главный компьютер в локальной сети"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3.3 Компьютер сетевой маршрутизации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4 Функции Linux и сетевых программ"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4.1  "),_("em",[e._v("ifconfig")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc3.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.4.2  "),_("em",[e._v("route")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4 Соединения"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.2 Структуры сокетов"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.3 Сокеты и маршрутизация"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4 Процессы соединения"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.1 Установление соединений"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.2 Прохождение вызовов сокетов"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.3 Прохождение вызовов Connect"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4 .4 Закрытие соединений"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.4.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.4.5 Закрытие обхода"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc4.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.5 Функции Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5 Отправка сообщений"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2 Отправка обхода"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.1 Запись в сокет"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.2 Создание пакета с помощью UDP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.3 Создание пакета с помощью TCP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.4 Упаковка пакета в IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.2.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2.5 Передача пакета"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc5.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.3 Функции Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp6",target:"_blank",rel:"noopener noreferrer"}},[e._v("6 Получение сообщений"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2 Пошаговое руководство по приему"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.1 Чтение из сокета (часть I)"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.2 Получение пакета"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.3 Запуск сети «нижняя половина»"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.4 Развертка пакета в IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.5 Прием пакета в UDP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.6",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.6 Прием пакета в TCP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.2.7",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.2.7 Чтение из сокета (Часть II)"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc6.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.3 Функции Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp7",target:"_blank",rel:"noopener noreferrer"}},[e._v("7 Переадресация IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2 Пошаговое руководство по пересылке IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.1 Получение пакета"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v('7.2.2 Запуск сети "Нижняя половина"'),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.3 Проверка пакета в IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.4 Пересылка пакета в IP"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.2.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.2.5 Передача пакета"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc7.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.3 Функции Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp8",target:"_blank",rel:"noopener noreferrer"}},[e._v("8 Базовая маршрутизация по Интернет-протоколу"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2 Таблицы маршрутизации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.1 Таблица соседей"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.2 Информационная база пересылки"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.3 Кэш маршрутизации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.2.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.4 Обновление информации о маршрутизации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc8.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3 Функции Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp9",target:"_blank",rel:"noopener noreferrer"}},[e._v("9 Динамическая маршрутизация с помощью "),_("em",[e._v("routed")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2 Как работает "),_("em",[e._v("routed")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2 .1 Структуры данных"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2.2 Инициализация"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.2.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.2.3 Обычные операции"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc9.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.3  "),_("em",[e._v("Маршрутизируемые")]),e._v(" функции"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp10",target:"_blank",rel:"noopener noreferrer"}},[e._v("10 Редактирование исходного кода Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.1 Дерево исходного кода Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2 Использование тегов EMACS"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2.1 Ссылки с помощью тегов"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.2.2 Создание файлов TAGS"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.3 Использование тегов vi"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.4 Пересборка ядра"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc10.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("10.5 Исправление исходного кода ядра"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp11",target:"_blank",rel:"noopener noreferrer"}},[e._v("11 Модули Linux"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2 Запись, установка и удаление модулей"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2.1 Запись модулей"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.2.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.2.2 Установка и удаление модулей"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc11.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("11.3 Пример"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp12",target:"_blank",rel:"noopener noreferrer"}},[e._v("12 Файловая система "),_("em",[e._v("proc")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.2 Сетевые файлы "),_("em",[e._v("proc")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3 Регистрация "),_("em",[e._v("proc")]),e._v(" Файлы"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.1 Форматирование функции для предоставления информации"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("12.3.2 Создание записи процедуры "),_("em",[e._v("12.3.3")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("Регистрация записи процедуры "),_("em",[e._v("12.3.4")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.3.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Отмена регистрации записи процедуры "),_("em",[e._v("12.4")]),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc12.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Пример"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp13",target:"_blank",rel:"noopener noreferrer"}},[e._v("13 Пример — отбрасыватель пакетов"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.1 Обзор"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.2 Соображения"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.3 Экспериментальные системы и тесты"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4 Результаты и предварительный анализ"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4.1 Стандартное ядро"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("​​13.4.2 Модифицированное ядро, отбрасывающее пакеты"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.4.3",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.4.3 Предварительный анализ"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5 Код"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5.1 Ядро"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc13.5.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.5.2 Модуль"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp14",target:"_blank",rel:"noopener noreferrer"}},[e._v("14 Дополнительные ресурсы"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("14.1 Интернет-сайты"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_sEc14.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("14.2 Книги"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp15",target:"_blank",rel:"noopener noreferrer"}},[e._v("15 Акронимы"),_("OutboundLink")],1)]),e._v(" "),_("h1",{attrs:{id:"глава-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-1"}},[e._v("#")]),e._v(" Глава 1")]),e._v(" "),_("p",[e._v("Введение")]),e._v(" "),_("p",[e._v("Это версия 1.0 этого документа от 31 мая 2000 г. со ссылкой на ядро ​​Linux версии 2.2.14.")]),e._v(" "),_("h2",{attrs:{id:"_1-1-предыстория"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-предыстория"}},[e._v("#")]),e._v(" 1.1   Предыстория")]),e._v(" "),_("p",[e._v("Linux становится все более популярным в качестве альтернативной операционной системы. Поскольку он доступен всем в рамках движения за открытый исходный код, буквально тысячи программистов постоянно работают над кодом, чтобы реализовать новые функции, улучшить существующие и исправить ошибки и неэффективность в коде. Есть много источников для получения дополнительной информации о Linux, от самого исходного кода (скачиваемого из Интернета) до книг, ``HOW-TO'' и досок объявлений, поддерживаемых на самые разные темы.")]),e._v(" "),_("p",[e._v("Этот документ представляет собой попытку объединить многие из этих источников в один последовательный справочник и руководство по изменению сетевого кода в ядре Linux. В нем представлена ​​внутренняя работа на четырех уровнях: общий обзор, более конкретные исследования сетевой активности, подробное описание функций и ссылки на фактический код и структуры данных. Он разработан, чтобы предоставить столько деталей, сколько пожелает читатель. Это руководство было написано специально для ядра Linux 2.2.14 (которое уже было заменено ядром 2.2.15), и многие примеры взяты из дистрибутива Red Hat 6.1; надеюсь, предоставленная информация является достаточно общей, чтобы она по-прежнему применялась в дистрибутивах и новых ядрах. Он также фокусируется почти исключительно на TCP/UDP, IP,")]),e._v(" "),_("p",[e._v("В качестве справочника для программистов ядра этот документ содержит информацию и указатели по редактированию и перекомпиляции ядра, написанию и установке модулей и работе с файловой системой "),_("em",[e._v("/proc")]),e._v(" . Также представлен пример программы, которая отбрасывает пакеты для выбранного хоста, а также анализ результатов. Между описаниями и примерами это должно ответить на большинство вопросов о том, как Linux выполняет сетевые операции и как вы можете изменить его в соответствии со своими целями.")]),e._v(" "),_("p",[e._v("Этот проект начался в сетевой лаборатории факультета компьютерных наук Университета Нью-Гемпшира как попытка внесения изменений в ядро ​​Linux для экспериментов с различными алгоритмами маршрутизации. Вскоре стало очевидно, что взламывать ядро ​​вслепую — плохая идея, поэтому этот документ родился как исследовательский отчет и справочник для будущих программистов. Наконец, он стал достаточно большим (и, надеюсь, достаточно полезным), поэтому мы решили обобщить его, формализовать и выпустить для всеобщего обозрения.")]),e._v(" "),_("p",[e._v("И последнее замечание: Linux — это постоянно меняющаяся система, и настоящее освоение ее, если такое вообще возможно, займет гораздо больше времени, чем было потрачено на составление этого справочника. Если вы заметили какие-либо искажения, упущения, явные ошибки или даже опечатки (!) в этом документе, пожалуйста, свяжитесь с человеком, который в настоящее время ведет его. Целью этого проекта было создание бесплатного и полезного справочника для Linux-программистов.")]),e._v(" "),_("h2",{attrs:{id:"_1-2-условные-обозначения-документов"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-условные-обозначения-документов"}},[e._v("#")]),e._v(" 1.2   Условные обозначения документов")]),e._v(" "),_("p",[e._v("Предполагается, что читатель понимает язык программирования C и знаком с распространенными сетевыми протоколами. Это не обязательно для более общей информации, но подробности в этом документе предназначены для опытных программистов и могут быть непонятны рядовым пользователям Linux.")]),e._v(" "),_("p",[e._v("Почти весь представленный код требует доступа суперпользователя для реализации. Некоторые из примеров могут создавать дыры в безопасности там, где их раньше не было; программисты должны быть осторожны, чтобы восстановить свои системы до нормального состояния после экспериментов с ядром.")]),e._v(" "),_("p",[e._v("Ссылки на файлы и имена программ пишутся "),_("em",[e._v("наклонным")]),e._v(" шрифтом.")]),e._v(" "),_("p",[e._v("Код, записи командной строки и имена машин написаны шрифтом пишущей машинки .")]),e._v(" "),_("p",[e._v("Общие записи или переменные (например, имя выходного файла) и комментарии выделены "),_("em",[e._v("курсивом")]),e._v(" .")]),e._v(" "),_("h2",{attrs:{id:"_1-3-пример-примера-сети"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-пример-примера-сети"}},[e._v("#")]),e._v(" 1.3   Пример примера сети")]),e._v(" "),_("p",[e._v("В этом документе есть многочисленные примеры, которые помогают пояснить представленный материал. Ради последовательности и знакомства большинство из них ссылаются на пример сети, показанный на рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#i_example",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1"),_("OutboundLink")],1),e._v(" .")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/i_example.gif",alt:"i_example.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 1.1: Пример структуры сети.")]),e._v(" "),_("p",[e._v("Эта сеть представляет собой компьютерную систему в вымышленном безымянном университете (U!). Он имеет маршрутизатор, подключенный к Интернету в целом ( крайслер ). Эта машина подключена (через интерфейс джипа ) к общеуниверситетской сети u.edu , состоящей из компьютеров, названных в честь автомобильных компаний, принадлежащих Chrysler ( dodge , eagle и т. д.). Существует также подсеть LAN для отдела компьютерных наук, cs.u.edu , хосты которой названы в честь моделей автомобилей Dodge ( stealth , neon и т. д.). Они подключены к сети кампуса с помощью компьютера dodge/viper . И u.edu , и cs.u.eduсети используют оборудование и протоколы Ethernet.")]),e._v(" "),_("p",[e._v("Это явно не настоящая сеть. Все IP-адреса берутся из блока, зарезервированного для частных сетей класса B (уникальность которых не гарантируется). В большинстве реальных сетей класса B было бы гораздо больше компьютеров, а в сети всего с восемью компьютерами, вероятно, не было бы подсети. Подключение к Интернету (через Chrysler ) обычно осуществляется через линию T1 или T3, и этот маршрутизатор, вероятно, будет «настоящим» маршрутизатором (то есть аппаратным маршрутизатором Cisco Systems), а не компьютером с двумя сетевыми картами. Однако этот пример достаточно реалистичен, чтобы служить своей цели: проиллюстрировать реализацию сети Linux и взаимодействие между хостами, подсетями и сетями.")]),e._v(" "),_("h2",{attrs:{id:"_1-4-авторское-право-лицензия-и-отказ-от-ответственности"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-авторское-право-лицензия-и-отказ-от-ответственности"}},[e._v("#")]),e._v(" 1.4   Авторское право, лицензия и отказ от ответственности")]),e._v(" "),_("p",[e._v("Авторское право (c) 2000 г. принадлежит Гленну Херрину. Этот документ может быть свободно воспроизведен полностью или частично при условии указания автора с помощью строки, подобной следующей:")]),e._v(" "),_("blockquote",[_("p",[e._v("Скопировано из Linux IP Networking, доступного по адресу "),_("em",[_("a",{attrs:{href:"http://www.cs.unh.edu/cnrg/gherrin",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.cs.unh.edu/cnrg/gherrin"),_("OutboundLink")],1)]),e._v(" .")])]),e._v(" "),_("p",[e._v("(Видимость авторства должна быть пропорциональна объему воспроизведенного документа!) Коммерческое распространение разрешено и поощряется. Все модификации этого документа, включая переводы, антологии и частичные документы, должны соответствовать следующим требованиям:")]),e._v(" "),_("ol",[_("li",[e._v("Модифицированные версии должны быть помечены соответствующим образом.")]),e._v(" "),_("li",[e._v("Лицо, внесшее изменения, должно быть идентифицировано.")]),e._v(" "),_("li",[e._v("Признание первоначального автора должно быть сохранено.")]),e._v(" "),_("li",[e._v("Местоположение исходного неизмененного документа должно быть указано.")]),e._v(" "),_("li",[e._v("Имя оригинального автора не может использоваться для утверждения или подразумевающего одобрения конечного документа без разрешения первоначального автора.")])]),e._v(" "),_("p",[e._v("Пожалуйста, обратите внимание на любые изменения, включая удаления.")]),e._v(" "),_("p",[e._v("Это вариант (изменения являются преднамеренными) лицензии Linux Documentaion Project (LDP), доступной по адресу:")]),e._v(" "),_("blockquote",[_("p",[_("em",[_("a",{attrs:{href:"http://www.linuxdoc.org/COPYRIGHT.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.linuxdoc.org/COPYRIGHT.html"),_("OutboundLink")],1)])])]),e._v(" "),_("p",[e._v("Этот документ в настоящее время не является частью LDP, но может быть представлен в будущем.")]),e._v(" "),_("p",[e._v("Этот документ распространяется в надежде, что он будет полезен, но (конечно) без какой-либо явной или подразумеваемой гарантии пригодности для какой-либо цели. Используйте его на свой страх и риск.")]),e._v(" "),_("h2",{attrs:{id:"_1-5-благодарности"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-благодарности"}},[e._v("#")]),e._v(" 1.5   Благодарности")]),e._v(" "),_("p",[e._v("Я написал этот документ в рамках своего магистерского проекта для факультета компьютерных наук Университета Нью-Гемпшира. Я хотел бы поблагодарить профессора Пилар де ла Торре за организацию проекта и профессора Радима Бартоса за то, что он был и спонсором, и моим советником, дав мне многочисленные указания, большую поддержку и набор компьютеров для экспериментов. Я также хотел бы отдать должное армии Соединенных Штатов, которая была моим домом в течение 11 лет и оплачивала мое посещение UNH.")]),e._v(" "),_("p",[e._v("Гленн Херрин Мейджор, первичный документатор и исследователь"),_("br"),e._v("\nармии США , версия 1.0 gherrin@cs.unh.edu")]),e._v(" "),_("h1",{attrs:{id:"глава-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-2"}},[e._v("#")]),e._v(" Глава 2.")]),e._v(" "),_("p",[e._v("Обзор трафика сообщений")]),e._v(" "),_("p",[e._v("В этой главе представлен обзор всей системы обмена сообщениями Linux. В нем обсуждаются конфигурации, вводятся задействованные структуры данных и описываются основы IP-маршрутизации.")]),e._v(" "),_("h2",{attrs:{id:"_2-1-путь-сетевого-трафика"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-путь-сетевого-трафика"}},[e._v("#")]),e._v(" 2.1   Путь сетевого трафика")]),e._v(" "),_("p",[e._v("Интернет-протокол (IP) является сердцем системы обмена сообщениями Linux. В то время как Linux (более или менее) строго придерживается концепции многоуровневости — и можно использовать другой протокол (например, ATM), — IP почти всегда является связующим звеном, через которое проходят пакеты. IP-реализация сетевого уровня выполняет маршрутизацию и пересылку, а также инкапсуляцию данных. На рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_path",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1"),_("OutboundLink")],1),e._v(" показана упрощенная схема того, как сетевые пакеты проходят через ядро ​​Linux.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/o_path.gif",alt:"o_path.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 2.1: Абстракция пути трафика сообщений Linux.")]),e._v(" "),_("p",[e._v("Когда приложение генерирует трафик, оно отправляет пакеты через сокеты на транспортный уровень (TCP или UDP), а затем на сетевой уровень (IP). На уровне IP ядро ​​ищет маршрут к хосту либо в кэше маршрутизации, либо в своей информационной базе пересылки (FIB). Если пакет предназначен для другого компьютера, ядро ​​обращается к нему, а затем отправляет его на выходной интерфейс канального уровня (обычно устройство Ethernet), которое в конечном итоге отправляет пакет через физическую среду.")]),e._v(" "),_("p",[e._v("Когда пакет поступает по среде, входной интерфейс получает его и проверяет, действительно ли пакет предназначен для хост-компьютера. Если это так, он отправляет пакет на уровень IP, который ищет маршрут к месту назначения пакета. Если пакет необходимо переслать на другой компьютер, уровень IP отправляет его обратно на выходной интерфейс. Если пакет предназначен для приложения, он отправляет его через транспортный уровень и сокеты для чтения приложением, когда он будет готов.")]),e._v(" "),_("p",[e._v("Попутно каждый сокет и протокол выполняет различные проверки и функции форматирования, подробно описанные в последующих главах. Весь процесс реализован с помощью ссылок и таблиц переходов, которые изолируют каждый протокол, большинство из которых настраиваются во время инициализации при загрузке компьютера. Подробную информацию о процессе инициализации см. в Главе  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#initialization",target:"_blank",rel:"noopener noreferrer"}},[e._v("3 ."),_("OutboundLink")],1)]),e._v(" "),_("h2",{attrs:{id:"_2-2-стек-протоколов"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-стек-протоколов"}},[e._v("#")]),e._v(" 2.2   Стек протоколов")]),e._v(" "),_("p",[e._v("Сетевые устройства образуют нижний уровень стека протоколов; они используют протокол канального уровня (обычно Ethernet) для связи с другими устройствами для отправки и получения трафика. Входные интерфейсы копируют пакеты с носителя, выполняют некоторые проверки на наличие ошибок, а затем пересылают их на сетевой уровень. Выходные интерфейсы получают пакеты с сетевого уровня, выполняют некоторые проверки на наличие ошибок, а затем отправляют их по среде.")]),e._v(" "),_("p",[e._v("IP — это стандартный протокол сетевого уровня. Он проверяет входящие пакеты, чтобы определить, предназначены ли они для хост-компьютера или их необходимо переслать. Он при необходимости дефрагментирует пакеты и доставляет их транспортным протоколам. Он поддерживает базу данных маршрутов для исходящих пакетов; он обращается к ним и при необходимости фрагментирует их перед отправкой на канальный уровень.")]),e._v(" "),_("p",[e._v("TCP и UDP являются наиболее распространенными протоколами транспортного уровня. UDP просто обеспечивает структуру для адресации пакетов к портам внутри компьютера, в то время как TCP позволяет выполнять более сложные операции на основе соединений, включая механизмы восстановления после потери пакетов и реализации управления трафиком. Любой из них копирует полезную нагрузку пакета между пользователем и пространством ядра. Однако и то, и другое является лишь частью промежуточного уровня между приложениями и сетью.")]),e._v(" "),_("p",[e._v("Специфичные для IP сокеты INET — это элементы данных и реализации универсальных сокетов. У них есть связанные очереди и код, выполняющий операции сокета, такие как чтение, запись и установление соединений. Они действуют как посредник между общим сокетом приложения и протоколом транспортного уровня.")]),e._v(" "),_("p",[e._v("Универсальные сокеты BSD — это более абстрактные структуры, содержащие сокеты INET. Приложения читают и записывают в сокеты BSD; сокеты BSD переводят операции в операции сокетов INET. См. главу  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#connect",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),_("OutboundLink")],1),e._v(" для получения дополнительной информации о сокетах.")]),e._v(" "),_("p",[e._v("Приложения, работающие в пользовательском пространстве, образуют верхний уровень стека протоколов; они могут быть такими же простыми, как двустороннее чат-соединение, или такими сложными, как протокол информации о маршрутизации (RIP — см. главу  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),_("OutboundLink")],1),e._v(" ).")]),e._v(" "),_("h2",{attrs:{id:"_2-3-структура-пакета"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-структура-пакета"}},[e._v("#")]),e._v(" 2.3   Структура пакета")]),e._v(" "),_("p",[e._v("Ключом к поддержанию строгой многоуровневости протоколов без потери времени на копирование параметров и полезной нагрузки туда и обратно является общая структура данных пакета (буфер сокета или sk_buff — рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#o_skbuff",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2"),_("OutboundLink")],1),e._v(" ). Во всех вызовах различных функций, когда данные проходят через протоколы, данные полезной нагрузки копируются только дважды; один раз от пользователя в пространство ядра и один раз из пространства ядра в выходной носитель (для исходящего пакета).")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/o_skbuff.gif",alt:"o_skbuff.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 2.2: Структура пакета ( sk_buff ).")]),e._v(" "),_("p",[e._v("Эта структура содержит указатели на всю информацию о пакете — его сокет, устройство, маршрут, расположение данных и т. д. Транспортные протоколы создают эти структуры пакетов из выходных буферов, а драйверы устройств создают их для входящих данных. Затем каждый уровень заполняет информацию, которая ему нужна, при обработке пакета. Все протоколы — транспортный (TCP/UDP), интернет (IP) и канальный уровень (Ethernet) — используют один и тот же буфер сокетов.")]),e._v(" "),_("h2",{attrs:{id:"_2-4-интернет-маршрутизация"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-интернет-маршрутизация"}},[e._v("#")]),e._v(" 2.4   Интернет-маршрутизация")]),e._v(" "),_("p",[e._v("Уровень IP обеспечивает маршрутизацию между компьютерами. Он хранит две структуры данных; База информации о переадресации (FIB), которая отслеживает все детали для каждого известного маршрута, и более быстрый кэш маршрутизации для пунктов назначения, которые в настоящее время используются. (Существует также третья структура — таблица соседей — которая отслеживает компьютеры, физически подключенные к хосту.)")]),e._v(" "),_("p",[e._v("FIB является основной ссылкой маршрутизации; он содержит до 32 зон (по одной на каждый бит IP-адреса) и записи для каждого известного места назначения. Каждая зона содержит записи для сетей или хостов, которые могут быть однозначно идентифицированы определенным количеством битов — сеть с сетевой маской 255.0.0.0 имеет 8 значащих битов и будет находиться в зоне 8, а сеть с сетевой маской 255.255.255.0 имеет 24 значащих бита и находится в зоне 24. Когда IP нужен маршрут, он начинает с наиболее конкретных зон и просматривает всю таблицу, пока не найдет совпадение (всегда должна быть хотя бы одна запись по умолчанию). Файл "),_("em",[e._v("/proc/net/route")]),e._v(" содержит содержимое FIB.")]),e._v(" "),_("p",[e._v("Кэш маршрутизации представляет собой хеш-таблицу, которую IP использует для фактической маршрутизации пакетов. Он содержит до 256 цепочек текущих записей маршрутизации, положение каждой записи определяется хэш-функцией. Когда хосту необходимо отправить пакет, IP ищет запись в кэше маршрутизации. Если такового нет, он находит соответствующий маршрут в FIB и вставляет новую запись в кэш. (Эта запись используется для маршрутизации различными протоколами, а не запись FIB.) Записи остаются в кэше до тех пор, пока они используются; если для пункта назначения нет трафика, время ожидания записи истекает, и IP удаляет ее. Файл "),_("em",[e._v("/proc/net/rt_cache")]),e._v(" содержит содержимое кеша маршрутизации.")]),e._v(" "),_("p",[e._v("Эти таблицы выполняют всю маршрутизацию в обычной системе. Даже другие протоколы (например, RIP) используют те же структуры; они просто изменяют существующие таблицы в ядре, используя функцию ioctl() . Подробную информацию о маршрутизации см. в главе  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#routing",target:"_blank",rel:"noopener noreferrer"}},[e._v("8 ."),_("OutboundLink")],1)]),e._v(" "),_("h1",{attrs:{id:"глава-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-3"}},[e._v("#")]),e._v(" Глава 3")]),e._v(" "),_("p",[e._v("Инициализация сети")]),e._v(" "),_("p",[e._v("В этой главе представлена ​​инициализация сети при запуске. В нем представлен обзор того, что происходит при загрузке операционной системы Linux, показано, как ядро ​​и вспомогательные программы "),_("em",[e._v("ifconfig")]),e._v(" и "),_("em",[e._v("route")]),e._v(" устанавливают сетевые связи, показаны различия между несколькими примерами конфигураций, а также обобщен код реализации в ядре и сетевых программах.")]),e._v(" "),_("h2",{attrs:{id:"_3-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-обзор"}},[e._v("#")]),e._v(" 3.1   Обзор")]),e._v(" "),_("p",[e._v("Linux инициализирует таблицы маршрутизации при запуске, только если компьютер настроен для работы в сети. (Почти все Linux-машины реализуют работу в сети, даже автономные машины, хотя бы для того, чтобы использовать петлевое устройство.) Когда ядро ​​заканчивает загрузку, оно запускает набор общих, но специфичных для системы служебных программ и считывает файлы конфигурации, некоторые из которых установить сетевые возможности компьютера. Они определяют его собственный адрес, инициализируют его интерфейсы (например, карты Ethernet) и добавляют важные и известные статические маршруты (например, один к маршрутизатору, который соединяет его с остальной частью Интернета). Если компьютер сам является маршрутизатором, он также может выполнять программу, которая позволяет ему динамически обновлять свои таблицы маршрутизации (но это НЕ выполняется на большинстве хостов).")]),e._v(" "),_("p",[e._v("Весь процесс настройки может быть статическим или динамическим. Если адреса и имена никогда (или редко) не меняются, системный администратор должен определить параметры и переменные в файлах при настройке системы. В более изменчивой среде хост будет использовать протокол, такой как протокол динамической конфигурации оборудования (DHCP), чтобы запрашивать информацию об адресе, маршрутизаторе и DNS-сервере, с помощью которой можно настроить себя при загрузке. (На самом деле, в любом случае администратор почти всегда будет использовать интерфейс с графическим интерфейсом, например панель управления Red Hat, которая автоматически записывает файлы конфигурации, показанные ниже.)")]),e._v(" "),_("p",[e._v("Важно отметить, что хотя большинство компьютеров под управлением Linux запускаются одинаково, программы и их расположение никоим образом не стандартизированы; они могут сильно различаться в зависимости от распространения, соображений безопасности или прихотей системного администратора. В этой главе представлено как можно более общее описание, но предполагается дистрибутив Red Hat Linux 6.1 и обычно статическая сетевая среда.")]),e._v(" "),_("h2",{attrs:{id:"_3-2-запуск"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-запуск"}},[e._v("#")]),e._v(" 3.2   Запуск")]),e._v(" "),_("p",[e._v("Когда Linux загружается как операционная система, она загружает свой образ с диска в память, распаковывает его и устанавливает себя, устанавливая файловые системы, управление памятью и другие ключевые системы. В качестве последней задачи ядра (инициализации) выполняется программа "),_("em",[e._v("инициализации")]),e._v(" . Эта программа считывает файл конфигурации ( "),_("em",[e._v("/etc/inittab")]),e._v(" ), который указывает ей выполнить сценарий запуска (находящийся в "),_("em",[e._v("/etc/rc.d")]),e._v(" в дистрибутивах Red Hat). Это, в свою очередь, запускает дополнительные сценарии, включая сетевой сценарий ( "),_("em",[e._v("/etc/rc.d/init.d/network")]),e._v(" ). (См. Раздел "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_i_examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.3"),_("OutboundLink")],1),e._v(" для примеров взаимодействия сценария и файла.)")]),e._v(" "),_("h3",{attrs:{id:"_3-2-1-сценарии-инициализации-сети"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-сценарии-инициализации-сети"}},[e._v("#")]),e._v(" 3.2.1   Сценарий инициализации сети")]),e._v(" "),_("p",[e._v("Сценарий сетевой инициализации задает переменные среды для идентификации хост-компьютера и определения того, будет ли компьютер использовать сеть. В зависимости от заданных значений сетевой сценарий включает (или выключает) переадресацию IP-адресов и фрагментацию IP-адресов. Он также устанавливает маршрутизатор по умолчанию для всего сетевого трафика и устройство, используемое для отправки такого трафика. Наконец, он вызывает любые сетевые устройства с помощью программ "),_("em",[e._v("ifconfig")]),e._v(" и "),_("em",[e._v("route")]),e._v(" . (В динамической среде он будет запрашивать у DHCP-сервера свою сетевую информацию вместо того, чтобы читать свои собственные файлы.)")]),e._v(" "),_("p",[e._v("Сценарий (сценарии), задействованный в создании сети, может быть очень простым; вполне возможно иметь один большой сценарий, который просто выполняет ряд команд, которые должным образом настроят одну машину. Тем не менее, большинство дистрибутивов Linux поставляются с большим количеством универсальных сценариев, которые работают для самых разных настроек компьютеров. Это оставляет много косвенного и условного выполнения в сценариях, но на самом деле значительно упрощает настройку любой машины. Например, в дистрибутивах Red Hat сценарий "),_("em",[e._v("/etc/rc.d/init.d/network")]),e._v(" запускает несколько других сценариев и устанавливает переменные, такие как interfaces_boot , чтобы отслеживать, какой файл _/etc/sysconfig/network-scripts/ifup_скрипты для запуска. Отследить процесс вручную очень сложно, но простая модификация всего двух конфигурационных файлов (с указанием правильных имен и IP-адресов в файлах "),_("em",[e._v("/etc/sysconfig/network")]),e._v(" и "),_("em",[e._v("/etc/sysconfig/network-scripts/ifcfg-eth0")]),e._v(" ) настраивает вся система правильно (и графический интерфейс делает процесс еще проще).")]),e._v(" "),_("p",[e._v("Когда сетевой сценарий завершается, FIB содержит указанные маршруты к заданным хостам или сетям, а кэш маршрутизации и таблицы соседей пусты. Когда трафик начинает течь, ядро ​​​​обновляет таблицу соседей и кэш маршрутизации в рамках обычных сетевых операций. (Сетевой трафик может начаться во время инициализации, если хост настроен динамически или, например, обращается к сетевым часам.)")]),e._v(" "),_("h3",{attrs:{id:"_3-2-2-ифконфиг"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-ифконфиг"}},[e._v("#")]),e._v(" 3.2.2   "),_("em",[e._v("Ифконфиг")])]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("ifconfig")]),e._v(" настраивает интерфейсные устройства для использования. (Эта программа, хотя и очень широко используется, не является частью ядра.) Она предоставляет каждому устройству его (IP) адрес, сетевую маску и широковещательный адрес. Устройство, в свою очередь, будет запускать свои собственные функции инициализации (для установки любых статических переменных) и регистрировать свои прерывания и процедуры обслуживания в ядре. Команды "),_("em",[e._v("ifconfig")]),e._v(" в сетевом скрипте выглядят так:")]),e._v(" "),_("blockquote",[_("p",[e._v("ifconfig ${DEVICE} ${IPADDR} сетевая маска ${NMASK} широковещательная рассылка ${BCAST}")])]),e._v(" "),_("p",[e._v("(где переменные либо пишутся непосредственно в скрипте, либо определяются в других скриптах).")]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("ifconfig")]),e._v(" также может предоставить информацию о сконфигурированных в данный момент сетевых устройствах (вызов без аргументов отображает все активные интерфейсы; вызов с параметром -a отображает все интерфейсы, активные или нет):")]),e._v(" "),_("blockquote",[_("p",[e._v("ifconfig")])]),e._v(" "),_("p",[e._v("Это предоставляет всю доступную информацию о каждом рабочем интерфейсе; адреса, статус, статистика пакетов и особенности операционной системы. Обычно будет как минимум два интерфейса - сетевая карта и петлевое устройство. Информация по каждому интерфейсу выглядит так (это интерфейс вайпера ):")]),e._v(" "),_("blockquote",[_("p",[e._v("Инкапсуляция канала eth0: Ethernet HWaddr 00:C1:4E:7D:9E:25\nинет-адрес: 172.16.1.1 Bcast: 172.16.1.255 Маска: 255.255.255.0\nВВЕРХ ТРАНСЛЯЦИЯ РАБОТАЕТ MULTICAST MTU:1500 Метрика:1\nПакеты RX: 389016 ошибки: 16534 отброшены: 0 переполнение: 0 кадр: 24522\nПакеты TX: 400845 ошибки: 0 отброшены: 0 переполнены: 0 перевозчик: 0\nколлизии: 0 txqueuelen: 100\nПрерывание: 11 Базовый адрес: 0xcc00")])]),e._v(" "),_("p",[e._v("Суперпользователь может использовать "),_("em",[e._v("ifconfig")]),e._v(" для изменения настроек интерфейса из командной строки; вот синтаксис:")]),e._v(" "),_("blockquote",[_("p",[_("em",[e._v("параметры интерфейса")]),e._v(" ifconfig [aftype] "),_("em",[e._v("|")]),e._v(" "),_("em",[e._v("адрес ...")])])]),e._v(" "),_("p",[e._v("... и некоторые из наиболее полезных вызовов:")]),e._v(" "),_("blockquote",[_("p",[e._v("ifconfig eth0 down — выключение eth0"),_("br"),e._v("\nifconfig eth1 up — активация eth1"),_("br"),e._v("\nifconfig eth0 arp — включение ARP на eth0"),_("br"),e._v("\nifconfig eth0 -arp — отключение ARP на eth0"),_("br"),e._v("\nifconfig eth0 netmask 255.255.255.0 — установка сетевой маски eth0"),_("br"),e._v("\nifconfig lo mtu 2000 — установка максимального значения обратной связи блок передачи"),_("br"),e._v("\nifconfig eth1 172.16.0.7 — установить IP-адрес eth1")])]),e._v(" "),_("p",[e._v("Обратите внимание, что изменение конфигурации интерфейса может косвенно изменить таблицы маршрутизации. Например, изменение сетевой маски может сделать некоторые маршруты спорными (включая маршрут по умолчанию или даже маршрут к самому хосту), и ядро ​​удалит их.")]),e._v(" "),_("h3",{attrs:{id:"_3-2-3-маршрут"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-маршрут"}},[e._v("#")]),e._v(" 3.2.3   "),_("em",[e._v("маршрут")])]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("маршрутизации")]),e._v(" просто добавляет предопределенные маршруты для интерфейсных устройств в информационную базу пересылки (FIB). Это также не часть ядра; это пользовательская программа, команда которой в сценарии выглядит так:")]),e._v(" "),_("blockquote",[_("p",[e._v("route add -net ${NETWORK} netmask ${NMASK} dev ${DEVICE} -or-"),_("br"),e._v("\nroute add -host ${IPADDR} ${DEVICE}")])]),e._v(" "),_("p",[e._v("(где переменные снова прописаны или определены в других сценариях).")]),e._v(" "),_("p",[e._v("Программа маршрутизации также может удалять маршруты (если запущена с опцией del ) или предоставлять информацию о маршрутах "),_("em",[e._v(",")]),e._v(" которые в настоящее время определены (если запущена без опций):")]),e._v(" "),_("blockquote",[_("p",[e._v("маршрут")])]),e._v(" "),_("p",[e._v("Это отображает таблицу IP-маршрутизации ядра (FIB, а не кэш маршрутизации). Например ( невидимый компьютер):")]),e._v(" "),_("blockquote",[_("p",[e._v("Таблица IP-маршрутизации ядра\nШлюз назначения Флаги Генмаски Метрика Ссылка Использование Iface\n172.16.1.4 * 255.255.255.255 UH 0 0 0 eth0\n172.16.1.0 * 255.255.255.0 U 0 0 0 eth0\n127.0.0.0 * 255.0.0.0 U 0 0 0 ниже\nпо умолчанию viper.u.edu 0.0.0.0 UG 0 0 0 eth0")])]),e._v(" "),_("p",[e._v("Суперпользователь может использовать "),_("em",[e._v("route")]),e._v(" для добавления и удаления IP-маршрутов из командной строки; вот основной синтаксис:")]),e._v(" "),_("blockquote",[_("p",[e._v("добавить маршрут "),_("em",[e._v("[-net | -host] target [параметр arg]")]),_("br"),e._v("\nroute del "),_("em",[e._v("[-net | -host] цель [опция arg]")])])]),e._v(" "),_("p",[e._v("... и несколько полезных примеров:")]),e._v(" "),_("blockquote",[_("p",[e._v("route add -host 127.16.1.0 eth1 - добавляет маршрут к хосту"),_("br"),e._v("\nroute add -net 172.16.1.0 netmask 255.255.255.0 eth0 - добавляет сетевой"),_("br"),e._v("\nмаршрут add default gw jeep - устанавливает маршрут по умолчанию через jeep"),_("br"),e._v("\n(Обратите внимание, что маршрут к jeep должен быть уже настроен)"),_("br"),e._v("\nroute del -host 172.16.1.16 - удаляет запись для хоста 172.16.1.16")])]),e._v(" "),_("h3",{attrs:{id:"_3-2-4-программы-динамическои-маршрутизации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-программы-динамическои-маршрутизации"}},[e._v("#")]),e._v(" 3.2.4   Программы динамической маршрутизации")]),e._v(" "),_("p",[e._v("Если компьютер является маршрутизатором, сетевой сценарий запустит программу маршрутизации, такую ​​как "),_("em",[e._v("routed")]),e._v(" или "),_("em",[e._v("gated")]),e._v(" . Поскольку большинство компьютеров всегда находятся в одной проводной сети с одним и тем же набором адресов и ограниченными возможностями маршрутизации, на большинстве компьютеров не выполняется ни одна из этих программ. (Если кабель Ethernet обрезан, трафик просто не пойдет; нет необходимости пытаться перенаправлять или настраивать таблицы маршрутизации.) См. главу  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),_("OutboundLink")],1),e._v(" для получения дополнительной информации о "),_("em",[e._v("routed")]),e._v(" .")]),e._v(" "),_("h2",{attrs:{id:"_3-3-примеры"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-примеры"}},[e._v("#")]),e._v(" 3.3   Примеры")]),e._v(" "),_("p",[e._v("Ниже приведены примеры файлов для систем, настроенных тремя различными способами, и пояснения того, как они работают. Обычно каждый компьютер выполняет сетевой сценарий, который считывает файлы конфигурации, даже если файлы предписывают компьютеру не реализовывать какую-либо сеть.")]),e._v(" "),_("h3",{attrs:{id:"_3-3-1-домашнии-компьютер"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-домашнии-компьютер"}},[e._v("#")]),e._v(" 3.3.1   Домашний компьютер")]),e._v(" "),_("p",[e._v("Эти файлы будут на компьютере, который не подключен к сети постоянно, но имеет модем для доступа по протоколу ppp . (Этот раздел не относится к компьютеру из общего примера.)")]),e._v(" "),_("p",[e._v("Это первый файл, который будет читать сетевой скрипт; он устанавливает несколько переменных среды. Первые две переменные заставляют компьютер запускать сетевые программы (даже если он не в сети), но не пересылать пакеты (поскольку ему некуда их отправлять). Последние две переменные являются общими элементами.")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сеть")])]),e._v(" "),_("blockquote",[_("p",[e._v("NETWORKING=yes"),_("br"),e._v("\nFORWARD_IPV4=false"),_("br"),e._v("\nHOSTNAME=localhost.localdomain"),_("br"),e._v("\nGATEWAY=")])]),e._v(" "),_("p",[e._v("После установки этих переменных сетевой сценарий решит, что ему необходимо настроить хотя бы одно сетевое устройство, чтобы оно стало частью сети. Следующий файл (который практически одинаков на всех компьютерах с Linux) устанавливает переменные окружения для loopback-устройства. Он дает ему имя и дает ему (стандартный) IP-адрес, сетевую маску и широковещательный адрес, а также любые другие переменные, относящиеся к устройству. (Переменная ONBOOT — это флаг для программы-скрипта, который сообщает ей настроить это устройство при загрузке.) Большинство компьютеров, даже те, которые никогда не будут подключаться к Интернету, устанавливают петлевое устройство для межпроцессного взаимодействия.")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сетевые скрипты/ifcfg-ло")])]),e._v(" "),_("blockquote",[_("p",[e._v("DEVICE=lo"),_("br"),e._v("\nIPADDR=127.0.0.1"),_("br"),e._v("\nNMASK=255.0.0.0"),_("br"),e._v("\nNETWORK=127.0.0.0"),_("br"),e._v("\nBCAST=127.255.255.255"),_("br"),e._v("\nONBOOT=yes"),_("br"),e._v("\nNAME=loopback"),_("br"),e._v("\nBOOTPROTO=none")])]),e._v(" "),_("p",[e._v("После установки этих переменных скрипт запустит программу "),_("em",[e._v("ifconfig")]),e._v(" и остановится, так как в данный момент больше делать нечего. Однако, когда программа ppp подключается к поставщику услуг Интернета, она устанавливает устройство ppp , а также адресацию и маршруты на основе динамических значений, назначенных поставщиком услуг Интернета. DNS-сервер и другая информация о соединении должны быть в файле "),_("em",[e._v("ifcfg-ppp")]),e._v(" .")]),e._v(" "),_("h3",{attrs:{id:"_3-3-2-хост-компьютер-в-локальнои-сети"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-хост-компьютер-в-локальнои-сети"}},[e._v("#")]),e._v(" 3.3.2   Хост-компьютер в локальной сети")]),e._v(" "),_("p",[e._v("Эти файлы будут на компьютере, подключенном к локальной сети; у него есть одна карта Ethernet, которая должна появляться при загрузке компьютера. Эти файлы отражают записи на стелс- компьютере из общего примера.")]),e._v(" "),_("p",[e._v("Это первый файл, который будет читать сетевой скрипт; снова первые переменные просто определяют, что компьютер будет работать в сети, но не будет пересылать пакеты. Последние четыре переменные идентифицируют компьютер и его связь с остальной частью Интернета (все, что не находится в локальной сети).")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сеть")])]),e._v(" "),_("blockquote",[_("p",[e._v("NETWORKING=yes"),_("br"),e._v("\nFORWARD_IPV4=false"),_("br"),e._v("\nHOSTNAME=stealth.cs.u.edu"),_("br"),e._v("\nDOMAINNAME=cs.u.edu"),_("br"),e._v("\nGATEWAY=172.16.1.1"),_("br"),e._v("\nGATEWAYDEV=eth0")])]),e._v(" "),_("p",[e._v("После установки этих переменных сетевой скрипт настроит сетевые устройства. Этот файл устанавливает переменные среды для карты Ethernet. Он называет устройство и дает ему его IP-адрес, сетевую маску и широковещательный адрес, а также любые другие переменные устройства. Этот тип компьютера также будет иметь файл конфигурации обратной связи, точно такой же, как и для компьютера, не подключенного к сети.")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сетевые скрипты/ifcfg-eth0")])]),e._v(" "),_("blockquote",[_("p",[e._v("DEVICE=eth0"),_("br"),e._v("\nIPADDR=172.16.1.4"),_("br"),e._v("\nNMASK=255.255.255.0"),_("br"),e._v("\nNETWORK=172.16.1.0"),_("br"),e._v("\nBCAST=172.16.1.255"),_("br"),e._v("\nONBOOT=да"),_("br"),e._v("\nBOOTPROTO=нет")])]),e._v(" "),_("p",[e._v("После установки этих переменных сетевой сценарий запустит "),_("em",[e._v("программу ifconfig")]),e._v(" для запуска устройства. Наконец, сценарий запустит программу "),_("em",[e._v("маршрутизации")]),e._v(" , чтобы добавить маршрут по умолчанию ( GATEWAY ) и любые другие указанные маршруты (которые можно найти в "),_("em",[e._v("файле /etc/sysconfig/static-routes")]),e._v(" , если таковые имеются). В этом случае указывается только маршрут по умолчанию, так как весь трафик либо остается в локальной сети (где компьютер будет использовать ARP для поиска других хостов), либо проходит через маршрутизатор, чтобы попасть во внешний мир.")]),e._v(" "),_("h3",{attrs:{id:"_3-3-3-компьютер-сетевои-маршрутизации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-компьютер-сетевои-маршрутизации"}},[e._v("#")]),e._v(" 3.3.3   Компьютер сетевой маршрутизации")]),e._v(" "),_("p",[e._v("Эти файлы будут на компьютере, который служит маршрутизатором между двумя сетями; у него есть две карты Ethernet, по одной для каждой сети. Одна карта находится в большой сети (WAN), подключенной к Интернету (через еще один маршрутизатор), а другая — в подсети (LAN). Компьютеры в локальной сети, которым необходимо обмениваться данными с остальной частью Интернета, отправляют трафик через этот компьютер (и наоборот). Эти файлы отражают записи на компьютере dodge/viper из общего примера.")]),e._v(" "),_("p",[e._v("Это первый файл, который будет читать сетевой скрипт; он устанавливает несколько переменных среды. Первые два просто определяют, что компьютер будет работать в сети (поскольку он находится в сети) и что этот компьютер будет пересылать пакеты (из одной сети в другую). "),_("em",[e._v("IP Forwarding встроен в большинство ядер, но он не активен, если в файле /proc/net/ipv4/ip_forward")]),e._v(" нет 1 ``записи'' . (Один из сетевых сценариев выполняет команду echo 1 > /proc/net/ipv4/ip_forward, если FORWARD_IPV4 имеет значение true.) Последние четыре переменные идентифицируют компьютер и его связь с остальной частью Интернета (все, что не находится в одной из его собственные сети).")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сеть")])]),e._v(" "),_("blockquote",[_("p",[e._v("NETWORKING=yes"),_("br"),e._v("\nFORWARD_IPV4=true"),_("br"),e._v("\nHOSTNAME=dodge.u.edu"),_("br"),e._v("\nDOMAINNAME=u.edu"),_("br"),e._v("\nGATEWAY=172.16.0.1"),_("br"),e._v("\nGATEWAYDEV=eth1")])]),e._v(" "),_("p",[e._v("После установки этих переменных сетевой скрипт настроит сетевые устройства. Эти файлы устанавливают переменные среды для двух карт Ethernet. Они называют устройства и дают им их IP-адреса, сетевые маски и широковещательные адреса. (Обратите внимание, что переменная BOOTPROTO остается определенной для второй карты.) Опять же, этот компьютер будет иметь стандартный файл конфигурации обратной связи.")]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сетевые скрипты/ifcfg-eth0")])]),e._v(" "),_("blockquote",[_("p",[e._v("DEVICE=eth0"),_("br"),e._v("\nIPADDR=172.16.1.1"),_("br"),e._v("\nNMASK=255.255.255.0"),_("br"),e._v("\nNETWORK=172.16.1.0"),_("br"),e._v("\nBCAST=172.16.1.255"),_("br"),e._v("\nONBOOT=да"),_("br"),e._v("\nBOOTPROTO=статический")])]),e._v(" "),_("p",[_("em",[e._v("/etc/sysconfig/сетевые скрипты/ifcfg-eth1")])]),e._v(" "),_("blockquote",[_("p",[e._v("DEVICE=eth1"),_("br"),e._v("\nIPADDR=172.16.0.7"),_("br"),e._v("\nNMASK=255.255.0.0"),_("br"),e._v("\nNETWORK=172.16.0.0"),_("br"),e._v("\nBCAST=172.16.255.255"),_("br"),e._v("\nONBOOT=да")])]),e._v(" "),_("p",[e._v("После установки этих переменных сетевой сценарий запустит программу "),_("em",[e._v("ifconfig")]),e._v(" для запуска каждого устройства. Наконец, сценарий запустит программу "),_("em",[e._v("маршрутизации")]),e._v(" , чтобы добавить маршрут по умолчанию ( GATEWAY ) и любые другие указанные маршруты (которые можно найти в "),_("em",[e._v("файле /etc/sysconfig/static-routes")]),e._v(" , если таковые имеются). В этом случае снова маршрут по умолчанию является единственным указанным маршрутом, поскольку весь трафик будет идти в сеть, указанную сетевыми масками, или через маршрутизатор по умолчанию для достижения остальной части Интернета.")]),e._v(" "),_("h2",{attrs:{id:"_3-4-функции-linux-и-сетевых-программ"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-функции-linux-и-сетевых-программ"}},[e._v("#")]),e._v(" 3.4   Функции Linux и сетевых программ")]),e._v(" "),_("p",[e._v("Ниже приведены алфавитные списки функций ядра Linux и сетевых программ, которые наиболее важны для инициализации, где они находятся в исходном коде и что они делают. Показанный каталог SOURCES представляет собой каталог, содержащий исходный код для данного сетевого файла "),_("em",[e._v(".")]),e._v(" Исполняемые файлы должны поставляться с любым дистрибутивом Linux, но исходный код, вероятно, не входит.")]),e._v(" "),_("p",[e._v("Эти исходные коды доступны в виде пакета, отдельного от исходного кода ядра (Red Hat Linux использует диспетчер пакетов "),_("em",[e._v("rpm")]),e._v(" ). Приведенный ниже код взят из пакета исходного кода "),_("em",[e._v("net-tools-1.53-1")]),e._v(" от 29 августа 1999 г. Пакеты доступны на веб-странице "),_("em",[e._v("www.redhat.com/apps/download .")]),e._v(" После загрузки "),_("em",[e._v("root")]),e._v(" может установить пакет с помощью следующих команд (начиная с каталога с пакетом):")]),e._v(" "),_("blockquote",[_("p",[e._v("rpm -i net-tools-1.53-1.src.rpm"),_("br"),e._v("\ncd /usr/src/redhat/ИСТОЧНИКИ"),_("br"),e._v("\ntar xzf net-tools-1.53.tar.gz")])]),e._v(" "),_("p",[e._v("Это создает каталог "),_("em",[e._v("/usr/src/redhat/SOURCES/net-tools-1.53")]),e._v(" ​​и заполняет его исходным кодом программ "),_("em",[e._v("ifconfig")]),e._v(" и "),_("em",[e._v("route")]),e._v(" (среди прочего). Этот процесс должен быть похожим (но, несомненно, не совсем таким же) для других дистрибутивов Linux.")]),e._v(" "),_("h3",{attrs:{id:"_3-4-1-ифконфиг"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-ифконфиг"}},[e._v("#")]),e._v(" 3.4.1   "),_("em",[e._v("Ифконфиг")])]),e._v(" "),_("p",[e._v("devinet_ioctl() — net/ipv4/devinet.c (398)\nсоздает структуру информационного запроса (ifreq) и копирует данные из\nпользователь в пространство ядра\nесли это запрос или действие уровня INET, выполняет его\nесли это запрос или действие устройства, вызывает функцию устройства\nкопирует ifreq обратно в память пользователя\nвозвращает 0 в случае успеха")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("ifconfig main() - SOURCES/ifconfig.c (478)\nоткрывает сокет (только для использования с функцией ioctl)\nищет аргументы командной строки для опций\nвызывает if_print(), если не было аргументов или был единственный аргумент\nэто имя интерфейса\nперебирает оставшиеся аргументы, устанавливает или очищает флаги или\nвызов ioctl() для установки переменных интерфейса\nif_fetch() — ИСТОЧНИКИ/lib/interface.c (338)\nзаполняет структуру интерфейса несколькими вызовами ioctl() для\nфлаги, аппаратный адрес, метрика, MTU, карта и адресная информация\nif_print() — ИСТОЧНИКИ/ifconfig.c (121)\nвызывает ife_print() для заданного (или всех) интерфейса(ов)\n(вызывает if_readlist() для заполнения списка структур при необходимости и\nзатем отображает информацию о каждом интерфейсе)\nif_readlist() — ИСТОЧНИКИ/lib/interface.c (261)\nоткрывает /proc/net/dev и анализирует данные в структурах интерфейса\nвызывает add_interface() для каждого устройства, чтобы поместить структуры в список\ninet_ioctl() - net/ipv4/af_inet.c (855)\nвыполняет переключение на основе переданной команды\n[для ifconfig вызывает devinet_ioctl()]\nиоктл () -\nпереходит к соответствующей процедуре обработчика [= inet_ioctl()]")])])])]),e._v(" "),_("h3",{attrs:{id:"_3-4-2-маршрут"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-маршрут"}},[e._v("#")]),e._v(" 3.4.2   "),_("em",[e._v("маршрут")])]),e._v(" "),_("p",[e._v("INET_rinput() — SOURCES/lib/inet_sr.c (305)\nпроверяет наличие ошибок (не может очистить таблицу или изменить кеш маршрутизации)\nвызывает INET_setroute()\nINET_rprint() — ИСТОЧНИКИ/lib/inet_gr.c (442)\nесли флаг FIB установлен, вызывает rprint_fib()\n(читает, анализирует и отображает содержимое /proc/net/route)\nесли флаг CACHE установлен, вызывает rprint_cache()\n(читает, анализирует и отображает содержимое /proc/net/rt_cache)\nINET_setroute() — ИСТОЧНИК/lib/inet_sr.c (57)\nустанавливает, является ли маршрут к сети или к хосту\nпроверяет, является ли адрес законным\nперебирает аргументы, заполняя структуру rtentry\nпроверяет наличие конфликтов сетевых масок\nсоздает временный сокет\nвызывает ioctl() с rtentry для добавления или удаления маршрута\nзакрывает сокет и возвращает 0\nиоктл () -\nпереходит к соответствующей процедуре обработчика [= ip_rt_ioctl()]\nip_rt_ioctl() — net/ipv4/fib_frontend.c (246)\nпреобразует переданные параметры в запись таблицы маршрутизации (struct rtentry)\nпри удалении маршрута:\nвызывает fib_get_table(), чтобы найти соответствующую таблицу\nвызывает функцию table->tb_delete(), чтобы удалить его\nесли добавить маршрут\nвызывает fib_net_table(), чтобы найти точку входа\nвызывает функцию table->tb_insert() для добавления записи\nвозвращает 0 в случае успеха")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("route main() - SOURCES/route.c (106)\nвызывает процедуры инициализации, которые устанавливают функции печати и редактирования\nполучает и анализирует параметры командной строки (воздействует на некоторые параметры\nнепосредственно путем установки флагов или отображения информации)\nпроверяет параметры (распечатывает сообщение об использовании, если есть ошибка)\nесли нет вариантов, вызывает route_info()\nесли есть возможность добавлять, удалять или сбрасывать маршруты,\nвызывает route_edit() с переданными параметрами\nесли опция недействительна, печатает сообщение об использовании\nвозвращает результат\nroute_edit() — ИСТОЧНИКИ/lib/setroute.c (69)\nвызывает get_aftype() для перевода семейства адресов из текста в указатель\nпроверяет наличие ошибок (неподдерживаемое или несуществующее семейство)\nвызывает функцию семейства адресов rinput() [= INET_rinput()]\nroute_info() — ИСТОЧНИКИ/lib/getroute.c (72)\nвызывает get_aftype() для перевода семейства адресов из текста в указатель\nпроверяет наличие ошибок (неподдерживаемое или несуществующее семейство)\nвызывает функцию семейства адресов rprint() [= INET_rprint()]")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-4"}},[e._v("#")]),e._v(" Глава 4")]),e._v(" "),_("p",[e._v("Соединения")]),e._v(" "),_("p",[e._v("В этой главе представлен процесс подключения. Он предоставляет обзор процесса подключения, описание структур данных сокетов, введение в систему маршрутизации и резюмирует код реализации в ядре.")]),e._v(" "),_("h2",{attrs:{id:"_4-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-обзор"}},[e._v("#")]),e._v(" 4.1   Обзор")]),e._v(" "),_("p",[e._v("Простейшая форма сети — это соединение между двумя хостами. На каждом конце приложение получает сокет, устанавливает соединение на транспортном уровне, а затем отправляет или получает пакеты. В Linux сокет фактически состоит из двух структур сокета (одна содержит другую). Когда приложение создает сокет, он инициализируется, но пуст. Когда сокет устанавливает соединение (независимо от того, включает ли это трафик с другой стороны), уровень IP определяет маршрут к удаленному хосту и сохраняет эту информацию в сокете. С этого момента весь трафик, использующий это соединение, использует этот маршрут — отправленные пакеты будут проходить через правильное устройство и соответствующие маршрутизаторы к удаленному хосту, а полученные пакеты появятся в очереди сокета.")]),e._v(" "),_("h2",{attrs:{id:"_4-2-структуры-сокетов"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-структуры-сокетов"}},[e._v("#")]),e._v(" 4.2   Структуры сокетов")]),e._v(" "),_("p",[e._v("В Linux есть две основные структуры сокетов: общие сокеты BSD и сокеты INET, специфичные для IP. Они сильно взаимосвязаны; сокет BSD имеет сокет INET в качестве члена данных, а сокет INET имеет сокет BSD в качестве своего владельца.")]),e._v(" "),_("p",[e._v("Сокеты BSD имеют тип struct socket , как определено в "),_("em",[e._v("include/linux/socket.h")]),e._v(" . Переменные сокета BSD обычно называются sock или его разновидностью. В этой структуре всего несколько записей, самые важные из которых описаны ниже.")]),e._v(" "),_("ul",[_("li",[e._v("struct proto_ops *ops — эта структура содержит указатели на специальные функции протокола для реализации общего поведения сокета. Например, ops- > sendmsg указывает на функцию inet_sendmsg() .")]),e._v(" "),_("li",[_("em",[e._v("struct inode *inode")]),e._v(" — эта структура указывает на индексный дескриптор файла, связанный с данным сокетом.")]),e._v(" "),_("li",[e._v("struct sock *sk — это сокет INET, связанный с этим сокетом.")])]),e._v(" "),_("p",[e._v("Сокеты INET имеют тип struct sock , определенный в "),_("em",[e._v("include/net/sock.h")]),e._v(" . Переменные сокета INET обычно называются sk или его разновидностью. Эта структура имеет много записей, связанных с широким спектром использования; есть много хаков и полей, зависящих от конфигурации. Наиболее важные члены данных описаны ниже:")]),e._v(" "),_("ul",[_("li",[e._v("struct sock *next, *pprev - все сокеты связаны различными протоколами, поэтому эти указатели позволяют протоколам проходить через них.")]),e._v(" "),_("li",[e._v("struct dst_entry *dst_cache — это указатель на маршрут к другой стороне сокета (пункт назначения для отправляемых пакетов).")]),e._v(" "),_("li",[e._v("struct sk_buff_head receive_queue — это заголовок очереди приема.")]),e._v(" "),_("li",[e._v("struct sk_buff_head write_queue — это заголовок очереди отправки.")]),e._v(" "),_("li",[e._v("__u32 saddr - адрес источника (в Интернете) для этого сокета.")]),e._v(" "),_("li",[e._v("struct sk_buff_head back_log,error_queue — дополнительные очереди для отставания пакетов (не путать с основной очередью отставания) и ошибочные пакеты для данного сокета.")]),e._v(" "),_("li",[e._v("struct proto *prot — эта структура содержит указатели на специфические функции протокола транспортного уровня. Например, prot- > recvmsg может указывать на функцию tcp_v4_recvmsg() .")]),e._v(" "),_("li",[e._v("структура объединения tcp_op af_tcp; tp_pinfo — параметры TCP для этого сокета.")]),e._v(" "),_("li",[e._v("struct socket *sock — родительский сокет BSD.")]),e._v(" "),_("li",[e._v("Обратите внимание, что в этой структуре гораздо больше полей; это только самые важные и неочевидные. Остальные либо не очень важны, либо имеют имена, говорящие сами за себя (например, ip_ttl — это счетчик IP Time-To-Live).")])]),e._v(" "),_("h2",{attrs:{id:"_4-3-сокеты-и-маршрутизация"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-сокеты-и-маршрутизация"}},[e._v("#")]),e._v(" 4.3   Сокеты и маршрутизация")]),e._v(" "),_("p",[e._v("Сокеты проходят процесс поиска маршрутизации только один раз для каждого пункта назначения (во время соединения). Поскольку сокеты Linux так тесно связаны с IP, они содержат маршруты к другому концу соединения (в переменной sock-> sk-> dst_cache ). Транспортные протоколы вызывают функцию ip_route_connect() для определения маршрута от хоста к хосту в процессе соединения; после этого предполагается, что маршрут не изменится (хотя путь, на который указывает dst_cache, действительно может измениться). Сокету не нужно постоянно просматривать таблицу маршрутизации для каждого отправляемого или получаемого пакета; он пытается снова, только если происходит что-то неожиданное (например, соседний компьютер выходит из строя). Это преимущество использования соединений.")]),e._v(" "),_("h2",{attrs:{id:"_4-4-процессы-подключения"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-процессы-подключения"}},[e._v("#")]),e._v(" 4.4   Процессы подключения")]),e._v(" "),_("h3",{attrs:{id:"_4-4-1-установление-соединении"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-установление-соединении"}},[e._v("#")]),e._v(" 4.4.1   Установление соединений")]),e._v(" "),_("p",[e._v("Прикладные программы устанавливают сокеты с помощью ряда системных вызовов, которые ищут удаленный адрес, устанавливают сокет, а затем подключаются к машине на другом конце.")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("/* поиск хоста */\nсервер = gethostbyname (ИМЯ_СЕРВЕРА);\n/* получить сокет */\nsockfd = сокет (AF_INET, SOCK_STREAM, 0);\n/* устанавливаем адрес */\nадрес.sin_family = AF_INET;\naddress.sin_port = htons(PORT_NUM);\nmemcpy(&address.sin_addr,server->h_addr,server->h_length);\n/* подключаемся к серверу */\nconnect(sockfd, &address, sizeof(address));\n")])])]),_("p",[e._v("Функция gethostbyname () просто ищет хост (например, ``viper.cs.u.edu'') и возвращает структуру, содержащую интернет-адрес (IP). Это имеет очень мало общего с маршрутизацией (только постольку, поскольку хосту может потребоваться запросить сеть для поиска адреса) и представляет собой просто перевод из удобочитаемой формы (текст) в совместимую с компьютером форму (беззнаковое 4-байтовое целое число). ).")]),e._v(" "),_("p",[e._v("Вызов socket () более интересен. Он создает объект сокета с соответствующим типом данных ( sock для сокетов INET) и инициализирует его. Сокет содержит информацию об индексе и указатели протокола для различных сетевых функций. Он также устанавливает значения по умолчанию для очередей (входящие, исходящие, ошибок и невыполненных работ), фиктивную информацию заголовка для сокетов TCP и различную информацию о состоянии.")]),e._v(" "),_("p",[e._v("Наконец, вызов connect() переходит к процедуре соединения, зависящей от протокола (например, tcp_v4_connect() или udp_connect() ). UDP просто устанавливает маршрут к месту назначения (поскольку виртуального соединения нет). TCP устанавливает маршрут, а затем начинает процесс TCP-соединения, отправляя пакет с соответствующим установленным флагом соединения и окна.")]),e._v(" "),_("h3",{attrs:{id:"_4-4-2-прохождение-вызовов-сокетов"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-прохождение-вызовов-сокетов"}},[e._v("#")]),e._v(" 4.4.2   Прохождение вызовов сокетов")]),e._v(" "),_("ul",[_("li",[e._v("Проверить наличие ошибок в звонке")]),e._v(" "),_("li",[e._v("Создать (выделить память) объект сокета")]),e._v(" "),_("li",[e._v("Поместить сокет в список INODE")]),e._v(" "),_("li",[e._v("Установить указатели на функции протокола (INET)")]),e._v(" "),_("li",[e._v("Хранить значения для типа сокета и семейства протоколов")]),e._v(" "),_("li",[e._v("Установить состояние сокета как закрытое")]),e._v(" "),_("li",[e._v("Инициализировать очереди пакетов")])]),e._v(" "),_("h3",{attrs:{id:"_4-4-3-пошаговое-подключение-к-звонку"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-3-пошаговое-подключение-к-звонку"}},[e._v("#")]),e._v(" 4.4.3   Пошаговое подключение к звонку")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("Проверить на ошибки")])]),e._v(" "),_("li",[_("p",[e._v("Определить маршрут к месту назначения:")]),e._v(" "),_("ul",[_("li",[e._v("Проверьте таблицу маршрутизации на наличие существующей записи (верните ее, если она существует)")]),e._v(" "),_("li",[e._v("Найдите пункт назначения в FIB")]),e._v(" "),_("li",[e._v("Создать новую запись в таблице маршрутизации")]),e._v(" "),_("li",[e._v("Поместить запись в таблицу маршрутизации и вернуть ее")])])]),e._v(" "),_("li",[_("p",[e._v("Сохранить указатель на запись маршрутизации в сокете")])]),e._v(" "),_("li",[_("p",[e._v("Функция соединения, специфичная для протокола вызова (например, отправка пакета TCP-соединения)")])]),e._v(" "),_("li",[_("p",[e._v("Установить состояние сокета на установленное")])])]),e._v(" "),_("h3",{attrs:{id:"_4-4-4-закрытие-соединении"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-4-закрытие-соединении"}},[e._v("#")]),e._v(" 4.4.4   Закрытие соединений")]),e._v(" "),_("p",[e._v("Закрыть сокет довольно просто. Приложение вызывает метод close() для сокета, который становится вызовом функции sock_close() . Это изменяет состояние сокета на отключение и вызывает функцию освобождения члена данных (сокета INET). Сокет INET, в свою очередь, очищает свои очереди и вызывает функцию закрытия транспортного протокола, tcp_v4_close() или udp_close() . Они выполняют любые необходимые действия (функции TCP могут отправлять пакеты для завершения соединения TCP), а затем очищают все оставшиеся структуры данных. Обратите внимание, что для маршрутизации никаких изменений не производится; (теперь пустой) сокет больше не имеет ссылки на пункт назначения, и запись в кэше маршрутизации останется до тех пор, пока она не будет освобождена из-за неиспользования.")]),e._v(" "),_("h3",{attrs:{id:"_4-4-5-закрытие-обхода"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-5-закрытие-обхода"}},[e._v("#")]),e._v(" 4.4.5   Закрытие обхода")]),e._v(" "),_("ul",[_("li",[e._v("Проверить на наличие ошибок (существует ли сокет?)")]),e._v(" "),_("li",[e._v("Измените состояние сокета на отключение, чтобы предотвратить дальнейшее использование")]),e._v(" "),_("li",[e._v("Выполните любые действия по закрытию протокола (например, отправьте TCP-пакет с установленным битом FIN)")]),e._v(" "),_("li",[e._v("Свободная память для структур данных сокетов (TCP/UDP и INET)")]),e._v(" "),_("li",[e._v("Удалить сокет из списка INODE")])]),e._v(" "),_("h2",{attrs:{id:"_4-5-функции-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-функции-linux"}},[e._v("#")]),e._v(" 4.5   Функции Linux")]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для соединений, где они находятся в исходном коде и что они делают. Чтобы следовать вызовам функций для создания сокета, начните с sock_create() . Чтобы следовать вызовам функций для закрытия сокета, начните с sock_close() .")]),e._v(" "),_("p",[e._v("destroy_sock — net/ipv4/af_inet.c (195)\nудаляет любые таймеры\nвызывает любые специфичные для протоколов функции уничтожения\nосвобождает очереди сокетов\nосвобождает саму структуру сокета\nfib_lookup() — include/net/ip_fib.h (153)\nвызывает tb_lookup() [= fn_hash_lookup()] для локальных и основных таблиц\nвозвращает маршрут или недостижимую ошибку\nfn_hash_lookup() — net/ipv4/fib_hash.c (261)\nищет и возвращает маршрут к адресу\ninet_create() - net/ipv4/af_inet.c (326)\nвызывает sk_alloc(), чтобы получить память для sock\nинициализирует структуру носка:\nустанавливает структуру прототипа в соответствующие значения для TCP или UDP\nвызывает sock_init_data()\nустанавливает семью, протокол и т. д. переменные\nвызывает функцию инициализации протокола (если есть)\ninet_release() — net/ipv4/af_inet.c (463)\nизменяет состояние сокета на отключение\nвызывает ip_mc_drop_socket для выхода из группы многоадресной рассылки (при необходимости)\nустанавливает владение элементом данных сокета в NULL\nвызывает sk->prot->close() [=TCP/UDP_close()]\nip_route_connect() — include/net/route.h (140)\nвызывает ip_route_output() для получения адреса назначения\nвозвращает, если вызов работает или генерирует ошибку\nв противном случае очищает указатель маршрута и повторяет попытку\nip_route_output() — net/ipv4/route.c (1664)\nвычисляет хеш-значение для адреса\nпроходит через таблицу (начиная с хэша) для сопоставления адресов и TOS\nесли есть совпадение, обновляет статистику и возвращает запись маршрута\nиначе вызывает ip_route_output_slow()\nip_route_output_slow() — net/ipv4/route.c (1421)\nесли исходный адрес известен, ищет выходное устройство\nесли адрес назначения неизвестен, устанавливает петлю\nвызывает fib_lookup() для поиска маршрута в FIB\nвыделяет память для новой записи в таблице маршрутизации\nинициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,\nфлаги\nвызывает rt_set_nexthop(), чтобы найти следующий пункт назначения\nвозвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации\nrt_intern_hash() — net/ipv4/route.c (526)\nперебирает rt_hash_table (начиная с хеш-значения)\nесли ключи совпадают, поместите запись rtable в переднее ведро\nиначе поместите запись rtable в хеш-таблицу по адресу hash")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("sock_close() - net/socket.c (476)\nпроверяет, существует ли сокет (может быть нулевым)\nвызывает sock_fasync() для удаления сокета из асинхронного списка\nвызывает sock_release()")])])]),e._v(" "),_("blockquote",[_("blockquote",[_("p",[e._v("sock_create() - net/socket.c (571)\nпроверяет параметры\nвызывает sock_alloc() для получения доступного inode для сокета и\nинициализировать его\nустанавливает тип сокета-> (на SOCK_STREAM, SOCK_DGRAM...)\nвызывает net_family->create() [= inet_create()] для построения структуры sock\nвозвращает установленный сокет\nsock_init_data() - net/core/sock.c (1018)\nинициализирует все общие значения носка\nsock_release() - сеть/socket.c (309)\nменяет состояние на отключение\nвызывает sock->ops->release() [= inet_release()]\nвызывает iput() для удаления сокета из списка инодов\nsys_socket() — сеть/socket.c (639)\nвызывает sock_create() для получения и инициализации сокета\nвызывает get_fd() для назначения fd сокету\nустанавливает socket->file в fcheck() (указатель на файл)\nвызывает sock_release(), если что-то не получается\ntcp_close() - сеть/ipv4/tcp.c (1502)\nпроверить на ошибки\nизвлекает и отбрасывает все пакеты из входящей очереди\nотправляет сообщения адресату, чтобы закрыть соединение (если требуется)\ntcp_connect() — сеть/ipv4/tcp_output.c (910)\nзавершает пакет соединения с соответствующими битами и установленными размерами окна\nпомещает пакет в очередь вывода сокета\nвызывает tcp_transmit_skb() для отправки пакета, инициируя TCP-соединение\ntcp_v4_connect() - сеть/ipv4/tcp_ipv4.c (571)\nпроверяет на ошибки\nвызывает ip_route_connect() для поиска маршрута к месту назначения\nсоздает пакет подключения"),_("br"),e._v("\nвызывает tcp_connect() для отправки пакета\nudp_close() - сеть/ipv4/udp.c (954)\nвызывает udp_v4_unhash() для удаления сокета из списка сокетов\nвызывает destroy_sock()\nudp_connect() - сеть/ipv4/udp.c (900)\nвызывает ip_route_connect() для поиска маршрута к месту назначения\nобновляет сокет с адресами и портами источника и назначения\nизменяет состояние сокета на установленное\nсохраняет маршрут назначения в sock->dst_cache")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-5"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-5"}},[e._v("#")]),e._v(" Глава 5")]),e._v(" "),_("p",[e._v("Отправка сообщений")]),e._v(" "),_("p",[e._v("В этой главе представлена ​​сторона отправки сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.")]),e._v(" "),_("h2",{attrs:{id:"_5-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-обзор"}},[e._v("#")]),e._v(" 5.1   Обзор")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/s_tx.gif",alt:"s_tx.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 5.1: Передача сообщения.")]),e._v(" "),_("p",[e._v("Исходящее сообщение начинается с системного вызова приложения для записи данных в сокет. Сокет проверяет свой собственный тип соединения и вызывает соответствующую процедуру отправки (обычно INET). Функция отправки проверяет состояние сокета, проверяет его тип протокола и отправляет данные в процедуру транспортного уровня (такую ​​как TCP или UDP). Этот протокол создает новый буфер для исходящего пакета (буфер сокета или struct sk_buff skb).), копирует данные из буфера приложения и заполняет информацию своего заголовка (такую ​​как номер порта, параметры и контрольная сумма) перед передачей нового буфера на сетевой уровень (обычно IP). Функции отправки IP заполняют большую часть буфера собственными заголовками протокола (такими как IP-адрес, параметры и контрольная сумма). При необходимости он также может фрагментировать пакет. Затем уровень IP передает пакет функции уровня канала, которая перемещает пакет в очередь xmit отправляющего устройства и гарантирует, что устройство знает, что у него есть трафик для отправки. Наконец, устройство (такое как сетевая карта) сообщает шине о необходимости отправить пакет.")]),e._v(" "),_("h2",{attrs:{id:"_5-2-отправка-обхода"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-отправка-обхода"}},[e._v("#")]),e._v(" 5.2   Отправка обхода")]),e._v(" "),_("h3",{attrs:{id:"_5-2-1-запись-в-сокет"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-запись-в-сокет"}},[e._v("#")]),e._v(" 5.2.1   Запись в сокет")]),e._v(" "),_("ul",[_("li",[e._v("Запись данных в сокет (приложение)")]),e._v(" "),_("li",[e._v("Заполните заголовок сообщения расположением данных (сокет)")]),e._v(" "),_("li",[e._v("Проверить наличие основных ошибок — привязан ли сокет к порту? может ли сокет отправлять сообщения? что-то не так с розеткой?")]),e._v(" "),_("li",[e._v("Передайте заголовок сообщения соответствующему транспортному протоколу (сокет INET).")])]),e._v(" "),_("h3",{attrs:{id:"_5-2-2-создание-пакета-с-udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-создание-пакета-с-udp"}},[e._v("#")]),e._v(" 5.2.2   Создание пакета с UDP")]),e._v(" "),_("ul",[_("li",[e._v("Проверить на ошибки — данные слишком велики? это UDP соединение?")]),e._v(" "),_("li",[e._v("Убедитесь, что маршрут к месту назначения существует (вызовите процедуры IP-маршрутизации, если маршрут еще не установлен; сбой, если маршрута нет)")]),e._v(" "),_("li",[e._v("Создайте заголовок UDP (для пакета)")]),e._v(" "),_("li",[e._v("Вызов функции построения и передачи IP")])]),e._v(" "),_("h3",{attrs:{id:"_5-2-3-создание-пакета-с-tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-3-создание-пакета-с-tcp"}},[e._v("#")]),e._v(" 5.2.3   Создание пакета с TCP")]),e._v(" "),_("ul",[_("li",[e._v("Проверить соединение - установлено? он открыт? розетка работает?")]),e._v(" "),_("li",[e._v("Проверяйте и комбинируйте данные с частичными пакетами, если это возможно")]),e._v(" "),_("li",[e._v("Создать буфер пакетов")]),e._v(" "),_("li",[e._v("Скопируйте полезную нагрузку из пользовательского пространства")]),e._v(" "),_("li",[e._v("Добавьте пакет в исходящую очередь")]),e._v(" "),_("li",[e._v("Встроить текущий заголовок TCP в пакет (с ACK, SYN и т. д.)")]),e._v(" "),_("li",[e._v("Вызов функции IP-передачи")])]),e._v(" "),_("h3",{attrs:{id:"_5-2-4-упаковка-пакета-в-ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-4-упаковка-пакета-в-ip"}},[e._v("#")]),e._v(" 5.2.4   Упаковка пакета в IP")]),e._v(" "),_("ul",[_("li",[e._v("Создать буфер пакетов (при необходимости — UDP)")]),e._v(" "),_("li",[e._v("Узнать маршрут до пункта назначения (при необходимости - TCP)")]),e._v(" "),_("li",[e._v("Заполнить IP-заголовок пакета")]),e._v(" "),_("li",[e._v("Скопируйте заголовок транспорта и полезную нагрузку из пользовательского пространства.")]),e._v(" "),_("li",[e._v("Отправьте пакет в функцию вывода устройства целевого маршрута.")])]),e._v(" "),_("h3",{attrs:{id:"_5-2-5-передача-пакета"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-5-передача-пакета"}},[e._v("#")]),e._v(" 5.2.5   Передача пакета")]),e._v(" "),_("ul",[_("li",[e._v("Поместите пакет в очередь вывода устройства")]),e._v(" "),_("li",[e._v("Разбудить устройство")]),e._v(" "),_("li",[e._v("Подождите, пока планировщик запустит драйвер устройства.")]),e._v(" "),_("li",[e._v("Протестируйте носитель (устройство)")]),e._v(" "),_("li",[e._v("Отправить заголовок ссылки")]),e._v(" "),_("li",[e._v("Скажите шине передать пакет по среде")])]),e._v(" "),_("h2",{attrs:{id:"_5-3-функции-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-функции-linux"}},[e._v("#")]),e._v(" 5.3   Функции Linux")]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для трафика сообщений, где они находятся в исходном коде и что они делают. Чтобы отслеживать вызовы функций, начните с sock_write() .")]),e._v(" "),_("p",[e._v("dev_queue_xmit() — net/core/dev.c (579)\nвызывает start_bh_atomic()\nесли у устройства есть очередь\nвызывает enqueue() для добавления пакета в очередь\nвызывает qdisc_wakeup() [= qdisc_restart()] для пробуждения устройства\nиначе вызывает hard_start_xmit()\nвызывает end_bh_atomic()\nDEVICE->hard_start_xmit() - зависит от устройства, drivers/net/DEVICE.c\nпроверяет, открыта ли среда\nотправляет заголовок\nговорит шине отправить пакет\nобновляет статус\ninet_sendmsg() — net/ipv4/af_inet.c (786)\nизвлекает указатель на сокет sock\nпроверяет сокет, чтобы убедиться, что он работает\nпроверяет указатель протокола\nвозвращает sk->prot[tcp/udp]->sendmsg()\nip_build_xmit-net/ipv4/ip_output.c (604)\nвызывает sock_alloc_send_skb() для установки памяти для skb\nустанавливает заголовок skb\nвызывает getfrag() [= udp_getfrag()] для копирования буфера из пространства пользователя\nвозвращает rt->u.dst.output() [= dev_queue_xmit()]\nip_queue_xmit() - net/ipv4/ip_output.c (234)\nищет маршрут\nстроит IP-заголовок\nфрагменты при необходимости\nдобавляет контрольную сумму IP\nвызывает skb->dst->output() [= dev_queue_xmit()]\nqdisc_restart() - net/sched/sch_generic.c (50)\nвыталкивает пакет из очереди\nвызывает dev->hard_start_xmit()\nобновляет статус\nесли произошла ошибка, запрашивает пакет\nsock_sendmsg() - net/socket.c (325)\nвызывает scm_sendmsg() [сообщение управления сокетом]\nвызывает sock->ops[inet]->sendmsg() и уничтожает scm")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("sock_write() - net/socket.c (399)\nвызывает socki_lookup(), чтобы связать сокет с inode fd/file\nсоздает и заполняет заголовок сообщения размером данных/адресами\nвозвращает sock_sendmsg()\ntcp_do_sendmsg() — сеть/ipv4/tcp.c (755)\nожидает подключения, если необходимо\nвызывает skb_tailroom() и добавляет данные в ожидающий пакет, если это возможно\nпроверяет состояние окна\nвызывает sock_wmalloc() для получения памяти для skb\nвызывает csum_and_copy_from_user() для копирования пакета и выполнения контрольной суммы\nвызывает tcp_send_skb()\ntcp_send_skb() — сеть/ipv4/tcp_output.c (160)\nвызывает __skb_queue_tail() для добавления пакета в очередь\nвызывает tcp_transmit_skb(), если это возможно\ntcp_transmit_skb() — сеть/ipv4/tcp_output.c (77)\nстроит заголовок TCP и добавляет контрольную сумму\nвызывает tcp_build_and_update_options()\nпроверяет ACK, SYN\nвызывает tp->af_specific[ip]->queue_xmit()\ntcp_v4_sendmsg() — сеть/ipv4/tcp_ipv4.c (668)\nпроверяет тип IP-адреса, открывает соединение, адреса портов\nвозвращает tcp_do_sendmsg()\nudp_getfrag() — сеть/ipv4/udp.c (516)\nкопирует и вычисляет контрольную сумму буфера из пользовательского пространства\nudp_sendmsg() — сеть/ipv4/udp.c (559)\nдлина проверок, флаги, протокол\nустанавливает заголовок UDP и адресную информацию\nпроверяет мультикаст\nзаполняет маршрут\nзаполняет оставшуюся часть заголовка\nвызывает ip_build_xmit()\nобновляет статус UDP\nвозвращает ошибку")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-6"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-6"}},[e._v("#")]),e._v(" Глава 6")]),e._v(" "),_("p",[e._v("Получение сообщений")]),e._v(" "),_("p",[e._v("В этой главе представлена ​​принимающая сторона трафика сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.")]),e._v(" "),_("h2",{attrs:{id:"_6-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-обзор"}},[e._v("#")]),e._v(" 6.1   Обзор")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_rx.gif",alt:"r_rx.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 6.1: Получение сообщений.")]),e._v(" "),_("p",[e._v('Входящее сообщение начинается с прерывания, когда система уведомляет устройство о готовности сообщения. Устройство выделяет место для хранения и указывает шине поместить сообщение в это пространство. Затем он передает пакет канальному уровню, который помещает его в очередь невыполненных работ и помечает сетевой флаг для следующего запуска "нижней половины".')]),e._v(" "),_("p",[e._v("Нижняя половина — это система Linux, которая сводит к минимуму объем работы, выполняемой во время прерывания. Выполнение большого объема обработки во время прерывания нехорошо именно потому, что это прерывает работающий процесс; вместо этого у обработчиков прерываний есть «верхняя половина» и «нижняя половина». Когда поступает прерывание, запускается верхняя половина и выполняет любые критические операции, такие как перемещение данных из очереди устройства в память ядра. Затем он помечает флаг, сообщающий ядру, что есть еще работа, когда у процессора есть время, и возвращает управление текущему процессу. В следующий раз, когда планировщик процессов запустится, он увидит флаг, проделает дополнительную работу и только затем запланирует любые нормальные процессы.")]),e._v(" "),_("p",[e._v("Когда планировщик процессов видит, что есть сетевые задачи, он запускает нижнюю половину сети. Эта функция извлекает пакеты из очереди ожидания, сопоставляет их с известным протоколом (обычно IP) и передает их функции приема этого протокола. Уровень IP проверяет пакет на наличие ошибок и направляет его; пакет попадет в исходящую очередь (если он предназначен для другого хоста) или до транспортного уровня (например, TCP или UDP). Этот уровень снова проверяет наличие ошибок, ищет сокет, связанный с портом, указанным в пакете, и помещает пакет в конец очереди приема этого сокета.")]),e._v(" "),_("p",[e._v("Как только пакет окажется в очереди сокета, сокет разбудит процесс приложения, которому он принадлежит (при необходимости). Затем этот процесс может выполнить или вернуться из системного вызова чтения , который копирует данные из пакета в очереди в свой собственный буфер. (Процесс также может пока ничего не делать, если он не ждал пакет, и получить данные из очереди, когда они ему понадобятся.)")]),e._v(" "),_("h2",{attrs:{id:"_6-2-получение-обхода"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-получение-обхода"}},[e._v("#")]),e._v(" 6.2   Получение обхода")]),e._v(" "),_("h3",{attrs:{id:"_6-2-1-чтение-из-сокета-часть-i"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-чтение-из-сокета-часть-i"}},[e._v("#")]),e._v(" 6.2.1   Чтение из сокета (Часть I)")]),e._v(" "),_("ul",[_("li",[e._v("Попробуйте прочитать данные из сокета (приложения)")]),e._v(" "),_("li",[e._v("Заполните заголовок сообщения расположением буфера (сокета)")]),e._v(" "),_("li",[e._v("Проверить наличие основных ошибок — привязан ли сокет к порту? может ли сокет принимать сообщения? что-то не так с розеткой?")]),e._v(" "),_("li",[e._v("Передайте заголовок сообщения соответствующему транспортному протоколу (сокет INET).")]),e._v(" "),_("li",[e._v("Спите, пока не будет достаточно данных для чтения из сокета (TCP/UDP)")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-2-получение-пакета"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-получение-пакета"}},[e._v("#")]),e._v(" 6.2.2   Получение пакета")]),e._v(" "),_("ul",[_("li",[e._v("Разбудить принимающее устройство (прерывание)")]),e._v(" "),_("li",[e._v("Протестируйте носитель (устройство)")]),e._v(" "),_("li",[e._v("Получите заголовок ссылки")]),e._v(" "),_("li",[e._v("Выделить место для пакета")]),e._v(" "),_("li",[e._v("Скажите шине поместить пакет в буфер")]),e._v(" "),_("li",[e._v("Поместите пакет в очередь ожидания")]),e._v(" "),_("li",[e._v("Установите флаг для запуска нижней половины сети, когда это возможно")]),e._v(" "),_("li",[e._v("Вернуть управление текущему процессу")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-3-запуск-сети-нижняя-половина"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-3-запуск-сети-нижняя-половина"}},[e._v("#")]),e._v(' 6.2.3   Запуск сети "Нижняя половина"')]),e._v(" "),_("ul",[_("li",[e._v("Запустите нижнюю половину сети (планировщик)")]),e._v(" "),_("li",[e._v("Отправлять любые ожидающие пакеты для предотвращения прерываний (нижняя половина)")]),e._v(" "),_("li",[e._v("Перебрать все пакеты в очереди невыполненных работ и передать пакет до его протокола приема в Интернете — IP.")]),e._v(" "),_("li",[e._v("Снова очистить очередь отправки")]),e._v(" "),_("li",[e._v("Выход из нижней половины")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-4-развертка-пакета-в-ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-4-развертка-пакета-в-ip"}},[e._v("#")]),e._v(" 6.2.4   Развертка пакета в IP")]),e._v(" "),_("ul",[_("li",[e._v("Проверить пакет на наличие ошибок - слишком короткий? слишком долго? неверная версия? ошибка контрольной суммы?")]),e._v(" "),_("li",[e._v("Дефрагментация пакета при необходимости")]),e._v(" "),_("li",[e._v("Получите маршрут для пакета (может быть для этого хоста или может потребоваться переадресация)")]),e._v(" "),_("li",[e._v("Отправьте пакет в подпрограмму обработки назначения (прием TCP или UDP или, возможно, повторная передача на другой хост)")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-5-прием-пакета-в-udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-5-прием-пакета-в-udp"}},[e._v("#")]),e._v(" 6.2.5   Прием пакета в UDP")]),e._v(" "),_("ul",[_("li",[e._v("Проверьте заголовок UDP на наличие ошибок")]),e._v(" "),_("li",[e._v("Сопоставить пункт назначения с сокетом")]),e._v(" "),_("li",[e._v("Отправить сообщение об ошибке обратно, если такого сокета нет")]),e._v(" "),_("li",[e._v("Поместить пакет в соответствующую очередь приема сокета")]),e._v(" "),_("li",[e._v("Разбудить любые процессы, ожидающие данных из этого сокета")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-6-прием-пакета-в-tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-6-прием-пакета-в-tcp"}},[e._v("#")]),e._v(" 6.2.6   Прием пакета в TCP")]),e._v(" "),_("ul",[_("li",[e._v("Проверить последовательность и флаги; сохранить пакет в правильном месте, если это возможно")]),e._v(" "),_("li",[e._v("Если он уже получен, немедленно отправьте ACK и отбросьте пакет.")]),e._v(" "),_("li",[e._v("Определить, какой пакет сокета принадлежит")]),e._v(" "),_("li",[e._v("Поместить пакет в соответствующую очередь приема сокета")]),e._v(" "),_("li",[e._v("Пробуждение и процессы, ожидающие данных из этого сокета")])]),e._v(" "),_("h3",{attrs:{id:"_6-2-7-чтение-из-сокета-часть-ii"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-7-чтение-из-сокета-часть-ii"}},[e._v("#")]),e._v(" 6.2.7   Чтение из сокета (Часть II)")]),e._v(" "),_("ul",[_("li",[e._v("Просыпаться, когда данные готовы (сокет)")]),e._v(" "),_("li",[e._v("Функция приема на транспортном уровне вызова")]),e._v(" "),_("li",[e._v("Переместить данные из очереди приема в пользовательский буфер (TCP/UDP)")]),e._v(" "),_("li",[e._v("Вернуть данные и управление в приложение (сокет)")])]),e._v(" "),_("h2",{attrs:{id:"_6-3-функции-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-функции-linux"}},[e._v("#")]),e._v(" 6.3   Функции Linux")]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для получения трафика, где они находятся в исходном коде и что они делают. Чтобы отслеживать вызовы функций из сети вверх, начните с DEVICE_rx() . Чтобы отслеживать вызовы функций из приложения вниз, начните с sock_read() .")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("DEVICE_rx() - зависит от устройства, drivers/net/DEVICE.c\n(получает управление от прерывания)\nвыполняет проверки состояния, чтобы убедиться, что он должен получать\nвызывает dev_alloc_skb(), чтобы зарезервировать место для пакета\nполучает пакет от системной шины\nвызывает eth_type_trans() для определения типа протокола\nвызывает netif_rx()\nобновляет статус карты\n(возврат из прерывания)\ninet_recvmsg() — net/ipv4/af_inet.c (764)\nизвлекает указатель на сокет sock\nпроверяет сокет, чтобы убедиться, что он принимает\nпроверяет указатель протокола\nвозвращает sk->prot[tcp/udp]->recvmsg()\nip_rcv() - сеть/ipv4/ip_input.c (395)\nпроверяет пакет на наличие ошибок:\nнедопустимая длина (слишком короткая или слишком длинная)\nнеправильная версия (не 4)\nневерная контрольная сумма\nвызывает __skb_trim() для удаления заполнения\nдефрагментирует пакет при необходимости\nвызывает ip_route_input() для маршрутизации пакета\nпроверяет и обрабатывает параметры IP\nвозвращает skb->dst->input() [= tcp_rcv,udp_rcv()]\nnet_bh() - net/core/dev.c (835)\n(запускается планировщиком)\nесли есть пакеты, ожидающие выхода, вызывает qdisc_run_queues()\n(см. раздел отправки)\nпока очередь невыполненных работ не пуста\nпусть другие нижние половины бегут\nвызовите skb_dequeue(), чтобы получить следующий пакет\nесли пакет для кого-то другого (FASTROUTED) ставится в очередь на отправку\nпрокручивать списки протоколов (отводы и основной) для соответствия типу протокола\nвызовите pt_prev->func() [= ip_rcv()] для передачи пакета соответствующему\nпротокол\nвызовите qdisc_run_queues() для сброса вывода (при необходимости)\nnetif_rx() - net/core/dev.c (757)\nставит время в skb->stamp\nесли очередь невыполненных работ слишком заполнена, отбрасывает пакет\nеще\nвызывает skb_queue_tail() для помещения пакета в очередь ожидания\nотмечает нижнюю половину для последующего выполнения\nsock_def_readable() - net/core/sock.c (989)\nвызывает wake_up_interruptible(), чтобы поместить ожидающий процесс в очередь выполнения\nвызывает sock_wake_async() для отправки SIGIO в процесс сокета\nsock_queue_rcv_skb() — include/net/sock.h (857)\nвызывает skb_queue_tail() для помещения пакета в очередь приема сокета\nвызывает sk->data_ready() [= sock_def_readable()]")])])]),e._v(" "),_("blockquote",[_("blockquote",[_("p",[e._v("sock_read() - net/socket.c (366)\nустанавливает заголовки сообщений\nвозвращает sock_recvmsg() с результатом чтения\nsock_recvmsg() — сеть/socket.c (338)\nчитает пакет управления сокетом (scm) или пакет\nвызов sock->ops[inet]->recvmsg()\ntcp_data() — сеть/ipv4/tcp_input.c (1507)\nсжимает очередь приема при необходимости\nвызывает tcp_data_queue() для постановки пакета в очередь\nвызывает sk->data_ready() для пробуждения сокета\ntcp_data_queue() — net/ipv4/tcp_input.c (1394)\nесли пакет не по порядку:\nесли старый, сразу выбрасывает\nиначе вычисляет соответствующее место хранения\nвызывает __skb_queue_tail() для помещения пакета в очередь приема сокета\nобновляет состояние подключения\ntcp_rcv_installed() - net/ipv4/tcp_input.c (1795)\nесли быстрый путь\nпроверяет все флаги и информацию заголовка\nотправляет подтверждение\nвызывает _skb_queue_tail() для помещения пакета в очередь приема сокета\nиначе (медленный путь)\nесли не по порядку, отправляет ACK и отбрасывает пакет\nпроверить наличие FIN, SYN, RST, ACK\nвызывает tcp_data() для постановки пакета в очередь\nотправляет подтверждение\ntcp_recvmsg() — сеть/ipv4/tcp.c (1149)\nпроверяет на ошибки\nподождите, пока не будет доступен хотя бы один пакет\nочищает сокет, если соединение закрыто\nвызывает memcpy_toiovec() для копирования полезной нагрузки из буфера сокета в\nпользовательское пространство\nвызывает cleanup_rbuf() для освобождения памяти и отправки ACK при необходимости\nвызывает remove_wait_queue() для пробуждения процесса (при необходимости)\nudp_queue_rcv_skb() — сеть/ipv4/udp.c (963)\nвызывает sock_queue_rcv_skb()\nобновляет статус UDP (освобождает skb, если очередь не удалась)\nudp_rcv() - сеть/ipv4/udp.c (1062)\nполучает заголовок UDP, обрезает пакет, проверяет контрольную сумму (при необходимости)\nпроверяет мультикаст\nвызывает udp_v4_lookup() для сопоставления пакета с сокетом\nесли сокет не найден, отправьте сообщение ICMP обратно, освободите skb и остановите\nвызывает udp_deliver() [= udp_queue_rcv_skb()]\nudp_recvmsg() — сеть/ipv4/udp.c (794)\nвызывает skb_recv_datagram() для получения пакета из очереди\nвызывает skb_copy_datagram_iovec() для перемещения полезной нагрузки из буфера сокета\nв пространство пользователя\nобновляет метку времени сокета\nзаполняет исходную информацию в заголовке сообщения\nосвобождает память пакетов")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-7"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-7"}},[e._v("#")]),e._v(" Глава 7")]),e._v(" "),_("p",[e._v("IP-переадресация")]),e._v(" "),_("p",[e._v("В этой главе представлена ​​чистая сторона маршрутизации (посредством IP-переадресации) трафика сообщений. Он предоставляет обзор процесса, исследует уровни, через которые проходят пакеты, детализирует действия каждого уровня и обобщает код реализации в ядре.")]),e._v(" "),_("h2",{attrs:{id:"_7-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-обзор"}},[e._v("#")]),e._v(" 7.1   Обзор")]),e._v(" "),_("p",[e._v("См. Рисунок "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#f_fwd",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.1"),_("OutboundLink")],1),e._v(" для абстрактной схемы процесса пересылки. (По сути, это комбинация процессов получения и отправки.)")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/f_fwd.gif",alt:"f_fwd.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 7.1: IP-переадресация.")]),e._v(" "),_("p",[e._v('Переадресованный пакет поступает с прерыванием, когда система уведомляет устройство о готовности сообщения. Устройство выделяет место для хранения и указывает шине поместить сообщение в это пространство. Затем он передает пакет канальному уровню, который помещает его в очередь невыполненных работ, помечает сетевой флаг для следующего выполнения "нижней половины" и возвращает управление текущему процессу.')]),e._v(" "),_("p",[e._v("Когда планировщик процессов запускается в следующий раз, он видит, что есть сетевые задачи, которые нужно выполнить, и запускает ``нижнюю половину'' сети. Эта функция извлекает пакеты из очереди ожидания, сопоставляет их с IP и передает их функции получения. Уровень IP проверяет пакет на наличие ошибок и направляет его; пакет будет подниматься на транспортный уровень (например, TCP или UDP, если он предназначен для этого хоста) или в боковом направлении к функции IP-пересылки. В рамках функции пересылки IP проверяет пакет и отправляет сообщение ICMP обратно отправителю, если что-то не так. Затем он копирует пакет в новый буфер и при необходимости фрагментирует его.")]),e._v(" "),_("p",[e._v("Наконец, уровень IP передает пакет функции уровня канала, которая перемещает пакет в очередь xmit отправляющего устройства и гарантирует, что устройство знает, что у него есть трафик для отправки. Наконец, устройство (такое как сетевая карта) сообщает шине о необходимости отправить пакет.")]),e._v(" "),_("h2",{attrs:{id:"_7-2-прохождение-ip-forward-walk-through"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-прохождение-ip-forward-walk-through"}},[e._v("#")]),e._v(" 7.2   Прохождение IP Forward Walk-Through")]),e._v(" "),_("h3",{attrs:{id:"_7-2-1-получение-пакета"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-1-получение-пакета"}},[e._v("#")]),e._v(" 7.2.1   Получение пакета")]),e._v(" "),_("ul",[_("li",[e._v("Разбудить принимающее устройство (прерывание)")]),e._v(" "),_("li",[e._v("Протестируйте носитель (устройство)")]),e._v(" "),_("li",[e._v("Получите заголовок ссылки")]),e._v(" "),_("li",[e._v("Выделить место для пакета")]),e._v(" "),_("li",[e._v("Скажите шине поместить пакет в буфер")]),e._v(" "),_("li",[e._v("Поместите пакет в очередь ожидания")]),e._v(" "),_("li",[e._v("Установите флаг для запуска нижней половины сети, когда это возможно")]),e._v(" "),_("li",[e._v("Вернуть управление текущему процессу")])]),e._v(" "),_("h3",{attrs:{id:"_7-2-2-запуск-сети-нижняя-половина"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-2-запуск-сети-нижняя-половина"}},[e._v("#")]),e._v(' 7.2.2   Запуск сети "Нижняя половина"')]),e._v(" "),_("ul",[_("li",[e._v("Запустите нижнюю половину сети (планировщик)")]),e._v(" "),_("li",[e._v("Отправлять любые ожидающие пакеты для предотвращения прерываний (net_bh)")]),e._v(" "),_("li",[e._v("Перебрать все пакеты в очереди невыполненных работ и передать пакет до его протокола приема в Интернете — IP.")]),e._v(" "),_("li",[e._v("Снова очистить очередь отправки")]),e._v(" "),_("li",[e._v("Выход из нижней половины")])]),e._v(" "),_("h3",{attrs:{id:"_7-2-3-проверка-пакета-в-ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-3-проверка-пакета-в-ip"}},[e._v("#")]),e._v(" 7.2.3   Проверка пакета в IP")]),e._v(" "),_("ul",[_("li",[e._v("Проверить пакет на наличие ошибок - слишком короткий? слишком долго? неверная версия? ошибка контрольной суммы?")]),e._v(" "),_("li",[e._v("Дефрагментация пакета при необходимости")]),e._v(" "),_("li",[e._v("Получите маршрут для пакета (может быть для этого хоста или может потребоваться переадресация)")]),e._v(" "),_("li",[e._v("Отправьте пакет в подпрограмму обработки назначения (в этом случае повторная передача на другой хост)")])]),e._v(" "),_("h3",{attrs:{id:"_7-2-4-пересылка-пакета-в-ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-4-пересылка-пакета-в-ip"}},[e._v("#")]),e._v(" 7.2.4   Пересылка пакета в IP")]),e._v(" "),_("ul",[_("li",[e._v("Проверьте поле TTL (и уменьшите его)")]),e._v(" "),_("li",[e._v("Проверить пакет на неправильную (нежелательную) маршрутизацию")]),e._v(" "),_("li",[e._v("Отправьте ICMP обратно отправителю, если есть какие-либо проблемы")]),e._v(" "),_("li",[e._v("Скопируйте пакет в новый буфер и освободите старый")]),e._v(" "),_("li",[e._v("Установите любые параметры IP")]),e._v(" "),_("li",[e._v("Фрагментировать пакет, если он слишком велик для нового пункта назначения")]),e._v(" "),_("li",[e._v("Отправьте пакет в функцию вывода устройства целевого маршрута")])]),e._v(" "),_("h3",{attrs:{id:"_7-2-5-передача-пакета"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-5-передача-пакета"}},[e._v("#")]),e._v(" 7.2.5   Передача пакета")]),e._v(" "),_("ul",[_("li",[e._v("Поместите пакет в очередь вывода устройства")]),e._v(" "),_("li",[e._v("Разбудить устройство")]),e._v(" "),_("li",[e._v("Подождите, пока планировщик запустит драйвер устройства.")]),e._v(" "),_("li",[e._v("Протестируйте носитель (устройство)")]),e._v(" "),_("li",[e._v("Отправить заголовок ссылки")]),e._v(" "),_("li",[e._v("Скажите шине передать пакет по среде")])]),e._v(" "),_("h2",{attrs:{id:"_7-3-функции-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-функции-linux"}},[e._v("#")]),e._v(" 7.3   Функции Linux")]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций ядра Linux, наиболее важных для IP-переадресации, где они находятся в исходном коде и что они делают. Чтобы следить за вызовами функций, начните с DEVICE_rx().")]),e._v(" "),_("p",[e._v("dev_queue_xmit() — net/core/dev.c (579)\nвызывает start_bh_atomic()\nесли у устройства есть очередь\nвызывает enqueue() для добавления пакета в очередь\nвызывает qdisc_wakeup() [= qdisc_restart()] для пробуждения устройства\nиначе вызывает hard_start_xmit()\nвызывает end_bh_atomic()\nDEVICE->hard_start_xmit() - зависит от устройства, drivers/net/DEVICE.c\nпроверяет, открыта ли среда\nотправляет заголовок\nговорит шине отправить пакет\nобновляет статус")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("DEVICE_rx() - зависит от устройства, drivers/net/DEVICE.c\n(получает управление от прерывания)\nвыполняет проверки состояния, чтобы убедиться, что он должен получать\nвызывает dev_alloc_skb(), чтобы зарезервировать место для пакета\nполучает пакет от системной шины\nвызывает eth_type_trans() для определения типа протокола\nвызывает netif_rx()\nобновляет статус карты\n(возврат из прерывания)\nip_finish_output() - включить/net/ip.h (140)\nустанавливает отправляющее устройство в устройство вывода для данного маршрута\nвызывает функцию вывода для пункта назначения [= dev_queue_xmit()]\nip_forward() - сеть/ipv4/ip_forward.c (72)\nпроверяет предупреждения маршрутизатора\nесли пакет не предназначен для какого-либо хоста, отбрасывает его\nесли TTL истек, отбрасывает пакет и отправляет сообщение ICMP обратно\nесли нельзя следовать строгому маршруту, отбрасывает пакет и отправляет ICMP\nсообщение обратно отправителю\nпри необходимости отправляет ICMP-сообщение о том, что пакет отправителя перенаправлен\nкопирует и выпускает старый пакет\nуменьшает TTL\nесли есть опции, вызывает ip_forward_options() для их установки\nвызывает ip_send()\nip_rcv() - сеть/ipv4/ip_input.c (395)\nпроверяет пакет на наличие ошибок:\nнедопустимая длина (слишком короткая или слишком длинная)\nнеправильная версия (не 4)\nневерная контрольная сумма\nвызывает __skb_trim() для удаления заполнения\nдефрагментирует пакет при необходимости\nвызывает ip_route_input() для маршрутизации пакета\nпроверяет и обрабатывает параметры IP\nвозвращает skb->dst->input() [= ip_forward()]\nip_route_input() — net/ipv4/route.c (1366)\nвызывает rt_hash_code() для получения индекса для таблицы маршрутизации\nперебирает таблицу маршрутизации (начиная с хэша), чтобы найти соответствие для пакета\nесли он находит совпадение:\nобновляет статистику маршрута (время и использование)\nустанавливает место назначения пакета в запись таблицы маршрутизации\nвозвращает успех\nеще\nпроверяет многоадресные адреса\nвозвращает результат ip_route_input_slow() (попытка маршрутизации)\nip_route_output_slow() — net/ipv4/route.c (1421)\nесли исходный адрес известен, ищет выходное устройство\nесли адрес назначения неизвестен, настройте loopback\nвызывает fib_lookup() для поиска маршрута\nвыделяет память для новой записи в таблице маршрутизации\nинициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,\nфлаги\nвызывает rt_set_nexthop(), чтобы найти следующий пункт назначения\nвозвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации\nip_send() - включить/net/ip.h (162)\nвызывает ip_fragment(), если пакет слишком велик для устройства\nвызывает ip_finish_output()\nnet_bh() - net/core/dev.c (835)\n(запускается планировщиком)\nесли есть пакеты, ожидающие выхода, вызывает qdisc_run_queues()\n(см. раздел отправки)\nпока очередь невыполненных работ не пуста\nпусть другие нижние половины бегут\nвызовите skb_dequeue(), чтобы получить следующий пакет\nесли пакет для кого-то другого (FASTROUTED) ставится в очередь на отправку\nпрокручивать списки протоколов (отводы и основной) для соответствия типу протокола\nвызовите pt_prev->func() [= ip_rcv()] для передачи пакета соответствующему\nпротокол\nвызовите qdisc_run_queues() для сброса вывода (при необходимости)\nnetif_rx() - net/core/dev.c (757)\nставит время в skb->stamp\nесли очередь невыполненных работ слишком заполнена, отбрасывает пакет\nеще\nвызывает skb_queue_tail() для помещения пакета в очередь ожидания\nотмечает нижнюю половину для последующего выполнения\nqdisc_restart() - net/sched/sch_generic.c (50)\nвыталкивает пакет из очереди\nвызывает dev->hard_start_xmit()\nобновляет статус\nесли произошла ошибка, запрашивает пакет\nrt_intern_hash() — net/ipv4/route.c (526)\nпомещает новый маршрут в таблицу маршрутизации")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-8"}},[e._v("#")]),e._v(" Глава 8")]),e._v(" "),_("p",[e._v("Базовая маршрутизация интернет-протокола")]),e._v(" "),_("p",[e._v("В этой главе представлены основы IP-маршрутизации. В нем содержится обзор того, как работает маршрутизация, исследуется, как создаются и обновляются таблицы маршрутизации, и обобщается код реализации в ядре.")]),e._v(" "),_("h2",{attrs:{id:"_8-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-обзор"}},[e._v("#")]),e._v(" 8.1   Обзор")]),e._v(" "),_("p",[e._v("Linux поддерживает три набора данных маршрутизации — один для компьютеров, которые напрямую подключены к хосту (например, через локальную сеть), и два для компьютеров, которые подключены только косвенно (через IP-сеть). Изучите рисунок  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.1"),_("OutboundLink")],1),e._v(" , чтобы увидеть, как могут выглядеть записи для компьютера в общем примере.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_overview.gif",alt:"r_overview.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.1: Пример общей таблицы маршрутизации.")]),e._v(" "),_("p",[e._v('Таблица соседей содержит информацию об адресах компьютеров, которые физически подключены к хосту (отсюда и название "сосед"). Он включает информацию о том, какое устройство к какому соседу подключается и какие протоколы использовать при обмене данными. Linux использует протокол разрешения адресов (ARP) для поддержки и обновления этой таблицы; он динамичен в том смысле, что записи добавляются по мере необходимости, но в конечном итоге исчезают, если не используются снова в течение определенного времени. (Однако администраторы могут сделать записи постоянными, если это имеет смысл.)')]),e._v(" "),_("p",[e._v('Linux использует два сложных набора таблиц маршрутизации для поддержки IP-адресов: универсальную информационную базу пересылки (FIB) с указаниями на все возможные адреса и меньший (и более быстрый) кэш маршрутизации с данными о часто используемых маршрутах. Когда IP-пакет должен быть отправлен на удаленный узел, уровень IP сначала проверяет кэш маршрутизации на наличие записи с соответствующим источником, пунктом назначения и типом службы. Если такая запись есть, IP использует ее. Если нет, IP запрашивает маршрутную информацию из более полной (но более медленной) FIB, создает новую запись кэша с этими данными, а затем использует новую запись. В то время как записи FIB являются полупостоянными (обычно они изменяются только при включении или отключении маршрутизаторов), записи кэша остаются только до тех пор, пока не устареют (они не используются в течение "долгого" периода).')]),e._v(" "),_("h2",{attrs:{id:"_8-2-таблицы-маршрутизации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-таблицы-маршрутизации"}},[e._v("#")]),e._v(" 8.2   Таблицы маршрутизации")]),e._v(" "),_("p",[e._v("Примечание: в этих таблицах есть ссылки на переменные таких типов, как u32 (порядок байтов хоста) и __u32 (порядок байтов сети). В архитектуре Intel они оба эквивалентны unsigned int s, и на самом деле они все равно транслируются (с использованием функции ntohl ); тип просто указывает порядок, в котором хранится содержащееся в нем значение.")]),e._v(" "),_("h3",{attrs:{id:"_8-2-1-таблица-соседеи"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-таблица-соседеи"}},[e._v("#")]),e._v(" 8.2.1   Таблица соседей")]),e._v(" "),_("p",[e._v("Таблица соседей (структура которой показана на рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_neigh_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2"),_("OutboundLink")],1),e._v(" ) содержит информацию о компьютерах, физически связанных с главным компьютером. (Обратите внимание, что в исходном коде используется европейское написание «neighbour».) Записи (обычно) не являются постоянными; эта таблица может не содержать записей (если компьютер в последнее время не пропускал сетевой трафик) или может содержать столько записей, сколько компьютеров физически подключено к его сети (если он недавно связывался со всеми из них). Записи в таблице на самом деле являются другими структурами таблиц, которые содержат адресацию, устройство, протокол и статистическую информацию.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_neigh_struct.gif",alt:"r_neigh_struct.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.2: Отношения структуры данных Neighbor Table.")]),e._v(" "),_("p",[e._v("struct neigh_table *neigh_tables — эта глобальная переменная является указателем на список соседних таблиц; каждая таблица содержит набор общих функций и данных, а также хэш-таблицу конкретной информации о наборе соседей. Это очень подробная низкоуровневая таблица, содержащая конкретную информацию, такую ​​как приблизительное время прохождения сообщений, размеры очередей, указатели устройств и указатели на функции устройств.")]),e._v(" "),_("p",[e._v("Таблица соседей ( struct neigh_table ) Структура - эта структура (элемент списка) содержит общую информацию о соседях и таблицу данных о соседях и данных pneigh. Все компьютеры, подключенные через один тип подключения (например, одну карту Ethernet), будут находиться в одной таблице.")]),e._v(" "),_("ul",[_("li",[e._v("struct neigh_table *next — указатель на следующую таблицу в списке.")]),e._v(" "),_("li",[e._v("struct neigh_parms parms — структура, содержащая время в пути сообщения, длину очереди и статистическую информацию; на самом деле это глава списка.")]),e._v(" "),_("li",[e._v("struct neigh_parms *parms_list — указатель на список информационных структур.")]),e._v(" "),_("li",[e._v("struct Neighbor *hash_buckets[] - хеш-таблица соседей, связанных с этой таблицей; есть NEIGH_HASHMASK+1 (32) сегмента.")]),e._v(" "),_("li",[e._v("struct pneigh_entry *phash_buckets[] — хэш-таблица структур, содержащих указатели и ключи устройств; имеется PNEIGH_HASHMASK+1 (16) сегментов.")]),e._v(" "),_("li",[e._v("Другие поля включают информацию о таймере, указатели функций, блокировки и статистику.")])]),e._v(" "),_("p",[e._v("Данные соседа ( struct Neighbor ) Структура - эти структуры содержат конкретную информацию о каждом соседе.")]),e._v(" "),_("ul",[_("li",[e._v("struct device *dev - указатель на устройство, которое подключено к этому соседу.")]),e._v(" "),_("li",[e._v("__u8 nud_state — флаги состояния; значения могут быть неполными, достижимыми, устаревшими и т. д.; также содержит информацию о состоянии для постоянства и использования ARP.")]),e._v(" "),_("li",[e._v("struct hh_cache *hh - указатель на кешированный аппаратный заголовок для передачи этому соседу.")]),e._v(" "),_("li",[e._v("struct sk_buff_head arp_queue — указатель на пакеты ARP для этого соседа.")]),e._v(" "),_("li",[e._v("Другие поля включают указатели на списки, указатели на функции (таблицы) и статистическую информацию.")])]),e._v(" "),_("h3",{attrs:{id:"_8-2-2-информационная-база-пересылки"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-2-информационная-база-пересылки"}},[e._v("#")]),e._v(" 8.2.2   Информационная база пересылки")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_gen.gif",alt:"r_fib_gen.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.3: Концептуальная организация пересылающей информационной базы (FIB).")]),e._v(" "),_("p",[e._v("Информационная база пересылки (FIB) — самая важная структура маршрутизации в ядре; это сложная структура, которая содержит информацию о маршрутизации, необходимую для достижения любого действительного IP-адреса по его сетевой маске. По сути, это большая таблица с общей адресной информацией вверху и очень конкретной информацией внизу. Уровень IP вводит в таблицу адрес назначения пакета и сравнивает его с самой конкретной сетевой маской, чтобы увидеть, совпадают ли они. Если это не так, IP переходит к следующей наиболее общей сетевой маске и снова сравнивает их. Когда он, наконец, находит совпадение, IP копирует «направления» к удаленному хосту в кэш маршрутизации и отправляет пакет по пути. См. рисунки  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3"),_("OutboundLink")],1),e._v("  и  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.4."),_("OutboundLink")],1),e._v("для организации и структур данных, используемых в FIB — обратите внимание, что на рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_fib_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.3"),_("OutboundLink")],1),e._v(" показаны некоторые другие возможности FIB, такие как два набора сетевой информации для одной зоны, и поэтому он не соответствует общему примеру.)")]),e._v(" "),_("p",[e._v("struct fib_table *local_table, *main_table - эти глобальные переменные являются точками доступа к таблицам FIB; они указывают на структуры таблиц, которые указывают на хеш-таблицы, указывающие на зоны. Содержимое переменной main_table находится в "),_("em",[e._v("/proc/net/route")]),e._v(" .")]),e._v(" "),_("p",[e._v("Таблица FIB Структура fib_table — "),_("em",[e._v("include/net/ip_fib.h")]),e._v(" — эти структуры содержат таблицы переходов функций, каждая из которых указывает на хеш-таблицу, содержащую информацию о зоне. Обычно их всего один или два.")]),e._v(" "),_("ul",[_("li",[e._v("int (*tb_ "),_("em",[e._v("functions")]),e._v(" )() — указатели на табличные функции (поиск, удаление, вставка и т. д.), которые при инициализации устанавливаются в fn_hash_function "),_("em",[e._v("(")]),e._v(" ) .")]),e._v(" "),_("li",[e._v("unsigned char tb_data[0] — указатель на ассоциированную хэш-таблицу FIB (несмотря на ее объявление как массив символов).")]),e._v(" "),_("li",[e._v("unsigned char tb_id - идентификатор таблицы; 255 для local_table , 254 для main_table .")]),e._v(" "),_("li",[e._v("беззнаковый tb_stamp")])]),e._v(" "),_("p",[e._v("Таблица сетевых масок Структура fn_hash - "),_("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" - эти структуры содержат указатели на отдельные зоны, организованные по сетевой маске. (Каждая зона соответствует уникальной маске сети.) Существует одна такая маска для каждой таблицы FIB (если только две таблицы не указывают на одну и ту же хеш-таблицу).")]),e._v(" "),_("ul",[_("li",[e._v("struct fn_zone *fn_zones[33] — указатели на записи зоны (одна зона для каждого бита в маске; fn_zone[0] указывает на зону для сетевой маски 0x0000, fn_zone[1] указывает на зону для 0x8000 и fn_zone[32] указывает на зону для 0xFFFF.")]),e._v(" "),_("li",[e._v("struct fn_zone *fn_zone_list - указатель на первую (самую конкретную) непустую зону в списке; если есть запись для сетевой маски 0xFFFF, она будет указывать на эту зону, в противном случае она может указывать на зону 0xFFF0, 0xFF00, 0xF000 и т. д.")])]),e._v(" "),_("p",[e._v("Сетевая зона Структура fn_zone — "),_("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" — эти структуры содержат некоторую информацию о хешировании и указатели на хеш-таблицы узлов. Существует один из них для каждой известной сетевой маски.")]),e._v(" "),_("ul",[_("li",[e._v("struct fn_zone *fz_next — указатель на следующую непустую зону в хеш-структуре (следующая наиболее общая сетевая маска; например, fn_hash- > fn_zone[28]- > fz_next может указывать на fn_hash- > fn_zone[27] ).")]),e._v(" "),_("li",[e._v("struct fib_node **fz_hash — указатель на хеш-таблицу узлов для этой зоны.")]),e._v(" "),_("li",[e._v("int fz_nent — количество записей (узлов) в этой зоне.")]),e._v(" "),_("li",[e._v("int fx_divisor — количество сегментов в хеш-таблице, связанных с этой зоной; в таблице 16 сегментов для большинства зон (кроме первой зоны - 0000 - петлевого устройства).")]),e._v(" "),_("li",[e._v("u32 fz_hashmask — маска для входа в хеш-таблицу узлов; 15 (0x0F) для большинства зон, 0 для зоны 0).")]),e._v(" "),_("li",[e._v("int fz_order — индекс этой зоны в родительской структуре fn_hash (от 0 до 32).")]),e._v(" "),_("li",[e._v("u32 fz_mask - маска сети зоны, определяемая как ~ ((1<<(32-fz_order))-1) ; например, первый (нулевой) элемент сдвинут влево на 1 32 минус 0 раз (0x10000), минус 1 (0xFFFF) и дополнен (0x0000). Второй элемент имеет сетевую маску 0x8000, следующий 0xC000, следующий 0xE000, 0xF000, 0xF800 и так далее до последнего (32d) элемента с маской 0xFFFF.")])]),e._v(" "),_("p",[e._v("Информация о сетевом узле Структура fib_node — "),_("em",[e._v("net/ipv4/fib_hash.c")]),e._v(" — эти структуры содержат информацию, уникальную для каждого набора адресов, и указатель на информацию об общих функциях (таких как устройства и протоколы); по одному для каждой известной сети (уникальная комбинация источника/назначения/TOS).")]),e._v(" "),_("ul",[_("li",[e._v("struct fib_node *fn_next — указатель на следующий узел.")]),e._v(" "),_("li",[e._v("struct fib_info *fn_info — указатель на дополнительную информацию об этом узле (общую для многих узлов).")]),e._v(" "),_("li",[e._v("fn_key_t fn_key — ключ хеш-таблицы — младшие 8 бит адреса назначения (или 0 для петлевого устройства).")]),e._v(" "),_("li",[e._v("Другие поля содержат конкретную информацию об этом узле (например, fn_tos и fn_state ).")])]),e._v(" "),_("p",[e._v("Информация о сетевом протоколе ( fib_info ) Структура — "),_("em",[e._v("include/net/ip_fib.h")]),e._v(" — эти структуры содержат информацию о протоколе и оборудовании, специфичную для интерфейса и, следовательно, общую для многих потенциальных зон; несколько сетей могут быть адресованы через один и тот же интерфейс (например, тот, который ведет к остальной части Интернета). Существует один из них для каждого интерфейса.")]),e._v(" "),_("ul",[_("li",[e._v("fib_protocol — индекс сетевого протокола (например, IP), используемого для данного маршрута.")]),e._v(" "),_("li",[e._v("struct fib_nh fib_nh[0] — содержит указатель на устройство, используемое для отправки или получения трафика по данному маршруту.")]),e._v(" "),_("li",[e._v("Другие поля включают указатели на списки, а также статистические и справочные данные (например, fib_refcnt и fib_flags .")])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_fib_struct.gif",alt:"r_fib_struct.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.4: Отношения данных Базы пересылаемой информации (FIB).")]),e._v(" "),_("p",[_("strong",[e._v("Пример обхода FIB:")])]),e._v(" "),_("ol",[_("li",[e._v("ip_route_output_slow() (вызывается потому, что маршрут не находится в кэше маршрутизации) устанавливает структуру rt_key с адресом источника 172.16.0.7, адресом назначения 172.16.0.34 и TOS 2.")]),e._v(" "),_("li",[e._v("ip_route_output_slow() вызывает fib_lookup() и передает ему ключ для поиска.")]),e._v(" "),_("li",[e._v("fib_lookup() вызывает local_table- > tb_lookup() (которая является ссылкой на функцию fn_hash_lookup ), чтобы локальная таблица нашла ключ.")]),e._v(" "),_("li",[e._v("fn_hash_lookup() выполняет поиск в хэш-таблице локальной таблицы, начиная с наиболее конкретной зоны - 24 (сетевая маска 255.255.255.0, десятичное число с точками) (на которую указывает переменная fn_zone_list ).")]),e._v(" "),_("li",[e._v("fz_key() создает тестовый ключ, объединяя адрес назначения с сетевой маской зоны и получая значение ключа 172.16.0.0.")]),e._v(" "),_("li",[e._v("fz_chain() выполняет хеш-функцию (см. fn_hash() ) и объединяет это значение с fz_hashmask зоны (15), чтобы получить индекс (6) в хеш-таблице узлов зоны. К сожалению, этот узел пуст; в этой зоне нет возможных совпадений.")]),e._v(" "),_("li",[e._v("fn_hash_lookup() переходит к следующей непустой зоне - 16 (сетевая маска 255.255.0.0, десятичное число с точками) (на которую указывает переменная fz_next текущей зоны ).")]),e._v(" "),_("li",[e._v("fz_key() создает новый тестовый ключ, объединяя адрес назначения и маску сети этой зоны, в результате чего значение ключа равно 172.16.0.0.")]),e._v(" "),_("li",[e._v("fz_chain() выполняет хеш-функцию и объединяет это значение с fz_hashmask зоны (15), чтобы получить индекс (10) в хеш-таблице узлов зоны. В этом слоте есть узел.")]),e._v(" "),_("li",[e._v("fn_hash_lookup() сравнивает свой ключ поиска с ключом узла. Они не совпадают, но значение ключа поиска меньше, чем у ключа узла, поэтому он переходит к следующему узлу.")]),e._v(" "),_("li",[e._v("fn_hash_lookup() сравнивает свой ключ поиска с ключом нового узла. Они совпадают, поэтому он выполняет некоторую проверку ошибок и проверяет точное совпадение с узлом и связанной с ним информационной переменной.")]),e._v(" "),_("li",[e._v("Поскольку все совпадает, fn_hash_lookup() заполняет структуру fib_result всей информацией об этом маршруте. (В противном случае он будет продолжать проверять больше узлов и зон, пока не найдет совпадение или полностью не выйдет из строя.)")]),e._v(" "),_("li",[e._v("ip_route_output_slow() берет структуру fib_result и, предполагая, что все в порядке, создает из нее новую запись кэша маршрутизации.")])]),e._v(" "),_("h3",{attrs:{id:"_8-2-3-кэш-маршрутизации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-3-кэш-маршрутизации"}},[e._v("#")]),e._v(" 8.2.3   Кэш маршрутизации")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_gen.gif",alt:"r_cache_gen.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.5: Концептуальная организация кэша маршрутизации.")]),e._v(" "),_("p",[e._v("Кэш маршрутизации — это самый быстрый метод поиска маршрута в Linux; он сохраняет каждый маршрут, который используется в настоящее время или недавно использовался, в хеш-таблице. Когда IP нужен маршрут, он переходит к соответствующему сегменту хэша и ищет цепочку кэшированных маршрутов, пока не найдет совпадение, а затем отправляет пакет по этому пути. (См. раздел "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sec_the_FIB",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.2.2"),_("OutboundLink")],1),e._v(" о том, что происходит, когда маршрут еще не находится в кэше.) Маршруты выстраиваются в цепочку по порядку, наиболее часто используемые первыми, и имеют таймеры и счетчики, которые удаляют их из таблицы, когда они больше не используются. См. рисунок  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_gen",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.5"),_("OutboundLink")],1),e._v(" для абстрактного обзора и рисунки  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_cache_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.6"),_("OutboundLink")],1),e._v("  и  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#r_dst_struct",target:"_blank",rel:"noopener noreferrer"}},[e._v("8.7"),_("OutboundLink")],1),e._v(" для подробных диаграмм структур данных.")]),e._v(" "),_("p",[e._v("struct rtable *rt_hash_table[RT_HASH_DIVISOR] — эта глобальная переменная содержит 256 сегментов (указателей) цепочек записей кэша маршрутизации ( rtable ); хеш-функция объединяет адрес источника, адрес назначения и TOS, чтобы получить точку входа в таблицу (от 0 до 255). Содержимое этой таблицы указано в "),_("em",[e._v("/proc/net/rt_cache")]),e._v(" .")]),e._v(" "),_("p",[e._v("Структура записи таблицы маршрутизации ( rtable ) — "),_("em",[e._v("include/net/route.h")]),e._v(" — эти структуры содержат записи кэша назначения и идентификационную информацию, специфичную для каждого маршрута.")]),e._v(" "),_("ul",[_("li",[e._v("объединение < struct dst_entry dst; struct rtable* rt_next) > u - это запись в таблице; структура объединения позволяет быстро получить доступ к следующей записи в таблице за счет чрезмерного использования поля next rtable для указания на следующую запись кэша, если это необходимо.")]),e._v(" "),_("li",[e._v("__u32 rt_dst — адрес назначения.")]),e._v(" "),_("li",[e._v("__u32 rt_src — исходный адрес.")]),e._v(" "),_("li",[e._v("rt_int iif - интерфейс ввода.")]),e._v(" "),_("li",[e._v("__u32 rt_gateway — адрес соседа, через которого следует маршрут для достижения пункта назначения.")]),e._v(" "),_("li",[e._v("struct rt_key key — структура, содержащая ключ поиска в кэше (с полями src, dst, iif, oif, tos и scope)")]),e._v(" "),_("li",[e._v("Другие поля содержат флаги, тип и другую разную информацию.")])]),e._v(" "),_("p",[e._v("Структура кеша назначения ( dst_entry ) — "),_("em",[e._v("include/net/dst.h")]),e._v(" — эти структуры содержат указатели на определенные входные и выходные функции и данные для маршрута.")]),e._v(" "),_("ul",[_("li",[e._v("struct device *dev - устройство ввода/вывода для данного маршрута.")]),e._v(" "),_("li",[e._v("unsigned pmtu - максимальный размер пакета для данного маршрута.")]),e._v(" "),_("li",[e._v("struct Neighbor *neighbor - указатель на соседа (следующую ссылку) для данного маршрута.")]),e._v(" "),_("li",[e._v("struct hh_cache *hh — указатель на аппаратный кэш заголовков; поскольку это одинаково для каждого исходящего пакета по физическому каналу, он сохраняется для быстрого доступа и повторного использования.")]),e._v(" "),_("li",[e._v("int ("),_("em",[e._v("input)(struct sk_buff")]),e._v(") — указатель на входную функцию для этого маршрута (обычно tcp_recv() ).")]),e._v(" "),_("li",[e._v("int ("),_("em",[e._v("output)(struct sk_buff")]),e._v(") — указатель на функцию вывода для этого маршрута (обычно dev_queue_xmit() ).")]),e._v(" "),_("li",[e._v("struct dst_ops *ops — указатель на структуру, содержащую семейство, протокол и функции проверки, перенаправления и уничтожения для этого маршрута.")]),e._v(" "),_("li",[e._v("Другие поля содержат статистическую информацию и информацию о состоянии, а также ссылки на другие записи таблицы маршрутизации.")])]),e._v(" "),_("p",[e._v("Структура Neighbor Link ( сосед ) — "),_("em",[e._v("include/net/neighbor.h")]),e._v(" — эти структуры, по одной для каждого хоста, который находится ровно в одном переходе, содержат указатели на свои функции доступа и информацию.")]),e._v(" "),_("ul",[_("li",[e._v("struct device *dev - указатель на устройство, которое физически подключено к этому соседу.")]),e._v(" "),_("li",[e._v("struct hh_cache *hh — указатель на аппаратный заголовок, который всегда предшествует трафику, отправляемому этому соседу.")]),e._v(" "),_("li",[e._v("int ("),_("em",[e._v("output)(struct sk_buff")]),e._v(") — указатель на функцию вывода для этого соседа (обычно dev_queue_xmit() ?).")]),e._v(" "),_("li",[e._v("struct sk_buff_head arp_queue — первый элемент в очереди ARP для трафика, относящегося к этому соседу — входящего или исходящего?")]),e._v(" "),_("li",[e._v("struct neigh_ops *ops - указатель на структуру, содержащую данные о семействе и функции вывода для этой ссылки.")]),e._v(" "),_("li",[e._v("Другие поля содержат статистическую информацию и информацию о состоянии, а также ссылки на других соседей.")])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_cache_struct.gif",alt:"r_cache_struct.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.6: Отношения структуры данных кэша маршрутизации.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/r_dst_struct.gif",alt:"r_dst_struct.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 8.7: Отношения структуры данных целевого кэша.")]),e._v(" "),_("p",[_("strong",[e._v("Пример обхода кэша маршрутизации:")])]),e._v(" "),_("ol",[_("li",[e._v("ip_route_output() (вызывается для поиска маршрута) вызывает rt_hash_code() с адресом источника 172.16.1.1, адресом назначения 172.16.1.6 и TOS 2.")]),e._v(" "),_("li",[e._v("rt_hash_code() выполняет хэш-функцию для источника, получателя и TOS и объединяет результат с 255, чтобы получить запись в хэш-таблицу (5).")]),e._v(" "),_("li",[e._v("ip_route_output() входит в хеш-таблицу по индексу 5. Там есть запись, но адреса назначения не совпадают.")]),e._v(" "),_("li",[e._v("ip_route_output() переходит к следующей записи (на которую указывает поле u.rt_next последней записи). Это соответствует в каждом случае - адрес назначения, адрес источника, iif из 0, соответствующий oif и приемлемый TOS.")]),e._v(" "),_("li",[e._v("ip_route_output() обновляет статистику в новой структуре dst_cache записи таблицы, устанавливает указатель для вызывающей функции, чтобы он ссылался на маршрут, и возвращает 0, указывающий на успех.")])]),e._v(" "),_("h3",{attrs:{id:"_8-2-4-обновление-маршрутнои-информации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-4-обновление-маршрутнои-информации"}},[e._v("#")]),e._v(" 8.2.4   Обновление маршрутной информации")]),e._v(" "),_("p",[e._v("Linux обновляет информацию о маршрутизации только при необходимости, но таблицы изменяются по-разному. Кэш маршрутизации является наиболее изменчивым, в то время как FIB обычно вообще не меняется.")]),e._v(" "),_("p",[e._v("Таблица соседей изменяется по мере обмена сетевым трафиком. Если хосту нужно отправить что-то на адрес, который находится в локальной подсети, но еще не находится в таблице соседей, он просто передает запрос ARP и добавляет новую запись в таблицу соседей, когда получает ответ. Периодически записи истекают и исчезают; этот цикл продолжается бесконечно (если только маршрут не был специально помечен как постоянный ARP). Ядро обрабатывает большинство изменений автоматически.")]),e._v(" "),_("p",[e._v("FIB на большинстве хостов и даже маршрутизаторов остается статичным; он заполняется во время инициализации всеми возможными зонами для маршрутизации через все подключенные маршрутизаторы и никогда не изменяется, если только один из маршрутизаторов не выйдет из строя. ( Подробнее о демонах IP-маршрутизации см. в главе "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#dyn_route",target:"_blank",rel:"noopener noreferrer"}},[e._v("9 )."),_("OutboundLink")],1),e._v(" Изменения должны поступать через внешние вызовы ioctl() для добавления или удаления зон.")]),e._v(" "),_("p",[e._v("Кэш маршрутизации часто меняется в зависимости от трафика сообщений. Если хосту необходимо отправить пакеты на удаленный адрес, он ищет адрес в кэше маршрутизации (и при необходимости в FIB) и отправляет пакет через соответствующий маршрутизатор. На узле, подключенном к локальной сети с одним маршрутизатором, подключенным к Интернету, каждая запись будет указывать либо на соседнего узла, либо на маршрутизатор, но может быть много записей, указывающих на маршрутизатор (по одной на каждый удаленный адрес). Записи создаются по мере установления соединений и быстро истекают, когда трафик на этот адрес перестает течь. Все делается с помощью вызовов уровня IP для создания маршрутов и таймеров ядра для их удаления.")]),e._v(" "),_("h2",{attrs:{id:"_8-3-функции-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-функции-linux"}},[e._v("#")]),e._v(" 8.3   Функции Linux")]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций ядра Linux, которые наиболее важны для маршрутизации, где они находятся в исходном коде и что они делают.")]),e._v(" "),_("p",[e._v("arp_rcv() - сеть/ipv4/arp.c (542)\nпроверяет наличие ошибок (устройство без ARP, отсутствие устройства, пакет не для хоста,\nтип устройства не совпадает и т.д.)\nпроверить на работоспособность - понимает только ОТВЕТ и ЗАПРОС\nизвлекает данные из пакета\nпроверка плохих запросов - петлевых или многоадресных адресов\nпроверяет пакет обнаружения дубликатов адресов (при необходимости отправляет ответ)\nесли сообщение является запросом и ip_route_input() имеет значение true:\nесли пакет локальный:\nвызывает neigh_event_ns() для поиска и обновления соседа, отправившего пакет\nпроверяет скрытое устройство (не отвечает, если скрыто)\nотправляет ответ с адресом устройства\nв противном случае:\nвызывает neigh_event_ns() для поиска и обновления соседа, отправившего пакет\nвызывает neigh_release()\nпри необходимости вызывает arp_send() с адресом\nв противном случае вызывает pneigh_enqueue() и возвращает 0\nесли сообщение является ответом:\nвызывает __neigh_lookup()\nпроверяет, пришло ли несколько ответов ARP; сохраняет только\nсамый быстрый (первый)\nвызывает neigh_update() для обновления записи ARP\nвызывает neigh_release()\nосвобождает skbuffer и возвращает 0\narp_send() - net/ipv4/arp.c (434)\nпроверяет, поддерживает ли устройство ARP\nвыделяет skbuffer\nзаполняет информацию заголовка буфера\nзаполняет информацию ARP\nвызывает dev_queue_xmit() с готовым пакетом\narp_req_get() — net/ipv4/arp.c (848)\nвызывает __neigh_lookup() для поиска записи по заданному адресу\nкопирует данные из соседней записи в запись arpreq\nвозвращает 0, если найден, или ENXIO, если адрес отсутствует в таблице ARP.\nfib_get_procinfo() — net/ipv4/fib_frontend.c (109)\nвыводит заголовок и результаты main_table->fn_hash_get_info() для proc FS\nfib_lookup() — include/net/ip_fib.h (153)\nвызывает tb_lookup() [= fn_hash_lookup()] для local_table и main_table\nесли у любого из них есть запись, он заполняет fib_result и возвращает 0\nиначе возвращает недостижимую ошибку\nfib_node_get_info() — net/ipv4/fib_semantics.c (971)\nвыводит содержимое fib_node и fib_info для proc FS\nfib_validate_source() — net/ipv4/fib_frontend.c (191)\nпроверяет устройство и адрес входящего пакета\nвозвращает код ошибки, если что-то не так\nвозвращает 0, если пакет кажется легальным\nfn_hash() — net/ipv4/fib_hash.c (108)\nвыполняет хеш-функцию на адресе назначения:\nu32 h = ntohl(daddr)>>(32 - fib_zone->fz_order);\nч ^= (ч>>20);\nч ^= (ч>>10);\nч ^= (ч>>5);\nч &= FZ_HASHMASK(fz); // FZ_HASHMASK равен 15 почти для всех зон\nfn_hash_get_info() — net/ipv4/fib_hash.c (723)\nперебирает зоны в таблице FIB, печатая fib_node_get_info() для\nпроц ФС\nfn_hash_lookup() — net/ipv4/fib_hash.c (261)\nперебирает зоны в заданной таблице\nперебирает узлы в каждой зоне (начиная с хеш-записи)\nесли сетевые маски (узел и пункт назначения) совпадают\nпроверяет TOS и статус узла\nвызывает fib_semantic_match() для проверки типа пакета\nзаполняет fib_result данными об успехе и возвращает 0\nвозвращает 1, если ничего не совпало\nfn_new_zone() — net/ipv4/fib_hash.c (220)\nвыделяет память (в ядре) для новой зоны\nвыделяет место для 16 сегментов узлов для зоны (кроме первой зоны -\n0.0.0.0 [loopback] - который получает только один)\nхранит сетевую маску (крайние левые n бит, где n — позиция\nзона в таблице)\nищет более конкретную зону в родительской таблице\nвставляет зону в список зон (наиболее конкретная зона - голова)\nустанавливает новую зону в родительскую таблицу\nвозвращает новую зону\nfz_chain() - net/ipv4/fib_hash.c (133)\nвызывает fn_hash() для получения хеш-значения\nвозвращает fib_node в fib_zone по хеш-индексу\nip_dev_find() - net/ipv4/fib_frontend.c (147)\nищет и возвращает устройство с заданным адресом в локальной таблице\nip_route_connect() — include/net/route.h (140)\nвызывает ip_route_output() для получения адреса назначения\nвозвращает, если вызов работает или генерирует ошибку\nв противном случае очищает указатель маршрута и повторяет попытку\nip_route_input() — net/ipv4/route.c (1366)\nвычисляет хеш-значение для адреса\nпросматривает таблицу (начиная с хэша), чтобы найти совпадение соединения\n(источник, место назначения, TOS и IIF/OIF)\nесли есть совпадение, обновляет статистику и возвращает запись маршрутизации\nиначе вызывает ip_route_input_slow()\nip_route_input_slow() — net/ipv4/route.c (1097)\nсоздает ключ кэша таблицы маршрутизации\nпроверяет наличие специальных адресов (таких как петля, широковещательная рассылка или ошибки)\nвызывает fib_lookup() для поиска маршрута\nвыделяет память для новой записи таблицы маршрутизации\nинициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,\nфлаги\nвызывает fib_validate_source() для проверки источника пакета\nсообщение printks и возвращает ошибку, если источник неверный\nвызывает rt_set_nexthop() для поиска следующего пункта назначения (соседнего)\nвозвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации\nip_route_output() — net/ipv4/route.c (1664)\nвычисляет хеш-значение для адреса\nпросматривает таблицу (начиная с хэша), чтобы найти совпадение соединения\n(источник, место назначения, TOS и IIF/OIF)\nесли есть совпадение, обновляет статистику и возвращает запись маршрутизации\nиначе вызывает ip_route_output_slow()\nip_route_output_slow() — net/ipv4/route.c (1421)\nсоздает ключ кэша таблицы маршрутизации\nесли исходный адрес известен, вызывает ip_dev_find для определения выходного устройства\nесли адрес назначения неизвестен, настройте loopback\nвызывает fib_lookup() для поиска маршрута\nвыделяет память для новой записи таблицы маршрутизации\nинициализирует запись таблицы с источником, местом назначения, TOS, устройством вывода,\nфлаги\nвызывает rt_set_nexthop() для поиска следующего пункта назначения (соседнего)\nвозвращает rt_intern_hash(), который устанавливает маршрут в таблице маршрутизации\nip_rt_ioctl() - net/ipv4/fib_frontend.c (250)\nвключает SIOCADDRT или SIOCDELRT (в противном случае возвращает EINVAL)\nпроверяет разрешение и копирует аргумент в пространство ядра\nпреобразует скопированный аргумент в структуру rtentry\nпри удалении маршрута вызывает fib_get_table() и table->delete()\nиначе вызывает fib_new_table() и table->insert()\nосвобождает место для аргумента и возвращает 0 в случае успеха\nneigh_event_ns() - net/core/neighbour.c (760)\nвызывает __neigh_lookup() для поиска адреса в соседней таблице\nвызывает neigh_update()\nвозвращает указатель на назначенного соседа\nneigh_update() - net/core/neighbour.c (668)\nпроверяет права на изменение таблицы\nпроверяет статус соседа, если это не новая запись\nсравнивает заданный адрес с кешированным:\nесли ноль или устройство не имеет адреса, использует текущий адрес\nесли отличается, проверьте флаг переопределения\nвызывает neigh_sync(), чтобы убедиться, что сосед все еще активен\nобновляет время контакта с соседом\nесли старая запись была действительна, а новая не меняет адрес, возвращает 0\nесли новый адрес отличается от старого, заменяет старый новым\nесли новое и старое состояния совпадают, возвращает 0\nвызывает neigh_connect() или neigh_suspect() для установки/проверки соединения\nесли старое состояние было недействительным:\nпросматривает пакеты в очереди ARP, вызывая соседний output()\nфункция на каждом\nочищает очередь ARP\nвозвращает 0\nrt_cache_get_info() — net/ipv4/route.c (191)\nпечатает заголовок и все элементы rt_hash_table для proc FS\nrt_hash_code() — net/ipv4/route.c (18)\nиспользует адрес источника, адрес назначения и тип службы для\nопределить (и вернуть) хеш-значение:\nhash = ((daddr&0xF0F0F0F0)>>4)|((daddr&0x0F0F0F0F)<<4);\nхэш = хэш ^ сад ^ тос;\nхеш = хэш ^ (хэш >> 16);\nхеш = (хэш ^ (хэш >> 8)) & 0xFF;\nrt_intern_hash() — net/ipv4/route.c (526)\nпомещает новый маршрут в таблицу маршрутизации")]),e._v(" "),_("h1",{attrs:{id:"глава-9"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-9"}},[e._v("#")]),e._v(" Глава 9")]),e._v(" "),_("p",[e._v("Динамическая маршрутизация с помощью "),_("em",[e._v("routed")])]),e._v(" "),_("p",[e._v("В этой главе представлена ​​динамическая маршрутизация, выполняемая маршрутизатором (в отличие от конечного хост-компьютера). В нем представлен обзор того, как "),_("em",[e._v("маршрутизируемая")]),e._v(" программа реализует протоколы маршрутизации в Linux, исследуется, как она изменяет таблицы маршрутизации ядра, и обобщается код реализации.")]),e._v(" "),_("h2",{attrs:{id:"_9-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-обзор"}},[e._v("#")]),e._v(" 9.1   Обзор")]),e._v(" "),_("p",[e._v('Обычный хост-компьютер имеет очень ограниченные возможности маршрутизации пакетов; сообщение либо для себя, либо для другого компьютера, а если оно для другого компьютера, то существует очень ограниченное количество вариантов его отправки. Обычно такому хосту достаточно отправить пакет в локальную сеть, чтобы "шлюзовый" компьютер (маршрутизатор) подхватил его и отправил дальше. Linux обычно не поддерживает никакой метрической информации (расстояния) о маршрутах, хотя в FIB есть переменные для ее хранения. Для простой маршрутизации к конечному хосту единственным важным вопросом является «смогу ли я добраться туда отсюда», а не «какой путь лучше?».')]),e._v(" "),_("p",[e._v("Однако маршрутизатор должен принимать решения о том, куда направлять трафик. Может быть несколько маршрутов к месту назначения, и маршрутизатор должен выбрать один (исходя из расстояния, измеряемого в переходах, или какой-либо другой метрики, такой как туманное качество обслуживания). Протокол маршрутной информации (RIP) — это простой протокол, который позволяет маршрутизирующим компьютерам отслеживать расстояние до различных пунктов назначения и обмениваться этой информацией между собой.")]),e._v(" "),_("p",[e._v("Используя RIP, каждый узел поддерживает таблицу, в которой содержится расстояние от него до других сетей и маршрут, по которому он будет отправлять пакеты в этот пункт назначения. Периодически маршрутизаторы обновляют друг друга; когда становятся очевидными более короткие маршруты, узел обновляет свою таблицу. Обновления — это просто сообщения RIP с адресом назначения и метрическими компонентами этой таблицы. На рисунке  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#d_rip",target:"_blank",rel:"noopener noreferrer"}},[e._v("9.1"),_("OutboundLink")],1),e._v(" показана схема таблицы маршрутизации RIP и пакета RIP.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/d_rip.gif",alt:"d_rip.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 9.1: Пакет и таблица протокола маршрутной информации.")]),e._v(" "),_("h2",{attrs:{id:"_9-2-как-работает-маршрутизация"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-как-работает-маршрутизация"}},[e._v("#")]),e._v(" 9.2   Как работает "),_("em",[e._v("маршрутизация")])]),e._v(" "),_("p",[_("em",[e._v("routed")]),e._v(" — это широко доступная программа для реализации RIP через сообщения UDP на компьютерах POSIX. По сути, это автономная программа, которая использует вызовы ioctl() для получения информации и обновления таблиц маршрутизации на хост-компьютере.")]),e._v(" "),_("h3",{attrs:{id:"_9-2-1-структуры-данных"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-1-структуры-данных"}},[e._v("#")]),e._v(" 9.2.1   Структуры данных")]),e._v(" "),_("p",[_("em",[e._v("routed")]),e._v(" поддерживает две идентичные таблицы данных — одну для хостов и одну для сетей. Каждая представляет собой хеш-таблицу с сегментами ROUTEHASHSIZ (32) цепочек записей маршрутизации. Записи содержат информацию RIP (но могут также совпадать со структурой rtentry , чтобы "),_("em",[e._v("routed")]),e._v(" мог передать их ядру через вызовы ioctl() ). Наряду с базовым пунктом назначения, маршрутизатором и метрикой в ​​записях хранятся флаги, состояние и информация о таймере.")]),e._v(" "),_("h3",{attrs:{id:"_9-2-2-инициализация"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-2-инициализация"}},[e._v("#")]),e._v(" 9.2.2   Инициализация")]),e._v(" "),_("p",[e._v("Когда начинается "),_("em",[e._v("маршрутизация")]),e._v(" , она выполняет различные действия по инициализации и вызывает ioctl() для получения информации об интерфейсе от ядра. Затем он отправляет сообщение RIP/UDP с запросом маршрутной информации от всех соседних маршрутизаторов. Наконец, он входит в бесконечный цикл, в котором он ждет трафика или таймеров, чтобы заставить его что-то сделать.")]),e._v(" "),_("h3",{attrs:{id:"_9-2-3-нормальная-работа"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-3-нормальная-работа"}},[e._v("#")]),e._v(" 9.2.3   Нормальная работа")]),e._v(" "),_("p",[e._v("Когда приходят сообщения RIP (через сокет UDP), "),_("em",[e._v("routed")]),e._v(" анализирует их и либо изменяет свою таблицу (для ответных сообщений), либо отправляет информацию обратно запрашивающему маршрутизатору (для запросов). Отправка информации — это просто поиск адресата в его собственной таблице, помещение этой информации в пакет RIP и отправка через сокет UDP. Обновление его таблицы может не иметь никакого значения (если изменений нет или изменение не имеет значения) или может привести к изменению маршрутизации. Если обновление показывает более короткий маршрут к месту назначения, "),_("em",[e._v("routed")]),e._v(" обновит свою собственную таблицу, а затем вызовет ioctl() для обновления таблиц маршрутизации ядра (FIB).")]),e._v(" "),_("p",[e._v("Когда таймер обновления истекает, каждые TIMER_RATE секунд "),_("em",[e._v("routed")]),e._v(" просматривает каждую запись в обеих таблицах и обновляет свои таймеры. Устаревшие записи устанавливаются на бесконечное расстояние ( HOPCNT_INFINITY ), а слишком старые записи удаляются (только из таблицы RIP, а не из FIB ядра). Наконец, он отправляет обновление на соседние маршрутизаторы. Это обновление содержит новую информацию таблицы (ответные сообщения) для всех записей, которые изменились с момента последнего обновления.")]),e._v(" "),_("p",[_("em",[e._v("routed")]),e._v(" оставляет фактическую маршрутизацию обычным механизмам маршрутизации ядра; все, что он делает, это обновляет таблицы ядра на основе информации от других маршрутизаторов и передает свою собственную маршрутную информацию. Обновления затем изменяют способ маршрутизации пакетов ядром, но "),_("em",[e._v("маршрутизация")]),e._v(" сама по себе не выполняет никакой маршрутизации.")]),e._v(" "),_("h2",{attrs:{id:"_9-3-функции-маршрутизации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-функции-маршрутизации"}},[e._v("#")]),e._v(" 9.3   Функции "),_("em",[e._v("маршрутизации")])]),e._v(" "),_("p",[e._v("Ниже приведен алфавитный список функций "),_("em",[e._v("маршрутизируемой")]),e._v(" программы, которые наиболее важны для маршрутизации, где они находятся в исходном коде и что они делают. Показанный каталог SOURCES представляет собой каталог, содержащий исходный код для данного сетевого файла "),_("em",[e._v(".")])]),e._v(" "),_("p",[e._v("Маршрутизируемый исходный код доступен в виде пакета, отдельного от исходного кода ядра (Red Hat Linux использует диспетчер пакетов "),_("em",[e._v("rpm")]),e._v(" "),_("em",[e._v(")")]),e._v(" . Приведенный ниже код взят из пакета исходного кода "),_("em",[e._v("netkit-routed-0.10 от")]),e._v(" 8 марта 1997 г. Этот пакет доступен на веб-странице "),_("em",[e._v("www.redhat.com/apps/download")]),e._v(" ; в частности, это пришло с "),_("em",[e._v("www.redhat.com/swt/src/netkit-routed-0.10.src.html")]),e._v(" . После загрузки "),_("em",[e._v("root")]),e._v(" может установить пакет с помощью следующих команд (начиная с каталога с пакетом):")]),e._v(" "),_("blockquote",[_("p",[e._v("rpm -i netkit-routed-0.10.src.rpm"),_("br"),e._v("\ncd /usr/src/redhat/SOURCES"),_("br"),e._v("\ntar xzf netkit-routed-0.10.tar.gz")])]),e._v(" "),_("p",[e._v("Это создает каталог "),_("em",[e._v("/usr/src/redhat/SOURCES/netkit-routed-0.10")]),e._v(" и заполняет его исходным кодом маршрутизируемой "),_("em",[e._v("программы")]),e._v(" . Этот процесс должен быть похожим (но, несомненно, не совсем таким же) для других дистрибутивов Linux.")]),e._v(" "),_("p",[e._v("ifinit() — ИСТОЧНИКИ/routed/startup.c (88)\nоткрывает сокет UDP\nвызывает ioctl(SIOCFIGCONF) для получения конфигурации интерфейса\nциклы через интерфейсы:\nвызывает ioctl() для получения флагов, широковещательного адреса, метрики и сетевой маски\nсоздает новую структуру интерфейса\nкопирует информацию в структуру интерфейса\nвызывает addrouteforif() для добавления записи маршрутизации для интерфейса\nустанавливает переменную поставщика, если необходимо\nзакрывает сокет\nprocess() - SOURCES/routed/main.c (298)\nзапускает непрерывный цикл:\nполучает пакет (ждет)\nпроверяет, что пакет имеет правильный размер\nвызывает rip_input() для обработки пакета (RIP)\nrip_input() - ИСТОЧНИКИ/routed/input.c (60)\nтрассирует ввод при необходимости\nпроверяет пакет, чтобы убедиться, что протокол и адрес поддерживаются\nпроверяет версию RIP (не может быть 0)\nпереключаться на основе содержимого пакета -\nесли пакет является запросом:\nпроверяет запрос на валидность\nесли запрос для всех записей, вызывает Supply()\nеще ищет запрошенный адрес, создает и отправляет ответный пакет\nвключена или выключена трассировка пакета:\nпроверяет, что запрос пришел с действительного порта\nесли все в порядке, включает или выключает трассировку\nесли пакет является ответом:\nпроверяет, что ответ пришел от маршрутизатора\nтаймер обновлений для интерфейса\nперебирает каждую запись в полученном пакете:\nанализирует информацию о маршруте\nпроверяет информацию о семействе адресов, хосте и метрике\nобновляет количество переходов (добавляет метрику в сообщении к счетчику переходов к маршрутизатору\nкоторые отправляют сообщение, с учетом максимума HOPCNT_INFINITY)\nвызывает rtlookup() для поиска адреса в таблице маршрутизации\nесли это кажется новым маршрутом:\nвызывает rtfind() для поиска эквивалентного маршрута\nесли он действительно новый, вызывает rtadd() и возвращает\nвызывает rtchange() для изменения маршрута при необходимости (новый маршрут или\nизменение количества прыжков)\nобновляет таймеры маршрута\nесли были изменения:\nотправляет обновление, если необходимо\nобновляет общую информацию о таймере обновления")]),e._v(" "),_("blockquote",[_("blockquote",[_("blockquote",[_("p",[e._v("routed main() - SOURCES/routed/main.c (78)\nоткрывает перенаправленный файл журнала\nвызывает getservbyname() для получения UDP-маршрутизатора\nустанавливает сокет UDP для трафика сообщений RIP\nзапускает аргументы командной строки для установки флагов\nесли не отлаживать, разветвляет и запускает программу в новом сеансе (родитель умирает)\nвызывает rtinit() для инициализации таблиц данных\nвызывает ifinit() для заполнения информации об интерфейсе\nвызывает toall() для запроса информации со всех других маршрутизаторов\nустанавливает обработчики сигналов для ALRM, HUP, TERM, INT, USR1 и USR2\nзапускает непрерывный цикл:\nесли необходимо обновление, устанавливает переменные таймера\nвызывает select() для ожидания трафика\nесли select() возвращает ошибку (кроме EINTR), регистрирует ее\nесли время ожидания select() истекло (время обновления)\nвызывает toall() для трансляции обновления\nсбрасывает переменные таймера\nесли на сокете есть ожидающий трафик, вызывает process()\nrtadd() - ИСТОЧНИКИ/routed/tables.c (138)\nпроверяет, что семейство адресов находится в правильном диапазоне\nвызывает семейную функцию af_rtflags() для установки флагов маршрутизации\nопределяет хеш-значение для соответствующей таблицы (хост или сеть)\nсоздает и заполняет новую структуру rt_entry\nвызывает insque() для добавления записи в таблицу\nвызывает rtioctl() для добавления записи в таблицу ядра\nесли вызов не удался:\nесли маршрут должен работать, вызывает семейство af_format() для добавления пункта назначения\nи шлюз к таблицам ядра\nесли хост недоступен, удаляет и освобождает запись\nrtchange() - ИСТОЧНИКИ/routed/tables.c (207)\nопределяет, требует ли изменение добавления или удаления шлюзов\nвызывает rtioctl() для добавления и/или удаления маршрутов\nrtfind() - ИСТОЧНИКИ/routed/tables.c (100)\nопределяет хеш-значение для таблицы хостов\nциклы через стол; возвращает запись, если адреса равны\nопределяет хеш-значение для чистой таблицы\nвозвращается к циклу по таблице, на этот раз возвращая запись, если вызов\nдля семейства функция af_netmatch() возвращает true\nвозвращает ноль (0), если совпадений нет\nrtinit() — ИСТОЧНИКИ/routed/tables.c (336)\nперебирает хэш-таблицу сети, устанавливая указатели вперед и назад\nперебирает хэш-таблицу хоста, устанавливая указатели вперед и назад\nrtioctl() — ИСТОЧНИКИ/routed/tables.c (346)\nзаполняет структуру rtentry из параметров\nвыводит действия трассировки при необходимости\nвызывает ioctl(SIOCADDRT или SIOCDELRT) для обновления таблицы ядра\nвозвращает результат вызова ioctl() (или -1 для ошибочного параметра)\nrtlookup() — ИСТОЧНИКИ/routed/tables.c (65)\nопределяет хеш-значение для адреса\nпросматривает таблицу хостов в поисках соответствия\nесли сначала неудачно, пытается снова с чистой таблицей\nвозвращает указатель на запись или ноль (0)\nsndmsg() — ИСТОЧНИКИ/routed/output.c (77)\nвызывает соответствующую выходную функцию семейства\nтрассирует пакет при необходимости\nSupply() - SOURCES/routed/ouput.c (91)\nсоздает ответное сообщение RIP\nзацикливается на таблице хостов маршрутизации\nперебирает записи маршрутизации\nпроверяет, нужна ли запись хосту маршрутизации\nесли это так, помещает информацию о маршрутизации в пакет и отправляет его\nвозвращается и делает это снова с таблицей сети маршрутизации\ntimer() — SOURCES/routed/timer.c (56)\nобновляет переменные таймера\nперебирает таблицу хостов\nобновляет информацию о таймере для каждой записи\nудаляет запись, если она слишком старая\nизменяет метрику на бесконечность, если она стареет\nвозвращается и делает это снова с чистой таблицей\nвызывает toall(), если требуется обновление\ntoall() - ИСТОЧНИКИ/routed/output.c (55)\nциклы через интерфейсы:\nустанавливает адрес назначения для широковещательного или определенного адреса\nвызывает переданную функцию [sndmsg() или Supply()] с адресом")])])])]),e._v(" "),_("h1",{attrs:{id:"глава-10"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-10"}},[e._v("#")]),e._v(" Глава 10.")]),e._v(" "),_("p",[e._v("Редактирование исходного кода Linux")]),e._v(" "),_("h2",{attrs:{id:"_10-1-дерево-исходного-кода-linux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-дерево-исходного-кода-linux"}},[e._v("#")]),e._v(" 10.1   Дерево исходного кода Linux")]),e._v(" "),_("p",[e._v("Исходный код Linux обычно находится в каталоге /usr/src (если он установлен). В разных деревьях каталогов может быть много версий (например, "),_("em",[e._v("linux-2.2.5")]),e._v(" или "),_("em",[e._v("linux-2.2.14")]),e._v(" ). Должна быть одна программная ссылка ( "),_("em",[e._v("linux")]),e._v(" ) на самую последнюю версию кода (например, "),_("em",[e._v("linux ® linux-2.2.14")]),e._v(" ).")]),e._v(" "),_("p",[e._v("Это обзор структуры исходных каталогов Linux (показаны не все ветки:")]),e._v(" "),_("p",[_("em",[e._v("/USR/SRC/линукс/")])]),e._v(" "),_("ul",[_("li",[_("p",[_("em",[e._v("arch")]),e._v(" - специфичный для архитектуры код, по процессору")]),e._v(" "),_("ul",[_("li",[_("p",[_("em",[e._v("i386")]),e._v(" — код для процессоров Intel (включая линейки 486 и Pentium)")]),e._v(" "),_("ul",[_("li",[_("em",[e._v("boot")]),e._v(" - расположение только что скомпилированных ядер")])])])])]),e._v(" "),_("li",[_("p",[_("em",[e._v("драйверы")]),e._v(" - код для драйверов всех видов")]),e._v(" "),_("ul",[_("li",[_("em",[e._v("block")]),e._v(" — блокировать драйверы устройств (например, жестких дисков)")]),e._v(" "),_("li",[_("em",[e._v("cdrom")]),e._v(" - драйверы устройств CD-ROM")]),e._v(" "),_("li",[_("em",[e._v("net")]),e._v(" — драйверы сетевых устройств")]),e._v(" "),_("li",[_("em",[e._v("pci")]),e._v(" - драйверы шины PCI")])])]),e._v(" "),_("li",[_("p",[_("em",[e._v("fs")]),e._v(" - код для разных файловых систем (EXT2, MS-DOS и т.д.)")])]),e._v(" "),_("li",[_("p",[_("em",[e._v("include")]),e._v(" — заголовочные файлы, используемые во всем коде")]),e._v(" "),_("ul",[_("li",[_("em",[e._v("asm ® asm-i386")]),e._v(" - заголовки, зависящие от процессора")]),e._v(" "),_("li",[_("em",[e._v("config")]),e._v(" — общие заголовки конфигурации")]),e._v(" "),_("li",[_("em",[e._v("linux")]),e._v(" — общие заголовки")]),e._v(" "),_("li",[_("em",[e._v("net")]),e._v(" — сетевые заголовки")])])]),e._v(" "),_("li",[_("p",[_("em",[e._v("ядро")]),e._v(" - код для конкретных подпрограмм ядра")])]),e._v(" "),_("li",[_("p",[_("em",[e._v("lib")]),e._v(" — код для ошибок, строк и printf")])]),e._v(" "),_("li",[_("p",[_("em",[e._v("mm")]),e._v(" - код управления памятью")])]),e._v(" "),_("li",[_("p",[_("em",[e._v("модули")]),e._v(" - объектные файлы и ссылки для загрузки ядра по мере необходимости")])]),e._v(" "),_("li",[_("p",[_("em",[e._v("net")]),e._v(" - код для сети")]),e._v(" "),_("ul",[_("li",[_("em",[e._v("ядро")]),e._v(" - независимый от протокола код")]),e._v(" "),_("li",[_("em",[e._v("ipv4")]),e._v(" — код, специфичный для IPv4")]),e._v(" "),_("li",[_("em",[e._v("package")]),e._v(" - независимый от протокола код пакета")]),e._v(" "),_("li",[_("em",[e._v("sched")]),e._v(" — код для планирования сетевых действий")])])])]),e._v(" "),_("h2",{attrs:{id:"_10-2-использование-тегов-emacs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-использование-тегов-emacs"}},[e._v("#")]),e._v(" 10.2   Использование тегов EMACS")]),e._v(" "),_("p",[e._v("Исходный код Linux, очевидно, очень большой и разбросан по многим файлам. Файл "),_("em",[e._v("TAGS")]),e._v(" позволяет быстро перейти к определенному файлу в поисках ссылки.")]),e._v(" "),_("h3",{attrs:{id:"_10-2-1-ссылки-с-помощью-tags"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-1-ссылки-с-помощью-tags"}},[e._v("#")]),e._v(" 10.2.1   Ссылки с помощью TAGS")]),e._v(" "),_("p",[e._v("Внутри файла переместите курсор на ключевое слово, которое вы хотите найти (например, "),_("code",[e._v("sock''). Нажмите")]),e._v("ESC'' "),_("code",[e._v(".'' - EMACS предложит найти тег (по умолчанию это слово, на котором находится курсор); нажмите")]),e._v("ENTER''. При первом использовании вам нужно будет указать, какой файл TAGS использовать (например, "),_("em",[e._v("/usr/src/TAGS")]),e._v(" ). Далее EMACS автоматически откроет соответствующий файл (например, "),_("em",[e._v("/usr/src/linux/include/linux/sock.h")]),e._v(" ) в новом буфере и поместит курсор на определение этой структуры, #define или функции. Если выводится не то определение, которое вы искали, нажмите "),_("code",[e._v("CTRL-U''")]),e._v("ESC'' ``.'', чтобы вызвать альтернативные ссылки.")]),e._v(" "),_("p",[e._v("Эти теги работают даже тогда, когда вы вносите изменения в исходные файлы, хотя они будут работать медленнее по мере того, как будет вноситься все больше и больше изменений. EMACS хранит теги в файле (по умолчанию "),_("em",[e._v("TAGS")]),e._v(" ) с каждой ссылкой, именем файла и номером строки. Если тег находится не на сохраненном номере строки, EMACS выполнит поиск в файле, чтобы найти новое местоположение.")]),e._v(" "),_("h3",{attrs:{id:"_10-2-2-создание-фаилов-tags"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-2-создание-фаилов-tags"}},[e._v("#")]),e._v(" 10.2.2   Создание файлов TAGS")]),e._v(" "),_("p",[e._v("Если вам нужно начать с нуля, выполните следующие действия.")]),e._v(" "),_("p",[e._v("Команда для создания файла тегов:")]),e._v(" "),_("blockquote",[_("p",[e._v("etags "),_("em",[e._v("имя файла")])])]),e._v(" "),_("p",[e._v("Команда для добавления новой информации в файл тегов:")]),e._v(" "),_("blockquote",[_("p",[e._v("etags - "),_("em",[e._v("имя файла")])])]),e._v(" "),_("p",[e._v("Они помещают новые теги в файл "),_("em",[e._v("TAGS")]),e._v(" в текущем каталоге. Имена файлов сохраняются как заданные, поэтому абсолютные ссылки всегда будут относиться к одним и тем же файлам, а относительные ссылки зависят от положения файла "),_("em",[e._v("TAGS")]),e._v(" . (Прочитайте справочную страницу для "),_("em",[e._v("etags")]),e._v(" для получения дополнительной информации).")]),e._v(" "),_("p",[e._v("Например, чтобы создать файл тегов для исходных файлов "),_("em",[e._v("ipv4")]),e._v(" , введите:")]),e._v(" "),_("blockquote",[_("p",[e._v("etags /usr/src/linux/net/ipv4/*.c")])]),e._v(" "),_("p",[e._v("Чтобы добавить заголовочные файлы, введите:")]),e._v(" "),_("blockquote",[_("p",[e._v("etags -a /usr/src/include/net/*.h")])]),e._v(" "),_("p",[e._v("Файл "),_("em",[e._v("TAGS")]),e._v(" теперь будет содержать краткие ссылки на весь исходный код C и информацию заголовков в этих каталогах.")]),e._v(" "),_("h2",{attrs:{id:"_10-3-использование-тегов-vi"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-использование-тегов-vi"}},[e._v("#")]),e._v(" 10.3   Использование тегов vi")]),e._v(" "),_("p",[e._v("Редактор vi также поддерживает использование файлов тегов (и создает их с помощью команды "),_("em",[e._v("gctags")]),e._v(" , которая работает почти так же, как показанная выше команда "),_("em",[e._v("etags")]),e._v(" ).")]),e._v(" "),_("h2",{attrs:{id:"_10-4-пересборка-ядра"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-пересборка-ядра"}},[e._v("#")]),e._v(" 10.4   Пересборка ядра")]),e._v(" "),_("p",[e._v("(Более подробные инструкции см. в Linux-kernel-HOWTO.)")]),e._v(" "),_("p",[e._v("Это краткое пошаговое руководство по перекомпиляции и установке ядра с нуля.")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("Перейдите в начало исходного каталога ( "),_("em",[e._v("/usr/src/linux")]),e._v(" ). Если еще нет исторической копии рабочего файла "),_("em",[e._v(".config")]),e._v(" (например, текущей), СДЕЛАЙТЕ ОДНУ. Пока у вас не будет достаточно опыта, чтобы вам больше не нужно было это руководство, ничего не перезаписывайте, пока не убедитесь, что есть копия, к которой вы можете вернуться. (С другой стороны, если у вас есть стабильная версия ядра, нет причин хранить старые версии. Даже система разработки, вероятно, должна иметь только исходную рабочую версию, последнюю известную стабильную версию и текущую версию.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make xconfig ( make config и make menuconfig также работают, но xconfig намного удобнее для пользователя). Настроить систему по желанию; есть помощь, доступная для большинства опций. Файл конфигурации должен по умолчанию использовать текущие настройки, поэтому вам нужно будет изменить только то, что вы хотите добавить или удалить. Как правило, выберите «Y» для важных или часто используемых функций (таких как файловая система ext2), «M» для вещей, которые иногда бывают полезны (например, звуковые драйверы), и «N» для вещей. которые не применяются (например, поддержка радиолюбителей). Если вы сомневаетесь, обратитесь к тексту справки или включите что-нибудь в качестве модуля.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make dep , чтобы убедиться, что выбранные вами параметры будут правильно скомпилированы. Это займет несколько минут, так как компьютер проверит все зависимости. Если все пойдет хорошо, программа make просто завершит работу; если есть проблема, он будет отображать сообщения об ошибках и останавливаться.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make clean , чтобы удалить старые объектные файлы, ЕСЛИ вы хотите все перекомпилировать. Это, очевидно, сделает процесс компиляции более длительным.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make bzImage , чтобы собрать новое ядро. ( make zImage и make boot также собирают образы ядра, но bzImage скомпилируется в наиболее компактный файл. Если по какой-то причине вы используете один из этих двух методов, вы можете получить ошибку «ядро слишком большое» при запуске "),_("em",[e._v("lilo")]),e._v(" - попробуйте еще раз с bzImage .) Это займет довольно много времени, в зависимости от доступной памяти.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make modules , чтобы собрать любые модули (не включенные в основной образ ядра).")])]),e._v(" "),_("li",[_("p",[e._v("При необходимости переименуйте старые модули:")]),e._v(" "),_("blockquote",[_("p",[e._v("mv /lib/modules/2.2.xx /lib/modules/2.2.xx-старый")])]),e._v(" "),_("p",[e._v("(Обратите внимание, что вам не нужно будет делать это, если вы компилируете совершенно новую версию; старые будут по-прежнему находиться в "),_("em",[e._v("/lib/modules/2.2.xx")]),e._v(" при сборке версии 2.2. "),_("em",[e._v("yy")]),e._v(" .)")])]),e._v(" "),_("li",[_("p",[e._v("Запустите make modules_install , чтобы установить новые модули. Вы должны сделать это, даже если вы собрали монолитное ядро ​​(без модулей). (Обратите внимание, что в загрузочном каталоге может быть текстовый файл "),_("em",[e._v("с информацией о модуле Red Hat или ссылка; это не очень важно, и это не обновляет его.)")])])]),e._v(" "),_("li",[_("p",[e._v("Скопируйте новое ядро ​​в каталог "),_("em",[e._v("/boot")]),e._v(" и измените ссылку на ядро ​​(обычно "),_("em",[e._v("это vmlinuz")]),e._v(" ):")]),e._v(" "),_("blockquote",[_("p",[e._v("cp arch/i386/boot/bzImage /boot/vmlinuz-2.2.xx"),_("br"),e._v("\nln -sf /boot/vmlinuz-2.2.xx /boot/vmlinuz")])])]),e._v(" "),_("li",[_("p",[e._v("Скопируйте новый файл "),_("em",[e._v("System.map")]),e._v(" в каталог "),_("em",[e._v("/boot")]),e._v(" и измените ссылку на карту:")])])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("> cp System.map /boot/System.map-2.2.xx  \n> ln -sf /boot/System.map-2.2.xx /boot/System.map\n")])])]),_("ol",{attrs:{start:"11"}},[_("li",[e._v("Создайте новый файл "),_("em",[e._v("initrd")]),e._v(" , если на компьютере есть устройства SCSI:")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("> /sbin/mkinitrd /boot/initrd-2.2.xx.img 2.2.xx\n")])])]),_("ol",{attrs:{start:"12"}},[_("li",[_("p",[e._v("Отредактируйте файл "),_("em",[e._v("/etc/lilo.conf")]),e._v(" , чтобы установить новое ядро; скопируйте блок для старого ядра ( image=vmlinuz ) и измените существующий, чтобы оставить его как вариант. Например, переименуйте образ в vmlinuz-2.2.xx-old и измените метку на стабильную . Таким образом, вы всегда сможете перезагрузиться на текущее (предположительно стабильное) ядро, если ваши изменения вызовут проблемы.")])]),e._v(" "),_("li",[_("p",[e._v("Запустите /sbin/lilo , чтобы установить новое ядро ​​в качестве опции загрузки.")])]),e._v(" "),_("li",[_("p",[e._v("Перезагрузите компьютер с новым ядром.")])]),e._v(" "),_("li",[_("p",[e._v("Если новое ядро ​​не работает должным образом, загрузите старое ядро ​​и перенастройте систему перед повторной попыткой.")])])]),e._v(" "),_("h2",{attrs:{id:"_10-5-исправление-исходного-кода-ядра"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-5-исправление-исходного-кода-ядра"}},[e._v("#")]),e._v(" 10.5   Исправление исходного кода ядра")]),e._v(" "),_("p",[e._v("Linux — это постоянно меняющаяся операционная система; обновления могут быть выпущены каждые несколько месяцев. Есть два способа установить новую версию ядра: загрузить новый исходный код целиком или загрузить патчи и применить их.")]),e._v(" "),_("p",[e._v("Загрузка всего исходного кода может быть предпочтительнее, чтобы гарантировать, что все работает правильно. Для этого загрузите последний исходный код ядра и установите его ( "),_("em",[e._v("untar")]),e._v(" ). Обратите внимание, что это будет (вероятно) полный дистрибутив, а не специфичный для машины, и будет содержать много дополнительного кода. Большая часть этого может быть удалена, но конфигурационные файлы Makefile полагаются на некоторую информацию. Если вам не хватает места, удалите файлы "),_("em",[e._v("*.c")]),e._v(" и "),_("em",[e._v("*.h в каталогах")]),e._v(" "),_("em",[e._v("arch/,")]),e._v(" отличных от i386, и "),_("em",[e._v("include/asm-*")]),e._v(" , но действуйте осторожно.")]),e._v(" "),_("p",[e._v("Загрузка патчей может быть быстрее, но несколько сложнее. Из-за вариаций дистрибутива, внесенных вами изменений или других модификаций патчи могут работать некорректно. Вы должны применять файлы исправлений по порядку (чтобы перейти с 2.2.12 на 2.2.14, сначала примените исправление 2.2.13, а затем 2.2.14). Тем не менее, исправления могут быть предпочтительнее, поскольку они работают с существующим деревом каталогов.")]),e._v(" "),_("p",[e._v("После того, как вы загрузили патч (и разархивировали его, если необходимо), просто поместите его в каталог выше "),_("em",[e._v("linux")]),e._v(" (например, "),_("em",[e._v("/usr/src/")]),e._v(" ) и запустите программу патча, чтобы установить его:")]),e._v(" "),_("blockquote",[_("p",[e._v("patch -Np0 -verbose -r rejfile < patch-2.2.xx "),_("em",[e._v("(где xx — версия патча)")])])]),e._v(" "),_("p",[e._v("Опция -N игнорирует уже примененные патчи, а -p0 предполагает, что патч хочет применить себя к источнику в каталоге "),_("em",[e._v("linux")]),e._v(" . Параметр -r rejfile помещает все отклоненные патчи в один файл ( "),_("em",[e._v("rejfile")]),e._v(" ) - это может быть или не быть тем, что вы хотите сделать. Если вы не сохранили весь исходный дистрибутив, вам придется пропустить многие изменения (для различных процессорных архитектур), просто нажав ENTER в ответ на приглашения "),_("code",[e._v("исправить какой файл'' и")]),e._v("игнорировать исправление''. Как только вы освоитесь с процессом, запустите его без параметров -verbose и -r rejfile .")]),e._v(" "),_("p",[e._v("Получив новую версию ядра, следуйте инструкциям по пересборке ядра, чтобы начать его использовать. Возможно, вам не придется изменять какие-либо параметры конфигурации, но вы почти наверняка захотите запустить команду make clean , чтобы удалить все старые объектные файлы.")]),e._v(" "),_("h1",{attrs:{id:"глава-11"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-11"}},[e._v("#")]),e._v(" Глава 11.")]),e._v(" "),_("p",[e._v("Модули Linux")]),e._v(" "),_("p",[e._v("В этой главе представлена ​​модульная система Linux. В нем содержится обзор того, как работают модули, описывается, как их устанавливать и удалять, а также представлен пример программы.")]),e._v(" "),_("h2",{attrs:{id:"_11-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-обзор"}},[e._v("#")]),e._v(" 11.1   Обзор")]),e._v(" "),_("p",[e._v("Ядра Linux более поздние, чем 2.0, могут быть (и обычно) модульными. Часть ядра постоянно остается в памяти (наиболее часто используемые процессы, такие как планировщик), но другие процессы загружаются только при необходимости. Например, файловая система MS-DOS для чтения дисков может быть загружена только при монтировании такого диска, а затем выгружена, когда она больше не нужна. Это сохраняет пространство, требуемое ядру в любой момент времени, небольшим, позволяя ему делать все больше и больше. Еще можно поместить все в одно ``монолитное'' ядро, которое не будет нуждаться в модулях, но это обычно делается только для машин специального назначения (где все необходимые процессы известны заранее).")]),e._v(" "),_("p",[e._v("Еще одним преимуществом модулей является то, что ядро ​​может загружать и выгружать их динамически (и автоматически с помощью демона "),_("em",[e._v("kerneld")]),e._v(" ). Это означает, что (привилегированный) пользователь может загружать модуль, тестировать его, выгружать и многократно отлаживать без перезагрузки компьютера. В этом документе предполагается, что у пользователя есть права суперпользователя (вы должны быть root для установки и удаления модулей) и ядро ​​сконфигурировано для модулей. (С монолитным ядром можно установить параметры конфигурации, чтобы не разрешать даже модули.)")]),e._v(" "),_("h2",{attrs:{id:"_11-2-запись-установка-и-удаление-модулеи"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-запись-установка-и-удаление-модулеи"}},[e._v("#")]),e._v(" 11.2   Запись, установка и удаление модулей")]),e._v(" "),_("h3",{attrs:{id:"_11-2-1-написание-модулеи"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-1-написание-модулеи"}},[e._v("#")]),e._v(" 11.2.1   Написание модулей")]),e._v(" "),_("p",[e._v("Модули такие же, как и любые другие программы, за исключением того, что они работают в пространстве ядра. Таким образом, они должны определять MODULE и включать "),_("em",[e._v("module.h")]),e._v(" и любые другие заголовочные файлы ядра, которые определяют используемые ими функции или переменные. Модули могут быть очень простыми (как показано в примере), но могут быть и довольно сложными, например, драйверы устройств и целые файловые системы.")]),e._v(" "),_("p",[e._v("Это общий формат модуля:")]),e._v(" "),_("p",[e._v("#define МОДУЛЬ\n#include <linux/module.h>\n/* ... другие необходимые заголовочные файлы ... "),_("em",[e._v("/\n/")])]),e._v(" "),_("ul",[_("li",[e._v("... объявления модулей и функции ...\n"),_("em",[e._v("/\ninit_module() {\n/")]),e._v(" код, который ядро ​​будет вызывать при установке модуля "),_("em",[e._v("/\n}\nнедействительным cleanup_module () {\n/")]),e._v(" код, который ядро ​​будет вызывать при удалении модуля */\n}")])]),e._v(" "),_("p",[e._v("Модули, использующие исходный код ядра, должны быть скомпилированы с помощью "),_("em",[e._v("gcc")]),e._v(" с параметром -I/usr/src/linux/include ; это гарантирует, что включенные файлы будут из правильного исходного дерева.")]),e._v(" "),_("p",[e._v("Обратите внимание, что не все переменные ядра экспортируются для использования модулями, даже если код объявляет их как extern . Файл "),_("em",[e._v("/proc/ksyms")]),e._v(" или программа "),_("em",[e._v("ksyms")]),e._v(" отображают экспортированные символы (не многие из них полезны для работы в сети). Последние ядра Linux экспортируют как символ, так и номер его версии, используя макрос EXPORT_SYMBOL(x) . Для переменных, созданных пользователем, используйте макрос EXPORT_SYMBOL_NOVERS(x), иначе компоновщик не сохранит переменную в таблице символов ядра. Авторы модулей также могут использовать макрос EXPORT_NO_SYMBOLS ; модули экспортируют все свои переменные по умолчанию.")]),e._v(" "),_("h3",{attrs:{id:"_11-2-2-установка-и-удаление-модулеи"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-2-установка-и-удаление-модулеи"}},[e._v("#")]),e._v(" 11.2.2   Установка и удаление модулей")]),e._v(" "),_("p",[e._v("Установка и удаление модулей так же проста, как вызов программы с именем скомпилированного модуля. (Вы должны быть суперпользователем, чтобы установить или удалить модуль.)")]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("insmod")]),e._v(" устанавливает модуль; сначала он связывает модуль с экспортированной таблицей символов ядра для разрешения ссылок, а затем устанавливает код в пространстве ядра.")]),e._v(" "),_("blockquote",[_("p",[e._v("/sbin/insmod "),_("em",[e._v("имя_модуля")])])]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("rmmod")]),e._v(" удаляет установленный модуль и все экспортированные им ссылки.")]),e._v(" "),_("blockquote",[_("p",[e._v("/sbin/rmmod "),_("em",[e._v("имя_модуля")])])]),e._v(" "),_("p",[e._v("Программа "),_("em",[e._v("lsmod")]),e._v(" перечисляет все установленные на данный момент модули:")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("/sbin/lsmod\nРазмер модуля, используемый\ncdrom 13368 0 (автоочистка) [ide-cd]\n3c59x 19112 1 (автоочистка)\n")])])]),_("h2",{attrs:{id:"_11-3-пример"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-3-пример"}},[e._v("#")]),e._v(" 11.3   Пример")]),e._v(" "),_("p",[e._v("Это полный пример очень простого модуля.")]),e._v(" "),_("p",[_("em",[e._v("простой_модуль.c")])]),e._v(" "),_("p",[e._v("/* simple_module.c\n*")]),e._v(" "),_("ul",[_("li",[e._v("Эта программа представляет собой пример того, как установить тривиальный модуль")]),e._v(" "),_("li",[e._v("в ядро ​​Linux. Все, что делает модуль, это помещает сообщение в")]),e._v(" "),_("li",[e._v("файл журнала при его установке и удалении.")]),e._v(" "),_("li")]),e._v(" "),_("p",[_("em",[e._v("/\n#define МОДУЛЬ\n#include <linux/module.h>\n/")]),e._v(" kernel.h содержит функцию printk "),_("em",[e._v("/\n#include <linux/kernel.h>\n/")]),e._v("******************************************************** *************** init_module")]),e._v(" "),_("ul",[_("li",[e._v("ядро ​​вызывает эту функцию при загрузке модуля "),_("em",[e._v('/\ninit_module() {\nprintk("<1>Простой модуль установился правильно.\\n");\nвернуть 0;\n} /')]),e._v(" init_module "),_("em",[e._v("/\n/")]),e._v("******************************************************** *********** cleanup_module")]),e._v(" "),_("li",[e._v("ядро ​​вызывает эту функцию при удалении модуля "),_("em",[e._v('/\nнедействительным cleanup_module () {\nprintk("<1>Простой модуль удален.\\n");\n} /')]),e._v(" модуль очистки */")])]),e._v(" "),_("p",[e._v("Это "),_("em",[e._v("Makefile")]),e._v(" :")]),e._v(" "),_("h1",{attrs:{id:"makefile-для-простого-модуля"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#makefile-для-простого-модуля"}},[e._v("#")]),e._v(" Makefile для простого_модуля")]),e._v(" "),_("p",[e._v("CC = gcc -I/usr/src/linux/include/config\nCFLAGS = -O2 -D__KERNEL__ -Стена\nпростой_модуль.о: простой_модуль.с\nустановить:\n/sbin/insmod простой_модуль\nудалять:\n/sbin/rmmod простой_модуль")]),e._v(" "),_("p",[e._v("Для использования (должен быть root ):")]),e._v(" "),_("p",[e._v("корень # сделать\nкорень # сделать установку\nкорень # сделать удалить\nroot# хвост /var/log/messages\n... ядро: простой модуль установился правильно.\n... ядро: теперь простой модуль удален.")]),e._v(" "),_("h1",{attrs:{id:"глава-12"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-12"}},[e._v("#")]),e._v(" Глава 12.")]),e._v(" "),_("p",[e._v("Файловая система "),_("em",[e._v("proc")])]),e._v(" "),_("p",[e._v("В этой главе представлена ​​виртуальная файловая система "),_("em",[e._v("proc")]),e._v(" . Он дает обзор того, как работает файловая система, показывает, как существующий сетевой код использует систему, и подробно описывает, как писать и использовать записи "),_("em",[e._v("proc")]),e._v(" из программ.")]),e._v(" "),_("h2",{attrs:{id:"_12-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-обзор"}},[e._v("#")]),e._v(" 12.1   Обзор")]),e._v(" "),_("p",[e._v("Файловая система "),_("em",[e._v("proc")]),e._v(" названа так потому, что находится в каталоге "),_("em",[e._v("/proc")]),e._v(" на большинстве машин Linux. НЕ включение "),_("em",[e._v("proc")]),e._v(" FS является опцией конфигурации, но система является мощным инструментом, который часто используется многими программами. Хотя она разработана как файловая система со структурой каталогов и индексными дескрипторами, на самом деле она представляет собой конструкцию зарегистрированных функций, предоставляющих информацию о важных переменных.")]),e._v(" "),_("p",[e._v("В каталоге "),_("em",[e._v("proc")]),e._v(" есть много подкаталогов — по одному для каждого запущенного процесса и другие для подсистем, таких как файловые системы, интерфейсы, терминалы и сеть ( "),_("em",[e._v("/proc/net")]),e._v(" ). "),_("em",[e._v("В самом основном каталоге /proc")]),e._v(" также есть много файлов - "),_("em",[e._v("прерывания")]),e._v(" , "),_("em",[e._v("ioports")]),e._v(" , "),_("em",[e._v("loadavg")]),e._v(" и "),_("em",[e._v("версия")]),e._v(" , и это лишь некоторые из них. В каждом подкаталоге процесса (названном по номеру процесса) находятся файлы, описывающие командную строку процесса, текущий рабочий каталог, статус и т. д.")]),e._v(" "),_("p",[e._v("Ядро перехватывает доступ к "),_("em",[e._v("proc-")]),e._v(" файлам и вместо выполнения «обычных» файловых операций над ними вызывает специальные (индивидуально зарегистрированные) функции. Когда файл в каталоге "),_("em",[e._v("/proc")]),e._v(' "создается", он регистрируется с помощью набора функций, которые сообщают ядру, что делать, когда файл читается или записывается. Большинство записей позволяют только чтение, и они просто выводят состояние определенных системных переменных для использования другими программами или для прочтения знающими пользователями.')]),e._v(" "),_("p",[e._v("Единственная сложность в использовании "),_("em",[e._v("proc-")]),e._v(" файлов заключается в том, что ядро ​​вызывает функцию генерации информации каждый раз при чтении файла; последующие чтения изменяющегося файла без копирования и буферизации результатов могут привести к совершенно другим результатам. Лучший способ использовать файл "),_("em",[e._v("proc")]),e._v(" — прочитать его в буфер PAGE_SIZE -byte. Это приведет к чтению всей записи сразу, и тогда буфер разрешит согласованный произвольный доступ.")]),e._v(" "),_("h2",{attrs:{id:"_12-2-фаилы-сетевых-процессов"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-фаилы-сетевых-процессов"}},[e._v("#")]),e._v(" 12.2 Файлы   сетевых "),_("em",[e._v("процессов")])]),e._v(" "),_("p",[e._v("Это список самых важных файлов в каталоге "),_("em",[e._v("/proc/net/")]),e._v(" , что они содержат, а также ссылка на функцию и файл, которые их создают. Обратите внимание, что есть много других интересных записей "),_("em",[e._v("proc")]),e._v(" , таких как файлы "),_("em",[e._v("/proc/sys")]),e._v(" , "),_("em",[e._v("/proc/ksyms")]),e._v(" и "),_("em",[e._v("/proc/modules,")]),e._v(" и это лишь некоторые из них.")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("арп")])])]),e._v(" "),_("p",[e._v("отображает таблицу соседей ( arp_tbl ); IP- и аппаратные адреса, тип оборудования, устройство и флаги. ( arp_get_info() : "),_("em",[e._v("сеть/ipv4/arp.c")]),e._v(" 988)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("разработчик")])])]),e._v(" "),_("p",[e._v("отображает статистику приема и передачи для каждого зарегистрированного интерфейса")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("dev_stat")])])]),e._v(" "),_("p",[e._v("отображает количество отброшенных полученных пакетов и статистику дросселирования и FASTROUTE ( dev_proc_stats() : "),_("em",[e._v("net/core/dev.c")]),e._v(" 1228)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("нетстат")])])]),e._v(" "),_("p",[e._v("отображает куки синхронизации, обрезку и статистику ICMP ( netstat_get_info() : "),_("em",[e._v("net/ipv4/proc.c")]),e._v(" 355)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("сырой")])])]),e._v(" "),_("p",[e._v("отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета RAW из структуры proto raw_prot ( get__netinfo() : "),_("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("маршрут")])])]),e._v(" "),_("p",[e._v("отображает таблицу FIB ( main_table ); интерфейс, адрес, шлюз, флаги и информацию об использовании. ( fib_get_procinfo() ): "),_("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(" 109)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("rt_cache")])])]),e._v(" "),_("p",[e._v("отображает кеш маршрутизации ( rt_hash_table ); интерфейс, адрес, шлюз, использование, источник и другую информацию. ( rt_cache_get_info() : "),_("em",[e._v("net/ipv4/route.c")]),e._v(" 191)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("носокстат")])])]),e._v(" "),_("p",[e._v("отображает количество использованных сокетов и некоторую статистику о количестве TCP, UDP и RAW ( afinet_get_info() : "),_("em",[e._v("net/ipv4/proc.c")]),e._v(" 244)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("TCP")])])]),e._v(" "),_("p",[e._v("отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета TCP из структуры proto tcp_prot ( get__netinfo() : "),_("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),_("p",[_("strong",[_("em",[e._v("UDP")])])]),e._v(" "),_("p",[e._v("отображает информацию об адресе, очереди и времени ожидания для каждого открытого сокета UDP из структуры proto udp_prot ( get__netinfo() : "),_("em",[e._v("net/ipv4/proc.c")]),e._v(" 165)")]),e._v(" "),_("h2",{attrs:{id:"_12-3-регистрация-фаилов-proc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-регистрация-фаилов-proc"}},[e._v("#")]),e._v(" 12.3   Регистрация файлов "),_("em",[e._v("proc")])]),e._v(" "),_("p",[e._v("В этом разделе описывается простейший метод регистрации записи ``файла'' процесса только для чтения "),_("em",[e._v("(")]),e._v(" доступен только в Linux 2.0 и более поздних версиях). Можно создать более полнофункциональную запись, определив структуры file_operations и inode_operations . Однако этот метод значительно сложнее, чем представленный здесь; посмотрите в исходном коде подробности о реализации полнофункциональной записи. Описанный ниже метод — определение функции, а затем ее регистрация и отмена регистрации — обеспечивает большую часть функций, необходимых для тестирования и отслеживания системных ресурсов. Только ядро ​​может зарегистрировать файл "),_("em",[e._v("proc")]),e._v(" ; пользователи могут сделать это, создав и установив модули ядра (хотя только rootможет устанавливать и удалять модули). Эти процедуры предполагают, что исходный код Linux установлен, а ядро ​​скомпилировано для использования модулей.")]),e._v(" "),_("h3",{attrs:{id:"_12-3-1-форматирование-функции-для-предоставления-информации"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-1-форматирование-функции-для-предоставления-информации"}},[e._v("#")]),e._v(" 12.3.1   Форматирование функции для предоставления информации")]),e._v(" "),_("p",[e._v("static int "),_("em",[e._v("read_proc_function")]),e._v(" (char *buf, char ** start, off_t offset, int len, int не используется)")]),e._v(" "),_("p",[e._v("Это функция, которую ядро ​​Linux будет вызывать всякий раз, когда оно попытается прочитать из только что созданного ``файла'' "),_("em",[e._v("proc")]),e._v(" . Единственным важным параметром обычно является buf — указатель на буфер, который ядро ​​делает доступным для хранения информации. Остальные обычно не меняются. ( "),_("em",[e._v("read_proc_function")]),e._v(" — это, конечно же, имя новой функции.)")]),e._v(" "),_("p",[e._v("Обычно эта функция выводит заголовок, перебирает список или таблицу, выводя ее содержимое (используя обычную процедуру sprintf ), и возвращает длину результирующей строки. Единственным ограничением является то, что размер буфера ( buf ) не должен превышать PAGE_SIZE байт (это не менее 4 КБ).")]),e._v(" "),_("p",[e._v("В качестве примера такой функции посмотрите на функцию fib_get_procinfo() , начинающуюся со строки 109 файла "),_("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(" . Эта функция отображает содержимое основной таблицы FIB.")]),e._v(" "),_("h3",{attrs:{id:"_12-3-2-создание-записи-процесса"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-2-создание-записи-процесса"}},[e._v("#")]),e._v(" 12.3.2   Создание записи "),_("em",[e._v("процесса")])]),e._v(" "),_("p",[e._v("Поскольку это часть файловой системы, записи нужен индексный дескриптор. Это легко построить с помощью структуры proc_dir_entry :")]),e._v(" "),_("p",[e._v('#include <linux/proc_fs.h>\nструктура proc_dir_entry new_proc_entry = {\n0, // low_ino - номер инода (0 для динамического)\n5, // namelen - длина имени записи\n"вход", // имя\nС_ИФРЕГ | S_IRUGO, // режим\n1, // nсвязей\n0, // uid - владелец\n0, // гид - группа\n0, // размер - не используется\nNULL, // ops — операции с инодом (используйте по умолчанию)\n&read_proc_function // read_proc - адрес функции чтения\n// оставить пустым!\n}')]),e._v(" "),_("p",[e._v("Содержимое этого блока можно использовать, как показано, просто заменив поля namelen , name и read_proc_function на нужные значения. Обратите внимание, что многие записи, определенные ядром, имеют предопределенные номера инодов (например, PROC_NET_ROUTE , часть перечисления, определенного в "),_("em",[e._v("include/linux/proc_fs.h")]),e._v(" .")]),e._v(" "),_("p",[e._v("В качестве примера записи такого типа посмотрите на функцию __init_func() , начинающуюся со строки 607 файла "),_("em",[e._v("net/ipv4/fib_frontend.c")]),e._v(" . Эта функция вызывает proc_net_register() (описанную ниже) с вновь созданной структурой proc_dir_entry .")]),e._v(" "),_("h3",{attrs:{id:"_12-3-3-регистрация-записи-о-процедуре"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-3-регистрация-записи-о-процедуре"}},[e._v("#")]),e._v(" 12.3.3   Регистрация записи "),_("em",[e._v("о процедуре")])]),e._v(" "),_("p",[e._v("Как только функция чтения и запись inode готовы, остается только зарегистрировать новый ``файл'' в системе "),_("em",[e._v("proc")]),e._v(" .")]),e._v(" "),_("p",[e._v("int proc_register(struct proc_dir_entry *dir, struct proc_dir_entry *entry)"),_("br"),e._v("\nint proc_net_register(struct proc_dir_entry *entry)")]),e._v(" "),_("p",[e._v("dir — это указатель на каталог, которому принадлежит запись — &proc_root и proc_net (определенные в "),_("em",[e._v("include/proc_fs.h")]),e._v(" ), вероятно, наиболее полезны. entry — это указатель на саму запись, созданную выше. Эти две функции идентичны, за исключением того, что proc_net_register автоматически использует каталог "),_("em",[e._v("/proc/net")]),e._v(" . Они возвращают либо 0 (успех), либо EAGAIN (если нет доступных инодов).")]),e._v(" "),_("h3",{attrs:{id:"_12-3-4-отмена-регистрации-записи-процесса"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-4-отмена-регистрации-записи-процесса"}},[e._v("#")]),e._v(" 12.3.4   Отмена регистрации записи "),_("em",[e._v("процесса")])]),e._v(" "),_("p",[e._v("Когда запись больше не нужна, ее следует удалить, отменив ее регистрацию.")]),e._v(" "),_("p",[e._v("int proc_unregister(struct proc_dir_entry *dir,int inode)"),_("br"),e._v("\nint proc_net_unregister(int inode)")]),e._v(" "),_("p",[e._v("dir — это каталог "),_("em",[e._v("proc")]),e._v(" , в котором находится файл, а inode — номер инода файла. (Инод доступен в поле struct proc_dir_entry.low_ino записи , если он не является константой.) Опять же, эти функции идентичны, за исключением того, что proc_net_unregister автоматически использует каталог "),_("em",[e._v("/proc/net")]),e._v(" . Они возвращают либо 0 (успех), либо EINVAL (если такой записи нет).")]),e._v(" "),_("h2",{attrs:{id:"_12-4-пример"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-пример"}},[e._v("#")]),e._v(" 12.4   Пример")]),e._v(" "),_("p",[e._v("Это полный пример модуля, который устанавливает простую запись "),_("em",[e._v("proc")]),e._v(" .")]),e._v(" "),_("p",[_("em",[e._v("simple_entry.c")])]),e._v(" "),_("p",[e._v("/* simple_entry.c\n*")]),e._v(" "),_("ul",[_("li",[e._v("Эта программа дает пример того, как установить запись в")]),e._v(" "),_("li",[e._v("Файловая система /proc. Все, что делает эта запись, это отображает некоторые статистические данные.")]),e._v(" "),_("li",[e._v("информация об ИП.\n"),_("em",[e._v("/\n#define МОДУЛЬ\n#include <linux/module.h>\n/")]),e._v(" proc_fs.h содержит proc_dir_entry и регистрацию/отмену регистрации прототипов "),_("em",[e._v("/\n#include <linux/proc_fs.h>\n/")]),e._v(" ip.h содержит переменную ip_statistics "),_("em",[e._v("/\n#include <net/ip.h>\n/")]),e._v("******************************************************** *********** show_ip_stats")]),e._v(" "),_("li",[e._v("эта функция вызывается файловой системой /proc, когда что-либо пытается прочитать")]),e._v(" "),_("li",[e._v("из файла /proc/simple_entry — он помещает часть ядра в глобальные")]),e._v(" "),_("li",[e._v("содержимое переменной ip_statistics в буфер возврата "),_("em",[e._v("/\nint show_ip_stats (char "),_("em",[e._v('buf, char ** start, off_t offset, int len, int unused) {\nlen = sprintf(buf,"Некоторые IP-статистики:\\nIP-переадресация");\nесли (ip_statistics.IpForwarding)\nlen += sprintf(buf+len,"on\\n");\nеще\nlen += sprintf(buf+len,"off\\n");\nlen += sprintf(buf+len,"TTL по умолчанию: %lu\\n",ip_statistics.IpDefaultTTL);\nlen += sprintf(buf+len,"Frag Creates: %lu\\n",ip_statistics.IpFragCreates);\n/')]),e._v(" это может показать больше.... "),_("em",[e._v("/\nвернуть лен;\n} /")]),e._v(" show_ip_stats "),_("em",[e._v("/\n/")])]),e._v("******************************************************* *************** test_entry")]),e._v(" "),_("li",[e._v("эта структура является своего рода регистрационной формой для /proc FS; оно говорит")]),e._v(" "),_("li",[e._v("FS для выделения динамического индекса, дает «файлу» имя и дает")]),e._v(" "),_("li",[e._v("адрес функции для вызова при чтении файла "),_("em",[e._v("/\nструктура proc_dir_entry test_entry = {\n0, /")]),e._v(" low_ino - номер инода (0 для динамического) "),_("em",[e._v("/\n12, /")]),e._v(" namelen - длина имени записи "),_("em",[e._v('/\n"simple_entry", /')]),e._v(" имя "),_("em",[e._v("/\nС_ИФРЕГ | S_IRUGO, /")]),e._v(" режим "),_("em",[e._v("/\n1, /")]),e._v(" nссылки "),_("em",[e._v("/\n0, /")]),e._v(" uid - владелец "),_("em",[e._v("/\n0, /")]),e._v(" гид - группа "),_("em",[e._v("/\n0, /")]),e._v(" размер - не используется "),_("em",[e._v("/\nNULL, /")]),e._v(" ops — операции с inode (использовать по умолчанию) "),_("em",[e._v("/\n&show_ip_stats /")]),e._v(" read_proc - адрес функции чтения "),_("em",[e._v("/\n/")]),e._v(" оставить пустым! "),_("em",[e._v("/\n};\n/")]),e._v("******************************************************** *************** init_module")]),e._v(" "),_("li",[e._v("эта функция устанавливает модуль; он просто регистрирует запись в каталоге")]),e._v(" "),_("li",[e._v("с файловой системой /proc "),_("em",[e._v("/\ninit_module() {\n/")]),e._v(" зарегистрировать функцию в proc FS "),_("em",[e._v("/\nint err = proc_register(&proc_root,&test_entry);\n/")]),e._v(" записываем результаты регистрации в лог "),_("em",[e._v('/\nесли (!ошибка)\nprintk("<1> simple_entry: зарегистрирован с инодом %d.\\n",\ntest_entry.low_ino);\nеще\nprintk("<1> simple_entry: ошибка регистрации, код %d.\\n",err);\nвернуть ошибку;\n} /')]),e._v(" init_module "),_("em",[e._v("/\n/")]),e._v("******************************************************** *********** cleanup_module")]),e._v(" "),_("li",[e._v("эта функция удаляет модуль; он просто отменяет регистрацию каталога")]),e._v(" "),_("li",[e._v("запись из /proc ФС "),_("em",[e._v("/\nнедействительным cleanup_module () {\n/")]),e._v(" отменить регистрацию функции в proc FS "),_("em",[e._v("/\nint err = proc_unregister(&proc_root,test_entry.low_ino);\n/")]),e._v(" записываем результаты отмены регистрации в лог "),_("em",[e._v('/\nесли (!ошибка)\nprintk("<1> simple_entry: незарегистрированный инод %d.\\n",\ntest_entry.low_ino);\nеще\nprintk("<1> simple_entry: ошибка отмены регистрации, код %d.\\n",err);\n} /')]),e._v(" модуль очистки */")])]),e._v(" "),_("p",[e._v("Это "),_("em",[e._v("Makefile")]),e._v(" :")]),e._v(" "),_("h1",{attrs:{id:"makefile-для-simple-entry"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#makefile-для-simple-entry"}},[e._v("#")]),e._v(" Makefile для simple_entry")]),e._v(" "),_("p",[e._v("CC = gcc -I/usr/src/linux/include\nCFLAGS = -O2 -D__KERNEL__ -Стена\nпростая_запись.о: простая_запись.с\nустановить:\n/sbin/insmod простая_запись\nудалять:\n/sbin/rmmod простая_запись")]),e._v(" "),_("p",[e._v("Для использования (должен быть root ):")]),e._v(" "),_("p",[e._v("корень # сделать\nкорень # сделать установку\nroot# cat /proc/simple_entry\nНемного статистики IP:\nIP-переадресация включена\nСрок жизни по умолчанию: 64\nСоздание фрагментов: 0\nкорень # сделать удалить\nroot# хвост /var/log/messages\n... ядро: simple_entry: зарегистрировано с инодом 4365.\n... ядро: simple_entry: незарегистрированный инод 4365.")]),e._v(" "),_("h1",{attrs:{id:"глава-13"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-13"}},[e._v("#")]),e._v(" Глава 13.")]),e._v(" "),_("p",[e._v("Пример — дроппер пакетов")]),e._v(" "),_("p",[e._v("В этом примере эксперимента в ядро ​​вставляется подпрограмма, которая выборочно отбрасывает пакеты на заданный хост. В нем обсуждается размещение кода, обрисовываются данные фактического испытания, представлен упрощенный анализ результатов и включается сам код.")]),e._v(" "),_("h2",{attrs:{id:"_13-1-обзор"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-обзор"}},[e._v("#")]),e._v(" 13.1   Обзор")]),e._v(" "),_("p",[e._v("Эта программа реализована в виде модуля, который при установке сравнивает адрес получателя каждого исходящего пакета с заданным адресом. Если они совпадают, процент этих пакетов отбрасывается случайным образом. Он делает это для всего IP-трафика, независимо от того, где он был сгенерирован и какой транспортный протокол он использует. Для реализации этого требуется модификация ядра (чтобы разрешить модулю доступ к функциям передачи) и модуль, который использует преимущества этой модификации.")]),e._v(" "),_("h2",{attrs:{id:"_13-2-соображения"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-соображения"}},[e._v("#")]),e._v(" 13.2   Соображения")]),e._v(" "),_("p",[_("strong",[e._v("Размещение кода")])]),e._v(" "),_("p",[e._v("Этот код может быть встроен непосредственно в ядро ​​или оформлен в виде модуля:")]),e._v(" "),_("ul",[_("li",[e._v("Ядро — это концептуально намного проще; простое добавление некоторого кода в ядро ​​является довольно простым делом. Однако он вносит полупостоянные изменения и требует много времени для отладки, поскольку для каждого изменения необходимо перекомпилировать, установить и перезагрузить все ядро.")]),e._v(" "),_("li",[e._v("Модуль — это намного безопаснее и проще, поскольку (супер) пользователь может безболезненно устанавливать, удалять и отлаживать модули. Однако для этого требуется доступ к ядру, который не всегда доступен — даже из модуля. Ядро не всегда экспортирует переменные, к которым может потребоваться доступ модулю. (См. обсуждение программы "),_("em",[e._v("ksyms")]),e._v(" в главе  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#module",target:"_blank",rel:"noopener noreferrer"}},[e._v("11."),_("OutboundLink")],1),e._v(" )")]),e._v(" "),_("li",[e._v("Оба - это лучший метод; выполнив несколько незначительных модификаций кода ядра для экспорта необходимых переменных и использования модуля только в том случае, если он загружен, пользователь может один раз перекомпилировать ядро, а затем выполнять тесты и эксперименты с модулями. Это по-прежнему имеет тот недостаток, что открывает потенциальные дыры в безопасности системы, но поскольку только экспериментатор знает, как они реализованы, это минимальный риск.")])]),e._v(" "),_("p",[_("strong",[e._v("Уровень протокола")])]),e._v(" "),_("p",[e._v("Этот код может быть реализован на многих уровнях:")]),e._v(" "),_("ul",[_("li",[e._v("Драйвер устройства — это возможно, так как весь трафик проходит через устройство. Однако это нарушает многоуровневые протоколы и требует взлома (предположительно) стабильного аппаратного драйвера.")]),e._v(" "),_("li",[e._v("Универсальные функции устройства — это лучший выбор, так как это самый низкий уровень, через который проходит весь трафик (в частности, функции dev_queue_xmit() и netif_rx() ). Это по-прежнему нарушает многоуровневость протокола, но все модификации могут быть сделаны в одном разделе кода.")]),e._v(" "),_("li",[e._v("IP-протокол — это концептуально правильное место для вставки специальной функции во входные, маршрутизирующие или выходные подпрограммы. Однако это не подходит именно потому, что в реализации есть три разные процедуры, через которые может пройти пакет: ip_forward() (переадресованные пакеты), ip_queue_xmit() (пакеты TCP) или ip_build_xmit() (пакеты UDP). См. разделы кодирования в главах  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#sending",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),_("OutboundLink")],1),e._v("  и  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#forward",target:"_blank",rel:"noopener noreferrer"}},[e._v("7"),_("OutboundLink")],1),e._v(" , чтобы увидеть, как взаимодействуют эти подпрограммы. Эти функции были бы хорошим выбором для вставки дроппера специального назначения, но не того, который влияет на весь трафик.")]),e._v(" "),_("li",[e._v("Транспортный протокол — эти подпрограммы подходят для обработки определенных типов трафика (например, только UDP), но в данном примере они бесполезны.")])]),e._v(" "),_("h2",{attrs:{id:"_13-3-экспериментальные-системы-и-тесты"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-3-экспериментальные-системы-и-тесты"}},[e._v("#")]),e._v(" 13.3   Экспериментальные системы и тесты")]),e._v(" "),_("p",[e._v("Этот пример был реализован на двух компьютерах, подключенных через один маршрутизатор, как показано на рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_setup",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.1"),_("OutboundLink")],1),e._v(" ; маршрутизатор работает с модифицированным ядром и модулем отбрасывания пакетов. В общем примере это представляет трафик, проходящий между neon и eagle , а dodge/viper отбрасывает пакеты для eagle .")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_setup.gif",alt:"x_setup.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 13.1: Настройка экспериментальной системы.")]),e._v(" "),_("p",[e._v("Коммутатор представляет собой Cisco Catalyst 2900, настроенный с виртуальными локальными сетями (VLAN) для каждой «подсети» (одна для исходного компьютера и одна для целевого компьютера, при этом маршрутизирующий компьютер действует как маршрутизатор между ними). ​​Коммутатор работает полностью на уровне канала и практически невидим для целей маршрутизации.")]),e._v(" "),_("p",[e._v("Маршрутизирующий компьютер ( dodge/viper ) представляет собой Dell Optiplex GX1 с процессором Pentium II/350 и 128 МБ оперативной памяти. Он имеет три карты Ethernet 3Com 3c59x с подключением к коммутатору на скорости 10 Мбит/с.")]),e._v(" "),_("p",[e._v("Один хост-компьютер ( neon ) представляет собой AST Premmia GX с процессором Pentium/100 и 32 МБ оперативной памяти. Он имеет карту AMD Lance Ethernet с подключением к коммутатору на скорости 10 Мбит/с.")]),e._v(" "),_("p",[e._v("Другой хост-компьютер ( eagle ) — это Dell Optiplex XL590 с процессором Pentium/90 и 32 МБ оперативной памяти. Он имеет карту Ethernet 3Com 3c509 с подключением к коммутатору на скорости 10 Мбит/с.")]),e._v(" "),_("p",[e._v("На всех компьютерах установлен дистрибутив Linux Red Hat 6.1; исходный и конечный компьютеры имеют стандартные перекомпилированные ядра версии 2.2.14, в то время как маршрутизатор использует либо стандартное (2.2.14) ядро, либо слегка модифицированное, как указано.")]),e._v(" "),_("p",[e._v("Первый эталонный тест представляет собой тест «пинг-понг», который устанавливает TCP-соединение, а затем повторно отправляет пакеты туда и обратно. Он возвращает общее время передачи (от начала до конца, не включая установление и закрытие соединения); деление времени на количество итераций дает среднее время приема-передачи (RTT). Этот тест был запущен с 20 000 итераций 5-байтовых пакетов и 5 000 итераций 500-байтовых пакетов.")]),e._v(" "),_("p",[e._v("Второй эталонный тест представляет собой «взрывной» тест, который устанавливает TCP-соединение, а затем отправляет данные из источника в пункт назначения. Он возвращает общее время передачи (от начала до конца, не включая установление и закрытие соединения); умножение количества пакетов на размер пакетов и деление на время дает пропускную способность. Этот тест был запущен с 50 000 5-байтовых пакетов, 5000 500-байтовых пакетов и 1000 1500-байтовых пакетов.")]),e._v(" "),_("p",[e._v("Тесты проводились на обеих машинах (т. е. с neon на eagle и с eagle на neon ), но в обоих случаях отбрасывались только пакеты на eagle . В каждом испытании взрывной тест запускался один раз с настройками по умолчанию (100 пакетов по 1 байту каждый) перед запуском тестов производительности «для записи», чтобы убедиться, что кэш маршрутизации и все таблицы протоколов находятся в нормализованном состоянии. Полный набор был запущен десять раз, чтобы зафиксировать различия между испытаниями (здесь представлены средние значения). Ни на одной из машин (включая маршрутизатор) не запускались какие-либо другие пользовательские программы, кроме оболочки входа в систему и соответствующего модуля, клиента или серверных программ (даже X Windows).")]),e._v(" "),_("h2",{attrs:{id:"_13-4-результаты-и-предварительныи-анализ"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-результаты-и-предварительныи-анализ"}},[e._v("#")]),e._v(" 13.4   Результаты и предварительный анализ")]),e._v(" "),_("h3",{attrs:{id:"_13-4-1-стандартное-ядро"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-1-стандартное-ядро"}},[e._v("#")]),e._v(" 13.4.1   Стандартное ядро")]),e._v(" "),_("p",[e._v("Это эталонные стандарты; эти подпрограммы выполнялись с двумя компьютерами, подключенными напрямую (НЕ маршрутизированными), и когда на маршрутизаторе было немодифицированное ядро ​​​​Linux 2.2.14. Частота ошибок при таком прямом соединении близка к нулю.")]),e._v(" "),_("p",[_("em",[e._v("настольный теннис")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("                       Среднее время (сек) Среднее значение RTT (миллисекунды)\n           Частота выпадения 20K@5 5K@500 20K@5 5K@500\n")])])]),_("p",[e._v("Прямой -\nнеон → орел: --- 17,24 28,98 0,86 5,80\nот орла до неона: --- 17,20 28,99 0,86 5,80\nМаршрутизированный -\nнеон → орел: (0,0%) 24,53 48,59 1,23 9,72\nот орла до неона: (0,0%) 24,36 48,46 1,22 9,69")]),e._v(" "),_("p",[_("em",[e._v("взрыв")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("                           Среднее время (сек) Пропускная способность (Мбит/сек)\n           Частота выпадения 50K*5 10K*500 1K*1500 50K*5 10K*500 1K*1500\n")])])]),_("p",[e._v("Прямой -\nнеон → орел: --- 0,56 3,19 1,89 3,55 6,26 6,36\nот орла до неона: --- 0,78 3,03 1,77 2,58 6,61 6,76\nМаршрутизированный -\nот неона до орла: (0,0%) 0,56 3,19 1,92 3,60 6,27 6,26\nот орла до неона: (0,0%) 0,77 3,19 1,93 2,60 6,27 6,23")]),e._v(" "),_("h3",{attrs:{id:"_13-4-2-отбрасывание-пакетов-модифицированного-ядра"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-2-отбрасывание-пакетов-модифицированного-ядра"}},[e._v("#")]),e._v(" 13.4.2   Отбрасывание пакетов модифицированного ядра")]),e._v(" "),_("p",[e._v("Это результаты экспериментов. Скорость отбрасывания 0,0 % обеспечивает эталон для измерения накладных расходов на вызов тестовых и случайных функций без отбрасывания каких-либо пакетов.")]),e._v(" "),_("p",[_("em",[e._v("настольный теннис")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("                       Среднее время (сек) Среднее значение RTT (миллисекунды)\n           Частота выпадения 20K@5 5K@500 20K@5 5K@500\n")])])]),_("p",[e._v("неон к орлу: 0,0% 25,55 49,12 1,28 9,82\n0,1% 29,87 51,11 1,49 10,22\n0,5% 44,78 58,07 2,24 11,61\n1,0% 65,37 68,77 3,27 13,75\n5,0% 245,51 160,09 12,28 32,02\n10,0% 506,03 290,77 25,30 58,15\nорел к неону: 0,0% 25,53 49,21 1,28 9,84\n0,1% 29,08 50,92 1,45 10,18\n0,5% 45,87 59,21 2,29 11,84\n1,0% 66,19 68,66 3,31 13,73\n5,0% 235,68 156,94 11,78 31,39\n10,0% 519,61 297,02 25,98 59,40")]),e._v(" "),_("p",[_("em",[e._v("взрыв")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("                           Среднее время (сек) Пропускная способность (Мбит/сек)\n           Частота выпадения 50K*5 10K*500 1K*1500 50K*5 10K*500 1K*1500\n")])])]),_("p",[e._v("неон к орлу: 0,0% 0,55 3,19 1,91 3,64 6,26 6,27\n0,1% 0,55 3,07 1,93 3,62 6,51 6,21\n0,5% 0,55 2,95 1,76 3,64 6,77 6,82\n1,0% 0,55 2,87 1,75 3,65 6,96 6,87\n2,5% 0,59 3,36 2,04 3,38 5,59 5,90\n5,0% 0,63 4,63 2,71 3,19 4,31 4,43\n10,0% 1,06 7,08 5,11 1,89 2,83 2,35\n20,0% 3,43 30,35 18,55 0,58 0,66 0,65\nорел к неону: 0,0% 0,79 3,21 1,93 2,53 6,23 6,23\n0,1% 0,77 3,22 1,89 2,59 6,20 6,35\n0,5% 0,80 3,24 1,88 2,51 6,17 6,39\n1,0% 0,77 3,24 1,91 2,60 6,17 6,27\n2,5% 0,79 3,17 1,90 2,53 6,31 6,33\n5,0% 0,78 3,17 1,91 2,57 6,31 6,29\n10,0% 0,81 3,85 2,51 2,48 5,20 4,78\n20,0% 2,02 4,06 2,51 0,99 4,92 4,78")]),e._v(" "),_("h3",{attrs:{id:"_13-4-3-предварительныи-анализ"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-3-предварительныи-анализ"}},[e._v("#")]),e._v(" 13.4.3   Предварительный анализ")]),e._v(" "),_("p",[e._v("Далее следует элементарная проверка результатов. Он НЕ предназначен для исчерпывающего анализа, и действительно, эксперимент не был достаточно обширным, чтобы предоставить достоверные данные, из которых можно было бы сделать определенные выводы. Однако это демонстрирует множество вовлеченных факторов и эффектов, которые несколько строк кода могут оказать на сеть. Дальнейший анализ, при желании, оставляем читателю в качестве упражнения.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_pong.gif",alt:"x_pong.gif"}})]),e._v(" "),_("p",[e._v("Рисунок 13.2: Результаты тестирования пинг-понга.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.cs.unh.edu/cnrg/people/gherrin/x_blast.gif",alt:"x_blast.gif"}})]),e._v(" "),_("p",[e._v("Рис. 13.3: Результаты тестов взрыва.")]),e._v(" "),_("p",[e._v('Модификации ядра и вставка модуля оказали небольшое, но измеримое влияние на TCP-соединение (измеряемое увеличением RTT). Для очень маленьких пакетов эта разница составляла примерно 0,05 мс; для больших пакетов это было 0,10 мс. Почему должна быть разница? Обратите внимание, что направление движения и размер пакета сильно повлияли на пропускную способность. Это указывает на то, что скорость процессора и накладные расходы на уровни влияют на RTT; для 1500-байтового пакета 66 байтов обертки (20 для TCP, 20 для IP и не менее 26 для Ethernet) не очень важны, но для 5-байтового пакета эти накладные расходы очень велики. Предположим, что фактическая "стоимость" вставки модуля равна задержке для больших пакетов, 0,10 мс.')]),e._v(" "),_("p",[e._v("Отбрасывание пакетов из TCP-соединения приводило к довольно линейному падению производительности в тесте пинг-понг; см. график на рис.  "),_("a",{attrs:{href:"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#x_pong",target:"_blank",rel:"noopener noreferrer"}},[e._v("13.2"),_("OutboundLink")],1),e._v(' . Это ожидаемо; когда либо пакет, либо подтверждение потеряны, отправитель делает паузу, а затем отправляет снова. RTT также очень близок (конечно, в пределах ожидаемой экспериментальной ошибки) независимо от того, какая машина является "источником"; опять же, это потому, что эталонный тест проверяет поведение обеих машин одновременно.')]),e._v(" "),_("p",[e._v("При малых размерах пакетов пропускная способность сильно различалась в зависимости от способа отправки данных. Это потому, что одна машина ( орел ) была медленнее другой. Для большого количества очень маленьких пакетов узким местом в сети является не среда или интерфейс, а скорость, с которой процессор может создавать и отправлять пакеты. Однако при больших размерах пакетов пропускная способность (при низкой частоте ошибок) для обоих источников одинакова; в этом случае ограничивающим фактором является сеть, а не процессор.")]),e._v(" "),_("p",[e._v("Наиболее удивительным результатом является очевидный пик пропускной способности, когда уровень потерь составляет примерно 1%, что даже лучше, чем полное отсутствие потерь (для удаленных данных; потеря ACK, отправленных от получателя к источнику, оказала незначительное влияние). Это очень противоречивый вывод; почему потеря пакетов должна увеличивать пропускную способность? Ошибки в 1% может быть достаточно, чтобы алгоритм экспоненциальной отсрочки TCP не замедлил скорость трафика. Немедленный ACK, отправляемый получателем при поступлении неупорядоченного пакета, может включать информацию о размере окна, которая удерживает отправителя от паузы. Прерывания, вызванные неупорядоченными пакетами, могут привести к тому, что планировщик будет запускать процесс эталонного теста чаще, очищая окно буфера и снова не позволяя отправителю приостановить работу. Есть много потенциальных причин;")]),e._v(" "),_("h2",{attrs:{id:"_13-5-код"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-код"}},[e._v("#")]),e._v(" 13.5   Код")]),e._v(" "),_("h3",{attrs:{id:"_13-5-1-ядро"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-1-ядро"}},[e._v("#")]),e._v(" 13.5.1   Ядро")]),e._v(" "),_("p",[e._v("Следующий код добавляет в ядро ​​лазейку. Он создает функцию, которая будет вызываться (если она существует) из функции dev_queue_xmit() , и экспортирует ее, чтобы модули могли ее использовать. Эти строки добавляются непосредственно в исходный код; тогда ядро ​​должно быть перекомпилировано. установил, загрузился. Обратите внимание, что ядро ​​по-прежнему работает нормально (хотя и с одним дополнительным сравнением), пока не установлен тестовый модуль.")]),e._v(" "),_("p",[_("em",[e._v("net/core/dev.c")]),e._v(" (после строки 579)")]),e._v(" "),_("p",[e._v("...\nint *test_function(struct sk_buff "),_("em",[e._v(")=0; /")]),e._v(" новый */\nint dev_queue_xmit(struct sk_buff *skb)...\n... структура Qdisc *q;\nif (test_function && ("),_("em",[e._v("test_function)(skb)) { /")]),e._v(" новый "),_("em",[e._v("/\nkfree_skb(скб); /")]),e._v(" новый "),_("em",[e._v("/\nвернуть 0; /")]),e._v(" новый "),_("em",[e._v("/\n} /")]),e._v(" новый */\n#ifdef CONFIG_NET_PROFILE...")]),e._v(" "),_("p",[_("em",[e._v("net/netsyms.c")]),e._v(" (после строки 544)")]),e._v(" "),_("p",[e._v("...\nextern int (*test_function)(struct sk_buff "),_("em",[e._v("); /")]),e._v(" новый "),_("em",[e._v("/\nEXPORT_SYMBOL_NOVERS (тестовая_функция); /")]),e._v(" новый */\nEXPORT_SYMBOL(register_gifconf);...")]),e._v(" "),_("h3",{attrs:{id:"_13-5-2-модуль"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-2-модуль"}},[e._v("#")]),e._v(" 13.5.2   Модуль")]),e._v(" "),_("p",[e._v("Ниже приведен код самого модуля отбрасывания пакетов. При установке он вычисляет процентное отсечение и помещает адрес в указатель функции, определенный выше. С этого момента любые пакеты, отправленные через dev_queue_xmit(), также будут проходить через функцию packet_dropper , которая сравнивает адрес назначения с жестко заданным. Если они совпадают и случайное число оказывается ниже расчетного порога, пакет отбрасывается; в противном случае пакеты проходят нетронутыми. Когда модуль удаляется, он снова сбрасывает указатель функции на 0 ( null ). (Обратите внимание, что этот не очень надежный код для простоты зависит от двухбайтовых коротких целых чисел. Функция get_random_bytes()доступен только ядру — или, конечно, модулям — и предоставляет случайные числа, которые являются «просто криптографически стойкими».)")]),e._v(" "),_("p",[_("em",[e._v("package_dropper.c")])]),e._v(" "),_("p",[e._v("/* package_dropper.c\n*")]),e._v(" "),_("ul",[_("li",[e._v("Эта программа представляет собой пример того, как установить модуль в")]),e._v(" "),_("li",[e._v("слегка измененное ядро, которое будет случайным образом отбрасывать пакеты для определенного")]),e._v(" "),_("li",[e._v("(жестко закодированный) хост.")]),e._v(" "),_("li"),e._v(" "),_("li",[e._v("Подробную информацию о get_random_bytes() см. в linux/drivers/char/random.c.")]),e._v(" "),_("li"),e._v(" "),_("li",[e._v("Использование (для использования должен быть root):")]),e._v(" "),_("li",[e._v("/sbin/insmod packet_dropper")]),e._v(" "),_("li",[e._v("/sbin/rmmod packet_dropper\n"),_("em",[e._v("/\n#define МОДУЛЬ\n#define MAX_UNSIGNED_SHORT 65535\n#include <linux/module.h>\n#include <linux/skbuff.h> /")]),e._v(" для структуры sk_buff "),_("em",[e._v("/\n#include <linux/ip.h> /")]),e._v(" для структуры iphdr "),_("em",[e._v("/\nextern int ("),_("em",[e._v("test_function)(struct sk_buff "),_("em",[e._v("); /")]),e._v(" вызов функции "),_("em",[e._v("/\nextern void get_random_bytes (void "),_("em",[e._v("buf, int nbytes); /")]),e._v(" случайная функция "),_("em",[e._v("/\nбеззнаковая короткая отсечка; /")]),e._v(" сбрасываем отсечку "),_("em",[e._v("/\nплавающая ставка = 0,050; /")]),e._v(" процент выпадения "),_("em",[e._v("/\n__u32 цель = 0x220010AC; /")]),e._v(" 172.16.0.34 "),_("em",[e._v("/\n/")])])])]),e._v("***************************************************** *********** packet_dropper")]),e._v(" "),_("li",[e._v("это то, что будет вызывать dev_queue_xmit, пока этот модуль установлен "),_("em",[e._v("/\nint packet_dropper (структура sk_buff * skb) {\nбеззнаковая короткая т;\nесли (skb->nh.iph->daddr == target) {\nget_random_bytes(&t,2);\nесли (t <= отсечка) вернуть 1; /")]),e._v(" отбрасываем этот пакет "),_("em",[e._v("/\n}\nвернуть 0; /")]),e._v(" продолжить обычную процедуру "),_("em",[e._v("/\n} /")]),e._v(" package_dropper "),_("em",[e._v("/\n/")]),e._v("******************************************************** *************** init_module")]),e._v(" "),_("li",[e._v("эта функция заменяет нулевой указатель реальным "),_("em",[e._v('/\ninit_module() {\nEXPORT_NO_SYMBOLS;\nотсечка = ставка * MAX_UNSIGNED_SHORT;\ntest_function = разбрасыватель пакетов;\nprintk("<1> packet_dropper: теперь пакеты отбрасываются\\n");\nвернуть 0;\n} /')]),e._v(" init_module "),_("em",[e._v("/\n/")]),e._v("******************************************************** *********** cleanup_module")]),e._v(" "),_("li",[e._v("эта функция сбрасывает указатель функции обратно на ноль "),_("em",[e._v('/\nнедействительным cleanup_module () {\nтестовая_функция = 0;\nprintk("<1> packet_dropper: деинсталлирован\\n");\n} /')]),e._v(" модуль очистки */")])]),e._v(" "),_("h1",{attrs:{id:"глава-14"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-14"}},[e._v("#")]),e._v(" Глава 14")]),e._v(" "),_("p",[e._v("Дополнительные ресурсы")]),e._v(" "),_("h2",{attrs:{id:"_14-1-интернет-саиты"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-интернет-саиты"}},[e._v("#")]),e._v(" 14.1   Интернет-сайты")]),e._v(" "),_("p",[_("strong",[e._v("Проект документации по Linux")])]),e._v(" "),_("p",[e._v("http://metalab.unc.edu/mdw/index.html")]),e._v(" "),_("p",[_("strong",[e._v("Штаб-квартира Linux")])]),e._v(" "),_("p",[e._v("http://www.linuxhq.com")]),e._v(" "),_("p",[_("strong",[e._v("Linux HOWTO")])]),e._v(" "),_("p",[e._v("ftp://metalab.unc.edu/pub/Linux/docs/HOWTO")]),e._v(" "),_("p",[_("strong",[e._v("Руководство для хакеров ядра Linux")])]),e._v(" "),_("p",[e._v("http://metalab.unc.edu/mdw/LDP/khg/HyperNews/get/khg.html")]),e._v(" "),_("p",[_("strong",[e._v("Проект Linux-маршрутизатора")])]),e._v(" "),_("p",[e._v("http://www.linuxrouter.org")]),e._v(" "),_("p",[_("strong",[e._v("Новый ТТСР")])]),e._v(" "),_("p",[e._v("http://users.leo.org/ ~ бартель")]),e._v(" "),_("p",[_("strong",[e._v("Программное обеспечение Red Hat")])]),e._v(" "),_("p",[e._v("http://www.redhat.com")]),e._v(" "),_("p",[_("strong",[e._v("Запросы комментариев")])]),e._v(" "),_("p",[e._v("http://www.rfc-editor.org/isi.html")]),e._v(" "),_("h2",{attrs:{id:"_14-2-книги"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-книги"}},[e._v("#")]),e._v(" 14.2   Книги")]),e._v(" "),_("p",[_("strong",[e._v("Компьютерная сеть")])]),e._v(" "),_("p",[e._v("Таненбаум, Эндрю, Prentice-Hall Inc., Аппер-Сэддл-Ривер, Нью-Джерси, 1996.")]),e._v(" "),_("p",[_("strong",[e._v("Высокоскоростные сети")])]),e._v(" "),_("p",[e._v("Столлингс, Уильям, Prentice-Hall Inc., Аппер-Сэдл-Ривер, Нью-Джерси, 1998.")]),e._v(" "),_("p",[_("strong",[e._v("Комментарий к ядру Linux Core")])]),e._v(" "),_("p",[e._v("Максвелл, Скотт, CoriolisOpen Press, Скоттсдейл, Аризона, 1999.")]),e._v(" "),_("p",[_("strong",[e._v("Драйверы устройств Linux")])]),e._v(" "),_("p",[e._v("Рубини, Алессандро, O'Reilly & Associates, Inc., Севастополь, Калифорния, 1998 г.")]),e._v(" "),_("p",[_("strong",[e._v("Внутреннее устройство ядра Linux")])]),e._v(" "),_("p",[e._v("Бек, Майкл и др., Аддисон-Уэсли, Харлоу, Англия, 1997.")]),e._v(" "),_("p",[_("strong",[e._v("Запуск Linux")])]),e._v(" "),_("p",[e._v("Уэлш, Мэтт, Далхеймер, Маттиас и Кауфман, Лар, O'Reilly & Associates, Inc., Севастополь, Калифорния, 1999.")]),e._v(" "),_("p",[_("strong",[e._v("Сетевое программирование Unix, Vol. 1 (2-е изд.)")])]),e._v(" "),_("p",[e._v("Стивенс, В. Ричард, Prentice-Hall Inc., Аппер-Сэддл-Ривер, Нью-Джерси, 1998.")]),e._v(" "),_("h1",{attrs:{id:"глава-15"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#глава-15"}},[e._v("#")]),e._v(" Глава 15")]),e._v(" "),_("p",[e._v("Сокращения")]),e._v(" "),_("p",[_("strong",[e._v("ARP")])]),e._v(" "),_("p",[e._v("Протокол разрешения адресов")]),e._v(" "),_("p",[_("strong",[e._v("банкомат")])]),e._v(" "),_("p",[e._v("Асинхронный режим передачи (протокол)")]),e._v(" "),_("p",[_("strong",[e._v("BSD")])]),e._v(" "),_("p",[e._v("Распространение программного обеспечения Беркли")]),e._v(" "),_("p",[_("strong",[e._v("DHCP")])]),e._v(" "),_("p",[e._v("Протокол динамической конфигурации оборудования")]),e._v(" "),_("p",[_("strong",[e._v("DNS")])]),e._v(" "),_("p",[e._v("Сервер доменных имен")]),e._v(" "),_("p",[_("strong",[e._v("ФРБ")])]),e._v(" "),_("p",[e._v("Экспедиторская информационная база")]),e._v(" "),_("p",[_("strong",[e._v("графический интерфейс")])]),e._v(" "),_("p",[e._v("Графический пользовательский интерфейс")]),e._v(" "),_("p",[_("strong",[e._v("ICMP")])]),e._v(" "),_("p",[e._v("Протокол контрольных сообщений Интернета")]),e._v(" "),_("p",[_("strong",[e._v("ИНЕТ")])]),e._v(" "),_("p",[e._v("Интернет")]),e._v(" "),_("p",[_("strong",[e._v("IP")])]),e._v(" "),_("p",[e._v("протокол Интернета")]),e._v(" "),_("p",[_("strong",[e._v("Интернет-провайдер")])]),e._v(" "),_("p",[e._v("Интернет-провайдер")]),e._v(" "),_("p",[_("strong",[e._v("локальная сеть")])]),e._v(" "),_("p",[e._v("Локальная сеть")]),e._v(" "),_("p",[_("strong",[e._v("ЛДП")])]),e._v(" "),_("p",[e._v("Проект документации по Linux")]),e._v(" "),_("p",[_("strong",[e._v("вот")])]),e._v(" "),_("p",[e._v("Loopback (устройство или интерфейс)")]),e._v(" "),_("p",[_("strong",[e._v("МТУ")])]),e._v(" "),_("p",[e._v("Максимальная единица передачи")]),e._v(" "),_("p",[_("strong",[e._v("ГЧП")])]),e._v(" "),_("p",[e._v("Протокол точка-точка")]),e._v(" "),_("p",[_("strong",[e._v("РАРП")])]),e._v(" "),_("p",[e._v("Протокол обратного разрешения адресов")]),e._v(" "),_("p",[_("strong",[e._v("РВАТЬ")])]),e._v(" "),_("p",[e._v("Протокол маршрутной информации")]),e._v(" "),_("p",[_("strong",[e._v("РТТ")])]),e._v(" "),_("p",[e._v("Время в пути туда и обратно")]),e._v(" "),_("p",[_("strong",[e._v("TCP")])]),e._v(" "),_("p",[e._v("Протокол управления передачей")]),e._v(" "),_("p",[_("strong",[e._v("UDP")])]),e._v(" "),_("p",[e._v("Протокол пользовательских датаграмм")]),e._v(" "),_("p",[_("strong",[e._v("UNH")])]),e._v(" "),_("p",[e._v("Университет Нью-Гэмпшира")]),e._v(" "),_("p",[_("strong",[e._v("ВЛАН")])]),e._v(" "),_("p",[e._v("Виртуальная локальная сеть")]),e._v(" "),_("p",[_("strong",[e._v("глобальная сеть")])]),e._v(" "),_("p",[e._v("Глобальная сеть")])])}),[],!1,null,null,null);_.default=r.exports}}]);