(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{414:function(_,v,e){"use strict";e.r(v);var s=e(14),t=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("https://parallel.uran.ru/book/export/html/505")]),_._v(" "),v("h1",{attrs:{id:"system-v-ipc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#system-v-ipc"}},[_._v("#")]),_._v(" System V IPC")]),_._v(" "),v("p",[_._v("Интерфейс межпроцессного взаимодействия "),v("em",[_._v("System V IPC")]),_._v(" позволяет манипулировать классическими набором объектов, таких как: очередь сообщений, семафор и разделяемая память.")]),_._v(" "),v("p",[_._v("Объекты "),v("em",[_._v("System V IPC")]),_._v(" идентифицируется 32-битным ключом "),v("em",[_._v("IPC")]),_._v(", играющего роль, аналогичную имени файла. При создании объекта IPC ему присваивается уникальный 32-битный идентификатор "),v("em",[_._v("IPC")]),_._v(", аналогичный inode файла. Идентификаторы "),v("em",[_._v("IPC")]),_._v(" назначаются ядром, ключи "),v("em",[_._v("IPC")]),_._v(" произвольно выбираются программистами.")]),_._v(" "),v("p",[_._v("У каждого объект "),v("em",[_._v("IPC")]),_._v(' есть атрибуты "пользователь-владелец", "группа-владельца", "пользователь-создатель", "группа-создателя", а так же права на чтение и запись для владельца, группы-владельца и остальных, аналогичные файловым. Например: '),v("em",[_._v("rw- r-- ---")]),_._v(".")]),_._v(" "),v("p",[_._v("Впервые "),v("em",[_._v("System V IPC")]),_._v(" появился во внутренних версиях "),v("em",[_._v("Unix")]),_._v(", использовавшихся в компании "),v("em",[_._v("Bell Laboratories")]),_._v(", но массовое распространение получил вместе с самой продаваемой версией "),v("em",[_._v("Unix")]),_._v(" - "),v("em",[_._v("System V")]),_._v(", что и отражено в названии.")]),_._v(" "),v("p",[v("em",[_._v("System V IPC")]),_._v(" имеет некоторые недостатки, в частности, плохую масштабируемость, в связи с тем, что создаваемые объекты не привязаны к процессам, и потому могут оставаться в памяти до перезагрузки ОС .")]),_._v(" "),v("p",[_._v("В последующем, "),v("em",[_._v("System V IPC")]),_._v(" с небольшими изменениями вошёл в стандарт "),v("em",[_._v("POSIX")]),_._v(". Логика работы с объектами сохранилась, однако была проведена некоторая унификация вызовов "),v("em",[_._v("System V IPC")]),_._v(" с вызовами файловой системы. Соответственно, поменялись имена функций.")]),_._v(" "),v("h3",{attrs:{id:"примеры-отличии-system-v-ipc-и-posix"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#примеры-отличии-system-v-ipc-и-posix"}},[_._v("#")]),_._v(" Примеры отличий "),v("em",[_._v("System V IPC")]),_._v(" и "),v("em",[_._v("POSIX")])]),_._v(" "),v("p",[_._v("В "),v("em",[_._v("System V IPC")]),_._v(" для именования объекта создаётся особый 32-битный ключ, часто формируемый из "),v("em",[_._v("inode")]),_._v(" существующего файла и целого числа, в "),v("em",[_._v("POSIX")]),_._v(" имена объектов имитируют имена файловой системы в формате "),v("em",[_._v("/object_name")]),_._v(".")]),_._v(" "),v("p",[_._v("Набор функций для работы с разделяемой памятью из "),v("em",[_._v("shmget()")]),_._v(", "),v("em",[_._v("shmat()")]),_._v(", "),v("em",[_._v("shmdt()")]),_._v(", "),v("em",[_._v("shmctl()")]),_._v(" превратился в "),v("em",[_._v("shm_open()")]),_._v(", "),v("em",[_._v("mmap()")]),_._v(", "),v("em",[_._v("shm_unlink()")]),_._v("/")]),_._v(" "),v("p",[v("em",[_._v("shmget()")]),_._v(" возвращает идентификатор "),v("em",[_._v("IPC")]),_._v(", а "),v("em",[_._v("shm_open()")]),_._v(" возвращает файловый дескриптор.")]),_._v(" "),v("p",[v("em",[_._v("shmat()")]),_._v(", "),v("em",[_._v("shmdt()")]),_._v(" работают только с разделяемой памятью, а "),v("em",[_._v("mmap()")]),_._v(' одинаково успешно работает как с объектом "разделяемая память", так и с файлами, отображаемыми в память.')]),_._v(" "),v("p",[_._v("Размер сегмента разделяемой памяти "),v("em",[_._v("System V IPC")]),_._v(" неизменен, а в "),v("em",[_._v("POSIX")]),_._v(" может изменяться вызовом * ftruncate() * с последующим обновлением отображения в память процесса вызовами "),v("em",[_._v("munmap()")]),_._v(" и "),v("em",[_._v("mmap()")]),_._v(" .")]),_._v(" "),v("p",[_._v("Наличие сообщений в очередях "),v("em",[_._v("POSIX")]),_._v(" может мониториться через "),v("em",[_._v("callback")]),_._v(", который устанавливается вызовом "),v("em",[_._v("mq_notify()")]),_._v(".")]),_._v(" "),v("h1",{attrs:{id:"классическии-api-system-v-ipc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#классическии-api-system-v-ipc"}},[_._v("#")]),_._v(" Классический API System V IPC")]),_._v(" "),v("h2",{attrs:{id:"пространство-имен"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#пространство-имен"}},[_._v("#")]),_._v(" Пространство имён")]),_._v(" "),v("p",[_._v("Объекты "),v("em",[_._v("System V IPC")]),_._v(" идентифицируется 32-битным ключом "),v("em",[_._v("IPC")]),_._v(", играющего роль, аналогичную имени файла. При создании объекта "),v("em",[_._v("IPC")]),_._v(" ему присваивается уникальный 32-битный идентификатор "),v("em",[_._v("IPC")]),_._v(", аналогичный "),v("em",[_._v("inode")]),_._v(" файла. Идентификаторы "),v("em",[_._v("IPC")]),_._v(" назначаются ядром, ключи "),v("em",[_._v("IPC")]),_._v(" произвольно выбираются программистами.")]),_._v(" "),v("p",[_._v("Особое значение ключа "),v("em",[_._v("IPC_PRIVATE")]),_._v(" адресует объект, доступный только данному процессу и его потомкам. Данное значение позволяет избежать случайного доступа к посторонним объектам из-за конфликта ключей.")]),_._v(" "),v("p",[_._v("В случае совпадения идентификаторов несколько программ будут пытаться получить доступ к одному и тому же объекту. Не существует механизма, гарантирующего выбор уникального ключа "),v("em",[_._v("IPC")]),_._v(", поэтому была создана специальная функция "),v("em",[_._v("ftok()")]),_._v(", генерирующая ключ на основе уникального имени файла в файловой системе (точнее номера его "),v("em",[_._v("Inode")]),_._v(") и дополнительного байта (номера проекта). При выборе файла, для формирования ключа, необходимо обеспечить достаточную длительность его жизни. Если файл удалён, то новые процессы не смогут сгенерировать ключи доступа к объектам "),v("em",[_._v("IPC")]),_._v(" на основе данного файла. Удаление файла и создание нового с тем же именем так же нарушит доступ к объектам "),v("em",[_._v("IPC")]),_._v(" поскольку новый файл будет иметь отличный номер "),v("em",[_._v("Inode")]),_._v(".")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("   #include <sys/types.h>\n   #include <sys/ipc.h>\n\n   key_t ftok(\"/home/bob/key_base\", 'Z');\n")])])]),v("p",[_._v("Реализация "),v("em",[_._v("ftok()")]),_._v(" в "),v("em",[_._v("glibc")])]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("  if (__xstat64 (_STAT_VER, pathname, &st) < 0)\n    return (key_t) -1;\n  key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)\n         | ((proj_id & 0xff) << 24));\n  return key;\n")])])]),v("h2",{attrs:{id:"создание-и-удаление-объектов"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#создание-и-удаление-объектов"}},[_._v("#")]),_._v(" Создание и удаление объектов")]),_._v(" "),v("p",[_._v("Объекты "),v("em",[_._v("IPC")]),_._v(" создаются функциями "),v("em",[_._v("msgget()")]),_._v(", "),v("em",[_._v("semget()")]),_._v(", "),v("em",[_._v("shmget()")]),_._v(".")]),_._v(" "),v("p",[_._v("При создании используются флаги")]),_._v(" "),v("ul",[v("li",[v("em",[_._v("IPC_CREAT")]),_._v(" - Создать объект если он не существовал")]),_._v(" "),v("li",[v("em",[_._v("IPC_EXCL")]),_._v(" - Совместно с "),v("em",[_._v("IPC_CREAT")]),_._v(" - вернуть ошибку если объект существует")])]),_._v(" "),v("p",[_._v("и права доступа. Права доступа аналогичны файлам (mode - rw-rw-rw-)")]),_._v(" "),v("p",[_._v("Управление объектами SysV IPC (в том числе их уничтожение) производится c помощью функций "),v("em",[_._v("msgctl()")]),_._v(", "),v("em",[_._v("semctl()")]),_._v(", "),v("em",[_._v("shmctl()")]),_._v(". Параметр "),v("em",[_._v("cmd")]),_._v(" этих функций может принимать значения:")]),_._v(" "),v("ul",[v("li",[_._v("IPC_RMID - удалить объект")]),_._v(" "),v("li",[_._v("IPC_SET - изменить свойства объекта")]),_._v(" "),v("li",[_._v("IPC_STAT - получить свойства объекта")])]),_._v(" "),v("h2",{attrs:{id:"флаги-операции"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#флаги-операции"}},[_._v("#")]),_._v(" Флаги операций")]),_._v(" "),v("p",[_._v("Во всех операциях с объектами может быть указан дополнительный флаг")]),_._v(" "),v("ul",[v("li",[_._v("IPC_NOWAIT - возвратить ошибку если операция не может быть выполнена немедленно")])]),_._v(" "),v("h2",{attrs:{id:"очередь-сообщении"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#очередь-сообщении"}},[_._v("#")]),_._v(" Очередь сообщений")]),_._v(" "),v("p",[_._v("При создании очереди она ассоциируется с буфером размером "),v("em",[_._v("MSGMNB")]),_._v(" (16384 байт в "),v("em",[_._v("Linux")]),_._v(").")]),_._v(" "),v("p",[_._v("Сообщение состоит из заголовка фиксированной длины и текста переменной длины. Размер текста не должен превышать "),v("em",[_._v("MSGMAX")]),_._v(" (8192 байта в "),v("em",[_._v("Linux")]),_._v(").")]),_._v(" "),v("p",[_._v("Каждое сообщение поступает в очередь, где хранится до тех пор, пока кто-нибудь не прочитает его. После прочтения сообщение удаляется из очереди сообщений. Следовательно, только один процесс может получить конкретное сообщение.")]),_._v(" "),v("p",[_._v("Сообщение может быть помечено целочисленным значением (типом сообщения), которое позволяет процессу избирательно извлекать сообщения из очереди. Правила чтения по типам:")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("если "),v("em",[_._v("msgp")]),_._v(" равен нулю, то используется первое сообщение из очереди;")])]),_._v(" "),v("li",[v("p",[_._v("если "),v("em",[_._v("msgp")]),_._v(" больше нуля, то из очереди берется первое сообщение типа "),v("em",[_._v("msgp")]),_._v(" (если только в параметре "),v("em",[_._v("msgflg")]),_._v(" не выставлен флаг "),v("em",[_._v("MSG_EXCEPT")]),_._v(". В этом случае из очереди берется первое сообщение, тип которого не равен "),v("em",[_._v("msgp")]),_._v(").")])]),_._v(" "),v("li",[v("p",[_._v("если "),v("em",[_._v("msgp")]),_._v(" меньше нуля, то из очереди берется первое сообщение со значением, меньшим, чем абсолютное значение "),v("em",[_._v("msgp")]),_._v(".")]),_._v(" "),v("p",[_._v("#include <sys/types.h> #include <sys/ipc.h> #include <sys/msg.h>")]),_._v(" "),v("p",[_._v("int msgget(key_t key, int msgflg); int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);")]),_._v(" "),v("p",[_._v("struct msgbuf { long mtype; /* message type, must be > 0 "),v("em",[_._v("/ char mtext[1]; /")]),_._v(" message data */ };")]),_._v(" "),v("p",[_._v("int msgctl(int msqid, int cmd, struct msqid_ds *buf);")])])]),_._v(" "),v("h2",{attrs:{id:"семафоры"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#семафоры"}},[_._v("#")]),_._v(" Семафоры")]),_._v(" "),v("p",[_._v("Каждый семафор IPC представляет собой набор из одного или нескольких целочисленных счётчиков. Таким образом один семафор может защищать несколько объектов. Обычно, нулевое значение счётчика означает, что объект свободен, положительное - занят, но можно договориться о других значениях. Механизм семафоров ничего не знает про их использование, а только обеспечивает атомарные операции изменения значений.")]),_._v(" "),v("p",[_._v("Существуют ограничения как на количество семафоров (по умолчанию 128), так и на количество счётчиков внутри одного семафора (по умолчанию 250). Эти данные в "),v("em",[_._v("Linux")]),_._v(" доступны в "),v("em",[_._v("/proc/sys/kernel/sem")]),_._v(".")]),_._v(" "),v("p",[_._v("При завершении процесса все операции, которые он проводил над семафорами сбрасываются, что позволяет избежать неприятностей в случае краха процесса, изменившего значения счётчиков.")]),_._v(" "),v("p",[_._v("Операции над семафорами в вызове "),v("em",[_._v("semop()")]),_._v(":")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Если величина "),v("em",[_._v("sembuf[n].semop")]),_._v(" положительна, то текущее значение счётчика "),v("em",[_._v("n")]),_._v(" увеличивается на эту величину.")])]),_._v(" "),v("li",[v("p",[_._v("Если значение "),v("em",[_._v("sembuf[n].semop")]),_._v(" равно нулю, процесс ожидает, пока счётчик "),v("em",[_._v("n")]),_._v(" не обнулится.")])]),_._v(" "),v("li",[v("p",[_._v("Если величина "),v("em",[_._v("sembuf[n].semop")]),_._v(" отрицательна, процесс ожидает, пока значение счётчика "),v("em",[_._v("n")]),_._v(" не станет большим или равным абсолютной величине "),v("em",[_._v("sembuf.semop")]),_._v(". Затем абсолютная величина "),v("em",[_._v("sembuf[n].semop")]),_._v(" вычитается из значения счётчика "),v("em",[_._v("n")]),_._v(".")]),_._v(" "),v("p",[_._v("#include <sys/types.h> #include <sys/ipc.h> #include <sys/sem.h>")]),_._v(" "),v("p",[_._v("int semget(key_t key, int nsems, int semflg); int semop(int semid, struct sembuf *sops, unsigned nsops);")]),_._v(" "),v("p",[_._v("struct sembuf { unsigned short sem_num; /* semaphore number "),v("em",[_._v("/ short sem_op; /")]),_._v(" semaphore operation "),v("em",[_._v("/ short sem_flg; /")]),_._v(" operation flags */ }")]),_._v(" "),v("p",[_._v("int semctl(int semid, int semnum, int cmd, ...);")])])]),_._v(" "),v("h2",{attrs:{id:"общая-память"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#общая-память"}},[_._v("#")]),_._v(" Общая память")]),_._v(" "),v("p",[_._v("Вызов "),v("em",[_._v("shmget()")]),_._v(" резервирует участок физической памяти (фала подкачки)")]),_._v(" "),v("p",[_._v("Вызов "),v("em",[_._v("shmat()")]),_._v(" ("),v("em",[_._v("attach")]),_._v(") отображает зарезервированный участок физической памяти в виртуальное адресное пространство процесса.")]),_._v(" "),v("p",[_._v("Вызов "),v("em",[_._v("shmdt()")]),_._v(" ("),v("em",[_._v("detach")]),_._v(") разрывает связь между зарезервированным участок физической памяти и виртуальным адресным пространством процесса.")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("   #include <sys/ipc.h>\n   #include <sys/shm.h>\n\n   int shmget(key_t key, size_t size, int shmflg);\n   void *shmat(int shmid, const void *shmaddr, int shmflg);\n   int shmdt(const void *shmaddr);\n   int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n")])])]),v("h1",{attrs:{id:"утилиты-команднои-строки"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#утилиты-команднои-строки"}},[_._v("#")]),_._v(" Утилиты командной строки")]),_._v(" "),v("p",[_._v("Просмотр информации о подсистеме "),v("em",[_._v("System V IPC")])]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("lsipc\n")])])]),v("p",[_._v("Создание объекта")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("# Допустимые опции\n# -Q - создание очереди\n# -M size - создание разделяемой памяти\n# -S number - создание семафора\nipcmk -Q  \n")])])]),v("p",[_._v("Просмотр объектов")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("ipcs\n")])])]),v("p",[_._v("Удаление объектов")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("ipcrm --shmem-id 9601039\nipcrm --all\n")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);