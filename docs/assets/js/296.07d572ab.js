(window.webpackJsonp=window.webpackJsonp||[]).push([[296],{566:function(e,t,a){"use strict";a.r(t);var n=a(14),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/book/arrays-vectors-and-slices.html")]),e._v(" "),t("p",[e._v("Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the "),t("em",[e._v("array")]),e._v(", a fixed-size list of elements of the same type. By default, arrays are immutable.")]),e._v(" "),t("p",[e._v("let a = [1, 2, 3]; // a: [i32; 3]\nlet mut m = [1, 2, 3]; // mut m: [i32; 3]")]),e._v(" "),t("p",[e._v("There's a shorthand for initializing each element of an array to the same value. In this example, each element of "),t("code",[e._v("a")]),e._v(" will be initialized to "),t("code",[e._v("0")]),e._v(":")]),e._v(" "),t("p",[e._v("let a = [0; 20]; // a: [i32; 20]")]),e._v(" "),t("p",[e._v("Arrays have type "),t("code",[e._v("[T; N]")]),e._v(". We'll talk about this "),t("code",[e._v("T")]),e._v(" notation later, when we cover generics.")]),e._v(" "),t("p",[e._v("You can get the number of elements in an array "),t("code",[e._v("a")]),e._v(" with "),t("code",[e._v("a.len()")]),e._v(", and use "),t("code",[e._v("a.iter()")]),e._v(" to iterate over them with a for loop. This code will print each number in order:")]),e._v(" "),t("p",[e._v("let a = [1, 2, 3];")]),e._v(" "),t("p",[e._v('println!("a has {} elements", a.len());\nfor e in a.iter() {\nprintln!("{}", e);\n}')]),e._v(" "),t("p",[e._v("You can access a particular element of an array with "),t("em",[e._v("subscript notation")]),e._v(":")]),e._v(" "),t("p",[e._v('let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]')]),e._v(" "),t("p",[e._v('println!("The second name is: {}", names[1]);')]),e._v(" "),t("p",[e._v("Subscripts start at zero, like in most programming languages, so the first name is "),t("code",[e._v("names[0]")]),e._v(" and the second name is "),t("code",[e._v("names[1]")]),e._v(". The above example prints "),t("code",[e._v("The second name is: Brian")]),e._v(". If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.")]),e._v(" "),t("p",[e._v("A "),t("em",[e._v("vector")]),e._v(' is a dynamic or "growable" array, implemented as the standard library type '),t("a",{attrs:{href:"https://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/std/vec/index.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("Vec<T>")]),t("OutboundLink")],1),e._v(" (we'll talk about what the "),t("code",[e._v("<T>")]),e._v(" means later). Vectors always allocate their data on the heap. Vectors are to slices what "),t("code",[e._v("String")]),e._v(" is to "),t("code",[e._v("&str")]),e._v(". You can create them with the "),t("code",[e._v("vec!")]),e._v(" macro:")]),e._v(" "),t("p",[e._v("let v = vec![1, 2, 3]; // v: Vec"),t("i32")],1),e._v(" "),t("p",[e._v("(Notice that unlike the "),t("code",[e._v("println!")]),e._v(" macro we've used in the past, we use square brackets "),t("code",[e._v("[]")]),e._v(" with "),t("code",[e._v("vec!")]),e._v(". Rust allows you to use either in either situation, this is just convention.)")]),e._v(" "),t("p",[e._v("You can get the length of, iterate over, and subscript vectors just like arrays. In addition, (mutable) vectors can grow automatically:")]),e._v(" "),t("p",[e._v("let mut nums = vec![1, 2, 3]; // mut nums: Vec"),t("i32")],1),e._v(" "),t("p",[e._v("nums.push(4);")]),e._v(" "),t("p",[e._v('println!("The length of nums is now {}", nums.len()); // Prints 4')]),e._v(" "),t("p",[e._v("Vectors have many more useful methods.")]),e._v(" "),t("p",[e._v("A "),t("em",[e._v("slice")]),e._v(' is a reference to (or "view" into) an array. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference just one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable. Slices have a length, can be mutable or not, and in many ways behave like arrays:')]),e._v(" "),t("p",[e._v("let a = [0, 1, 2, 3, 4];\nlet middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3")]),e._v(" "),t("p",[e._v('for e in middle.iter() {\nprintln!("{}", e); // Prints 1, 2, 3\n}')]),e._v(" "),t("p",[e._v("You can also take a slice of a vector, "),t("code",[e._v("String")]),e._v(", or "),t("code",[e._v("&str")]),e._v(", because they are backed by arrays. Slices have type "),t("code",[e._v("&[T]")]),e._v(", which we'll talk about when we cover generics.")]),e._v(" "),t("p",[e._v("We have now learned all of the most basic Rust concepts. We're ready to start building ourselves a guessing game, we just need to know one last thing: how to get input from the keyboard. You can't have a guessing game without the ability to guess!")])])}),[],!1,null,null,null);t.default=s.exports}}]);