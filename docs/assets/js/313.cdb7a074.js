(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{585:function(e,t,n){"use strict";n.r(t);var a=n(14),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://xnuter.medium.com/writing-a-modern-http-s-tunnel-in-rust-56e70d898700")]),e._v(" "),t("h1",{attrs:{id:"writing-a-modern-http-s-tunnel-in-rust"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writing-a-modern-http-s-tunnel-in-rust"}},[e._v("#")]),e._v(" Writing a Modern HTTP(S) Tunnel in Rust.")]),e._v(" "),t("h2",{attrs:{id:"a-step-by-step-guide-on-how-to-create-an-async-i-o-app-in-rust"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-step-by-step-guide-on-how-to-create-an-async-i-o-app-in-rust"}},[e._v("#")]),e._v(" A step-by-step guide on how to create an async I/O app in Rust.")]),e._v(" "),t("h2",{attrs:{id:"overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),t("p",[e._v("This post is for anyone interested in writing performant and safe applications in Rust quickly. It walks the reader through designing and implementing an HTTP Tunnel and basic, language-agnostic, principles of creating robust, scalable, observable, and evolvable network applications.")]),e._v(" "),t("h2",{attrs:{id:"rust-performance-reliability-productivity-pick-three"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rust-performance-reliability-productivity-pick-three"}},[e._v("#")]),e._v(" Rust: performance, reliability, productivity. Pick three.")]),e._v(" "),t("p",[e._v("About a year ago, I started to learn Rust. The first two weeks were quite painful. Nothing compiled, I didn’t know how to do basic operations, I couldn’t make a simple program run. But step by step, I started to understand what the compiler wanted. Even more, I realized that it forces the right thinking and correct behaviour.")]),e._v(" "),t("p",[e._v("Yes, sometimes, you have to write seemingly redundant constructs. But it’s better not to compile a correct program than to compile an incorrect one. This makes making mistakes more difficult.")]),e._v(" "),t("p",[e._v("Anyway, soon after, I became more or less productive and finally could do what I wanted. Well, most of the time.")]),e._v(" "),t("p",[e._v("Recently out of curiosity, I decided to take on a slightly more complex challenge: implement an "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/HTTP_tunnel",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP Tunnel"),t("OutboundLink")],1),e._v(" in Rust. It turned out to be surprisingly easy to do and took about a day, which is quite impressive. Basically, I stitched together "),t("a",{attrs:{href:"https://tokio.rs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("tokio"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://github.com/clap-rs/clap",target:"_blank",rel:"noopener noreferrer"}},[e._v("clap"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://serde.rs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("serde"),t("OutboundLink")],1),e._v(", and several other very useful crates. Okay, enough of the introduction. Let me share the knowledge I gained during this exciting challenge and elaborate on why I organized the app this way. I hope you’ll enjoy it.")]),e._v(" "),t("h1",{attrs:{id:"what-is-an-http-tunnel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-is-an-http-tunnel"}},[e._v("#")]),e._v(" What is an HTTP Tunnel?")]),e._v(" "),t("p",[e._v("Simply put, it’s a lightweight VPN that you can set up with your browser so your Internet provider cannot block or track your activity, and web-servers won’t see your IP address.")]),e._v(" "),t("p",[e._v("If you’d like, you can test it with your browser locally, e.g., with Firefox (otherwise just skip this section for now).")]),e._v(" "),t("ol",[t("li",[e._v("Install the app using "),t("a",{attrs:{href:"https://doc.rust-lang.org/cargo/getting-started/installation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("cargo"),t("OutboundLink")],1),e._v(":")])]),e._v(" "),t("p",[e._v("$ cargo install http-tunnel")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Start:")])]),e._v(" "),t("p",[e._v("$ http-tunnel --bind 0.0.0.0:8080 http")]),e._v(" "),t("p",[e._v("You can also check the http-tunnel GitHub "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel",target:"_blank",rel:"noopener noreferrer"}},[e._v("repository"),t("OutboundLink")],1),e._v(" for build/installation instructions.")]),e._v(" "),t("p",[e._v("Now you can go to your browser and set the "),t("code",[e._v("HTTP Proxy")]),e._v(" to "),t("code",[e._v("localhost:8080")]),e._v(". For instance, in "),t("a",{attrs:{href:"https://support.mozilla.org/en-US/kb/connection-settings-firefox",target:"_blank",rel:"noopener noreferrer"}},[e._v("Firefox"),t("OutboundLink")],1),e._v(" just search for "),t("code",[e._v("proxy")]),e._v(" in the preferences section:")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:700/1*3JVz5hArvpZz3T0p6diBew.png",alt:""}})]),e._v(" "),t("p",[e._v("Finding the proxy settings")]),e._v(" "),t("p",[e._v("and then specify it for "),t("code",[e._v("HTTP Proxy")]),e._v(" and also check it for "),t("code",[e._v("HTTPS:")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:700/1*77Tn80rhPu5ItAeVoLkOSw.png",alt:""}})]),e._v(" "),t("p",[e._v("Setting the proxy to just built "),t("code",[e._v("http_tunnel")])]),e._v(" "),t("p",[e._v("You can visit several web-pages and check the "),t("code",[e._v("./logs/application.log")]),e._v(" file — all your traffic was going via the tunnel. For example:")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:700/1*QOVnG7P0N7YGO8z3qOQG9A.png",alt:""}})]),e._v(" "),t("p",[e._v("Okay, let’s walk through the process from the beginning.")]),e._v(" "),t("h1",{attrs:{id:"design-the-app"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#design-the-app"}},[e._v("#")]),e._v(" Design the app")]),e._v(" "),t("p",[e._v("Each application starts with design, which means we need to define the following:")]),e._v(" "),t("ol",[t("li",[e._v("Functional requirements.")]),e._v(" "),t("li",[e._v("Non-functional requirements.")]),e._v(" "),t("li",[e._v("Application abstractions and components.")])]),e._v(" "),t("h2",{attrs:{id:"step-1-functional-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-1-functional-requirements"}},[e._v("#")]),e._v(" Step 1. Functional requirements")]),e._v(" "),t("p",[e._v("We need to follow the specification outlined here: "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/HTTP_tunnel",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://en.wikipedia.org/wiki/HTTP_tunnel"),t("OutboundLink")],1),e._v(" :")]),e._v(" "),t("p",[e._v("Negotiate target with an "),t("code",[e._v("HTTP CONNECT")]),e._v(" request. E.g., if the client wants to create a tunnel to "),t("a",{attrs:{href:"http://www.wikipedia.org%2C/",target:"_blank",rel:"noopener noreferrer"}},[e._v("www.wikipedia.org,"),t("OutboundLink")],1),e._v(" the request will look like:")]),e._v(" "),t("p",[e._v("CONNECT www.wikipedia.org:443 HTTP/1.1"),t("br"),e._v("\n...")]),e._v(" "),t("p",[e._v("followed by a response, e.g.")]),e._v(" "),t("p",[e._v("HTTP/1.1 200 OK")]),e._v(" "),t("p",[e._v("After this point, just relay TCP traffic both ways until one of the sides closes it, or an I/O error happens.")]),e._v(" "),t("p",[e._v("The HTTP Tunnel should work for both HTTP and HTTPS.")]),e._v(" "),t("p",[e._v("We also should be able to manage access/block targets (e.g., to block-list trackers).")]),e._v(" "),t("h2",{attrs:{id:"step-2-non-functional-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-2-non-functional-requirements"}},[e._v("#")]),e._v(" Step 2. Non-functional requirements")]),e._v(" "),t("p",[e._v("The service shouldn’t log any information that identifies users.")]),e._v(" "),t("p",[e._v("It should have high throughput and low-latency (it should be unnoticeable for users and relatively cheap to run).")]),e._v(" "),t("p",[e._v("Ideally, we want it to be resilient to traffic spikes, provide noisy neighbor isolation, and resist basic DDoS attacks.")]),e._v(" "),t("p",[e._v("Error messaging should be developer-friendly. We want the system to be observable to troubleshoot and tune it in production at a massive scale.")]),e._v(" "),t("h2",{attrs:{id:"step-3-components"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step-3-components"}},[e._v("#")]),e._v(" Step 3. Components")]),e._v(" "),t("p",[e._v("When designing components, we need to first breakdown the app to a set of responsibilities. First, let’s see how our flow diagram looks like:")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:484/1*4zycGeu6OZxf1AucAnqG8A.png",alt:""}})]),e._v(" "),t("p",[e._v("To implement this, we can introduce the following main components:")]),e._v(" "),t("ol",[t("li",[e._v("TCP/TLS Acceptor")]),e._v(" "),t("li",[e._v("HTTP CONNECT Negotiator")]),e._v(" "),t("li",[e._v("Target Connector")]),e._v(" "),t("li",[e._v("Full-Duplex Relay")])]),e._v(" "),t("h1",{attrs:{id:"implementation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),t("h2",{attrs:{id:"tcp-tls-acceptor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-tls-acceptor"}},[e._v("#")]),e._v(" TCP/TLS Acceptor")]),e._v(" "),t("p",[e._v("When we roughly know how to organize the app, it’s time to decide which dependencies we should use. For Rust, the best I/O library I know is "),t("a",{attrs:{href:"https://crates.io/crates/tokio",target:"_blank",rel:"noopener noreferrer"}},[e._v("tokio"),t("OutboundLink")],1),e._v(". In the "),t("code",[e._v("tokio")]),e._v(" family, there are many libraries, including "),t("code",[e._v("tokio-tls")]),e._v(", which makes things much simpler. So the "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/main.rs#L127-L148",target:"_blank",rel:"noopener noreferrer"}},[e._v("TCP acceptor code"),t("OutboundLink")],1),e._v(" would look like:")]),e._v(" "),t("p",[e._v("And then the whole acceptor loop + launching asynchronous connection handlers would be:")]),e._v(" "),t("p",[e._v("Let’s break down what’s happening "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/30b1a69db0171c5aa8834feb9d27612b6c8fac2f/src/main.rs#L132-L146",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(". We accept a connection. If the operation was successful, use "),t("code",[e._v("tokio::spawn")]),e._v(" to create a new task that will handle that connection. Memory/thread-safety management happens behind the scenes. Handling futures is hidden by "),t("code",[e._v("async/await")]),e._v(" syntax sugar.")]),e._v(" "),t("p",[e._v("However, there is one question. "),t("code",[e._v("TcpStream")]),e._v(" and "),t("code",[e._v("TlsStream")]),e._v(" are different objects, but handling both is precisely the same. Can we re-use the same code? In Rust, abstraction is achieved via "),t("code",[e._v("Traits")]),e._v(", which are super handy:")]),e._v(" "),t("p",[e._v("The stream must implement:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("AsyncRead /Write")]),e._v("— so we can read/write it "),t("a",{attrs:{href:"https://xnuter.medium.com/distributed-systems-and-asynchronous-i-o-ef0f27655ce5",target:"_blank",rel:"noopener noreferrer"}},[e._v("asynchronously"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("code",[e._v("Send")]),e._v("— to be able to send between threads")]),e._v(" "),t("li",[t("code",[e._v("Unpin")]),e._v("— to be moveable (otherwise we won’t be able to do "),t("code",[e._v("async move")]),e._v(" and "),t("code",[e._v("tokio::spawn")]),e._v(" to create an "),t("code",[e._v("async")]),e._v(" task)")]),e._v(" "),t("li",[t("code",[e._v("'static")]),e._v(" —to denote that it may live until application shutdown and doesn’t depend on any other object’s destruction.")])]),e._v(" "),t("p",[e._v("Which our "),t("code",[e._v("TCP/TLS")]),e._v(" streams exactly are. However, now we can see that it doesn’t have to be "),t("code",[e._v("TCP/TLS")]),e._v(" streams. This code would work for "),t("code",[e._v("UDP")]),e._v(" or "),t("code",[e._v("QUIC")]),e._v(" or "),t("code",[e._v("ICMP")]),e._v(". I.e., it can wrap any protocol within any other protocol, or itself."),t("br"),e._v("\nIn other words, this code is reusable, extendable, and ready for migration (which happens sooner or later).")]),e._v(" "),t("h2",{attrs:{id:"http-connect-negotiator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-connect-negotiator"}},[e._v("#")]),e._v(" HTTP Connect Negotiator")]),e._v(" "),t("p",[e._v("Let’s pause for a second and think at a higher level. What if we can abstract from HTTP Tunnel, and just need to implement a generic tunnel?")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:420/1*85IWIDW1NIIkFYT6LXG_Uw.png",alt:""}})]),e._v(" "),t("ol",[t("li",[e._v("We need to establish some transport-level connections (L4).")]),e._v(" "),t("li",[e._v("Negotiate a target (doesn’t really matter how: HTTP, PPv2, etc.).")]),e._v(" "),t("li",[e._v("Establish an L4 connection to the target.")]),e._v(" "),t("li",[e._v("Report success and start relaying data.")])]),e._v(" "),t("p",[e._v("A target could be, for instance, another tunnel. Also, we can support different protocols. The core would stay the same.")]),e._v(" "),t("p",[e._v("We already saw that "),t("code",[e._v("tunnel_stream")]),e._v(" method already works with any L4 "),t("code",[e._v("Client<->Tunnel")]),e._v(" connection.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/proxy_target.rs#L27-L37",target:"_blank",rel:"noopener noreferrer"}},[e._v("Here"),t("OutboundLink")],1),e._v(", we specify two abstractions:")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("TunnelTarget")]),e._v(" is just something that has an "),t("code",[e._v("Addr")]),e._v(" — whatever it is.")]),e._v(" "),t("li",[t("code",[e._v("TargetConnector")]),e._v(" — can connect to that "),t("code",[e._v("Addr")]),e._v(" and needs to return a stream that supports async I/O.")])]),e._v(" "),t("p",[e._v("Okay, but what about the target negotiation? The "),t("code",[e._v("tokio-utils")]),e._v(" crate already has an abstraction for that, named "),t("code",[e._v("Framed")]),e._v(" streams (with corresponding "),t("code",[e._v("Encoder/Decoder")]),e._v(" traits). We need to implement them for "),t("code",[e._v("HTTP CONNECT")]),e._v(" (or any other proxy protocol). You can find the implementation "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/30b1a69db0171c5aa8834feb9d27612b6c8fac2f/src/http_tunnel_codec.rs#L48-L102",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"relay"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relay"}},[e._v("#")]),e._v(" Relay")]),e._v(" "),t("p",[e._v("We only have one major component remaining — that which relays data after the tunnel negotiation is done. "),t("code",[e._v("tokio")]),e._v(" provides a method to split a stream into two halves: "),t("code",[e._v("ReadHalf")]),e._v(" and "),t("code",[e._v("WriteHalf")]),e._v(". We can split both client and target connections and "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/tunnel.rs#L137-L164",target:"_blank",rel:"noopener noreferrer"}},[e._v("relay"),t("OutboundLink")],1),e._v(" them in both directions:")]),e._v(" "),t("p",[e._v("Where the "),t("code",[e._v("relay_data(…)")]),e._v(" definition requires nothing more than implementing abstractions mentioned above. I.e., it can connect any two halves of a stream:")]),e._v(" "),t("p",[e._v("And finally, instead of a simple HTTP Tunnel, we have an "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/main.rs#L186-L223",target:"_blank",rel:"noopener noreferrer"}},[e._v("engine"),t("OutboundLink")],1),e._v(" that can be used to build any type of tunnels or a chain of tunnels (e.g., for onion routing), over any transport and proxy protocols:")]),e._v(" "),t("p",[e._v("The "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/tunnel.rs#L121-L172",target:"_blank",rel:"noopener noreferrer"}},[e._v("implementation"),t("OutboundLink")],1),e._v(" is almost trivial in basic cases, but we want our app to handle failures, and that’s the focus of the next section.")]),e._v(" "),t("h1",{attrs:{id:"dealing-with-failures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dealing-with-failures"}},[e._v("#")]),e._v(" Dealing with failures")]),e._v(" "),t("p",[e._v("The amount of time engineers deal with failures is proportional to the scale of a system. It’s easy to write happy-case code. Still, if it enters an irrecoverable state on the very first error, it’s painful to use. Besides that, your app will be used by other engineers, and there are very few things more irritating than cryptic/misleading error messages. If your code runs as a part of a large service, some people need to monitor and support it (e.g., SREs or DevOps), and it should be a pleasure for them to deal with your service.")]),e._v(" "),t("p",[e._v("What kind of failures may an HTTP Tunnel encounter?")]),e._v(" "),t("p",[e._v("It’s a good idea to enumerate all error codes that your app returns to the client. So it’s clear why a request failed if the operation can be tried again (or shouldn’t), if it’s an integration bug or just network noise.")]),e._v(" "),t("p",[e._v("Dealing with delays is crucial for a network app. If your operations don’t have timeouts, it’s a matter of time until all of your threads will be "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Waiting_for_Godot",target:"_blank",rel:"noopener noreferrer"}},[e._v("Waiting for Godot"),t("OutboundLink")],1),e._v(", or your app will exhaust all available resources and become unavailable. Here we delegate timeout definition to "),t("code",[e._v("RelayPolicy")]),e._v(":")]),e._v(" "),t("p",[e._v("Relay policy can be configured like this:")]),e._v(" "),t("p",[e._v("relay_policy:"),t("br"),e._v("\nidle_timeout: 10s"),t("br"),e._v("\nmin_rate_bpm: 1000"),t("br"),e._v("\nmax_rate_bps: 10000"),t("br"),e._v("\nmax_lifetime_:_ 100s  max_total_payload_:_ 100mb")]),e._v(" "),t("p",[e._v("So we can limit activity per connection with "),t("code",[e._v("max_rate_bps")]),e._v(" and detecting idle clients with "),t("code",[e._v("min_rate_bpm")]),e._v(" (so they don’t consume system resources than can be utilized more productively). A connection lifetime and total traffic may be bounded as well.")]),e._v(" "),t("p",[e._v("It goes without saying that each failure mode needs to be "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/relay.rs#L389-L536",target:"_blank",rel:"noopener noreferrer"}},[e._v("tested"),t("OutboundLink")],1),e._v(". It’s straightforward to do that in Rust in general and with "),t("code",[e._v("tokio-test")]),e._v(" in particular:")]),e._v(" "),t("p",[e._v("The same goes for I/O errors:")]),e._v(" "),t("h2",{attrs:{id:"logging-and-metrics"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#logging-and-metrics"}},[e._v("#")]),e._v(" Logging and metrics")]),e._v(" "),t("p",[e._v("I haven’t seen an application that failed only in ways anticipated by its developers. I’m not saying there are no such applications. Still, chances are that your app is going to encounter something you didn’t expect: data races, specific traffic patterns, dealing with traffic bursts, legacy clients.")]),e._v(" "),t("p",[e._v("But probably one of the most common types of failures is human failures, such as pushing bad code or configuration, which are inevitable in large projects. Anyway, we need to be able to deal with something we didn’t foresee. So we emit enough information that would allow us to detect failures and troubleshoot.")]),e._v(" "),t("p",[e._v("So we’d better log every error and important events with meaningful information and relevant context as well as statistics.")]),e._v(" "),t("p",[e._v("Please note the "),t("code",[e._v("tunnel_ctx: TunnelCtx")]),e._v(" field, which can be used to correlate metric records with log messages:")]),e._v(" "),t("p",[e._v("error!("),t("br"),e._v('\n"{} failed to write {} bytes. Err = {:?}, '),t("strong",[e._v("CTX={}")]),e._v('",'),t("br"),e._v("\nself.name, n, e, "),t("strong",[e._v("self.tunnel_ctx")]),t("br"),e._v("\n);")]),e._v(" "),t("h1",{attrs:{id:"configuration-and-parameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configuration-and-parameters"}},[e._v("#")]),e._v(" Configuration and parameters")]),e._v(" "),t("p",[e._v("Last but not least. We’d like to be able to run our tunnel in different modes with different parameters. Here’s where "),t("code",[e._v("serde")]),e._v(" and "),t("code",[e._v("clap")]),e._v(" become handy.")]),e._v(" "),t("p",[e._v("In my opinion, "),t("code",[e._v("clap")]),e._v(" makes "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/configuration.rs#L59",target:"_blank",rel:"noopener noreferrer"}},[e._v("dealing with command line parameters"),t("OutboundLink")],1),e._v(" pleasant. Extraordinarily expressive and easy to maintain.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/master/config/config.yaml",target:"_blank",rel:"noopener noreferrer"}},[e._v("Configuration"),t("OutboundLink")],1),e._v(" files can be easily handled with "),t("code",[e._v("serde-yaml")]),e._v(":")]),e._v(" "),t("p",[e._v("target_connection:"),t("br"),e._v("\ndns_cache_ttl: 60s"),t("br"),e._v('\nallowed_targets: "(?i)(wikipedia|rust-lang)\\.org:443$"'),t("br"),e._v("\nconnect_timeout: 10s"),t("br"),e._v("\nrelay_policy:"),t("br"),e._v("\nidle_timeout: 10s"),t("br"),e._v("\nmin_rate_bpm: 1000"),t("br"),e._v("\nmax_rate_bps: 10000")]),e._v(" "),t("p",[e._v("Which just corresponds to Rust "),t("a",{attrs:{href:"https://github.com/xnuter/http-tunnel/blob/997570b8a2b237cd9d55562780c053c91b596d5f/src/configuration.rs#L18-L40",target:"_blank",rel:"noopener noreferrer"}},[e._v("structs"),t("OutboundLink")],1),e._v(":")]),e._v(" "),t("p",[e._v("It doesn’t need any additional comments to make it readable and maintainable, and that is beautiful.")]),e._v(" "),t("h1",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),t("p",[e._v("As you could see from this quick overview, the Rust ecosystem already provides many building blocks so you can focus on "),t("em",[e._v("what")]),e._v(" you need to do rather than "),t("em",[e._v("how")]),e._v(". You didn’t see any memory/resources management or explicit thread-safety (which often comes at the expense of concurrency) with impressive "),t("a",{attrs:{href:"https://github.com/xnuter/perf-gauge/wiki/Benchmarking-TCP-Proxies-written-in-different-languages:-C,-CPP,-Rust,-Golang,-Java,-Python",target:"_blank",rel:"noopener noreferrer"}},[e._v("performance"),t("OutboundLink")],1),e._v(". Abstraction mechanisms are fantastic, so your code can be highly reusable. This task was a lot of fun, so I’ll try to take on the next challenge.")])])}),[],!1,null,null,null);t.default=r.exports}}]);