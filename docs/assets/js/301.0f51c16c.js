(window.webpackJsonp=window.webpackJsonp||[]).push([[301],{573:function(t,e,a){"use strict";a.r(e);var s=a(14),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("https://oswalt.dev/2021/06/polymorphism-in-rust/")]),t._v(" "),e("p",[t._v("In the "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/using-generic-types-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[t._v("previous post"),e("OutboundLink")],1),t._v(" we explored the use of generic types in Rust and some of the common reasons for doing so. In this post, I’d like to take a step back and look at the full spectrum of options Rust makes available for accomplishing polymorphism, and get under the covers so we fully understand the tradeoffs of the decisions we make as Rust developers.")]),t._v(" "),e("h1",{attrs:{id:"rust-s-polymorphic-choice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rust-s-polymorphic-choice"}},[t._v("#")]),t._v(" Rust’s Polymorphic Choice "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#rusts-polymorphic-choice",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("If you’re reading this post, you’ve almost certainly heard of the term “polymorphism”. In my own words, polymorphism gives us the ability to present a single interface for potentially many different concrete types. This allows us to create more flexible APIs which give more control to the consumer and are easier to maintain.")]),t._v(" "),e("p",[t._v("There are several practical advantages to using polymorphism, but one of the biggest is code re-use. If you design an API around specific, concrete types, then you’re committed to that approach, and so are your consumers.")]),t._v(" "),e("p",[t._v("As an example - if we wrote a function that requires a type - "),e("code",[t._v("Lion")]),t._v(" as a parameter, we’re bound to that decision strictly. If we wanted to have similar functionality, but for other types, we’d have to create additional functions to accept those types. This results in a lot of unnecessarily duplicate code, which becomes difficult to maintain.")]),t._v(" "),e("p",[t._v("Instead, polymorphism allows us to create functions that accept any type, as long as those types exhibit certain behaviors or properties that we need them to have. In this example, we can accept any concrete type as long as they implement a "),e("code",[t._v("growl()")]),t._v(" method.")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://oswalt.dev/assets/2021/06/with-without-polymorphism.png",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://oswalt.dev/assets/2021/06/with-without-polymorphism.png",alt:""}}),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("In this case, that "),e("strong",[t._v("behavior")]),t._v(" is actually all we care about, so we can leverage polymorphism to be more flexible, but maintain a set of required functionality. Through this, we can do things like write a single function that accepts multiple types.")]),t._v(" "),e("p",[t._v("This is the general idea behind why we would want to use polymorphism in any language, but what options for polymorphism exist in Rust? There are two primary ways, and both of these have trade-offs to consider when it comes to performance as well as binary size:")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("Static Dispatch")]),t._v(" - this approach leverages "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/using-generic-types-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[t._v("generics"),e("OutboundLink")],1),t._v(" (also called parametric polymorphism) and (usually) "),e("a",{attrs:{href:"https://oswalt.dev/2020/07/rust-traits-defining-behavior#traits-as-parameters-and-the-trait-bound-syntax",target:"_blank",rel:"noopener noreferrer"}},[t._v("trait bounds"),e("OutboundLink")],1),t._v(" to provide the flexibility we need while still maintaining full type safety, and without requiring a lot of duplicate code. This approach is extremely performant (in Rust this is known as a “zero-cost abstraction”) - however, "),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics",target:"_blank",rel:"noopener noreferrer"}},[t._v("due to monomorphization"),e("OutboundLink")],1),t._v(", this does create a larger binary size.")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("Dynamic Dispatch")]),t._v(" - this approach uses “"),e("a",{attrs:{href:"https://oswalt.dev/2020/07/rust-traits-defining-behavior#rust-polymorphism-using-trait-objects",target:"_blank",rel:"noopener noreferrer"}},[t._v("trait objects"),e("OutboundLink")],1),t._v("” to punt the decision of which type is required to satisfy some kind of polymorphic interface to runtime. This cuts down on binary size (as no monomorphization is used here) but incurs a performance penalty due to the extra lookup at runtime. This approach also "),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects",target:"_blank",rel:"noopener noreferrer"}},[t._v("explicitly forbids the use of generics"),e("OutboundLink")],1),t._v(".")])])]),t._v(" "),e("p",[t._v("While there are other reasons to pick one approach or the other - such as readability - in general, you can think of this decision as a trade-off between binary size and performance. If you can tolerate a slightly larger binary size but performance is important, the static approach is probably your best bet. For others who don’t need maximum performance but binary size is critical (embedded systems would be a likely example), the dynamic approach is likely preferable.")]),t._v(" "),e("p",[t._v("What’s more interesting to me personally is that Rust is the first language I’ve used that gives this choice. Languages that don’t have generics force the developer to either write a bunch of duplicate code to get the benefits of the “static” approach, or take the performance hit caused by the “dynamic” approach. I know there are other languages that give this choice (C++ is one of them), but the way this is done in Rust is really nice.")]),t._v(" "),e("p",[t._v("It is this choice that I want to drill into more deeply.")]),t._v(" "),e("blockquote",[e("p",[t._v("EDIT: "),e("a",{attrs:{href:"https://www.reddit.com/r/rust/comments/o5qm8l/polymorphism_in_rust_static_vs_dynamic_dispatch/h2o4qky/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A very helpful redditor"),e("OutboundLink")],1),t._v(" pointed out a few things to keep in mind when reading this blog post. The examples to follow were made by disabling inlining and building in “debug” mode, to make the learning experience a bit easier, but I didn’t do a good job of highlighting this choice. Building in release mode and allowing Rust to inline where needed will likely change the resulting program significantly.")])]),t._v(" "),e("h2",{attrs:{id:"the-growler-trait-and-its-implementations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-growler-trait-and-its-implementations"}},[t._v("#")]),t._v(" The “Growler” Trait and Its Implementations "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#the-growler-trait-and-its-implementations",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("For this post, I’ve created a trait called "),e("code",[t._v("Growler")]),t._v(" which enforces a single method implementation "),e("code",[t._v("growl()")]),t._v(" which has no parameters or return types. I’ve also created three types "),e("code",[t._v("Lion")]),t._v(", "),e("code",[t._v("Tiger")]),t._v(", and "),e("code",[t._v("Bear")]),t._v(" which have their own implementations of this trait. We will be using these three types to demonstrate the difference between static and dynamic dispatch:")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("trait")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Growler")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Lion")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Growler")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lion")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[inline(never)]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Lion says GROWL!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Tiger")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Growler")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Tiger")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[inline(never)]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Tiger says GROWL!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Bear")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Growler")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bear")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[inline(never)]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Bear says GROWL!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("Regardless of the method we explore below (static and dynamic), this code will remain the same. The difference between static or dynamic dispatch isn’t found in the declaration of this trait, or the types and methods that implement it, but how we use them in our Rust code, and more importantly how the two approaches actually work under the hood in our compiled program.")]),t._v(" "),e("h2",{attrs:{id:"static-dispatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static-dispatch"}},[t._v("#")]),t._v(" Static Dispatch "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#static-dispatch",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("As a refresher on "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/using-generic-types-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[t._v("generics in rust"),e("OutboundLink")],1),t._v(", we can leverage generics in a few places. When defining a function, we can define a generic type in the function signature, and then reference that type for one of the parameters:")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("static_dispatch")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Growler")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("As we learned previously, by defining the "),e("code",[t._v("Growler")]),t._v(" trait as a bound on the generic parameter "),e("code",[t._v("T")]),t._v(", whatever type that’s passed in must implement that trait. So, in our "),e("code",[t._v("main()")]),t._v(" function we can pass in our three concrete types, which we know all implement this trait:")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("static_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lion")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("static_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Tiger")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("static_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bear")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("This approach leverages the “static dispatch” approach, which makes use of “monomorphization” during compilation time to create multiple copies of our "),e("code",[t._v("static_dispatch")]),t._v(" function - one for every type that’s ever passed into it. This is the more efficient approach, since we can essentially bake in all our execution paths into the resulting program, without having to calculate this at runtime.")]),t._v(" "),e("p",[t._v("We can immediately see the signs of monomorphization by using "),e("code",[t._v("objdump")]),t._v(" to look at the instructions present in our compiled Rust program:")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("objdump "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--disassemble")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("polymorphism::main "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-S")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-C")]),t._v(" target/debug/polymorphism "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-EL")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-M")]),t._v(" intel --insn-width"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n\ntarget/debug/polymorphism:     "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("file")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("format")]),t._v(" elf64-x86-64\n\n0000000000005510 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::main"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(":\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5510")]),t._v(":       "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("83")]),t._v(" ec "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),t._v("                     sub    rsp,0x18\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5514")]),t._v(":       e8 "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("47")]),t._v(" fe ff ff                  call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5360")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::static_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5519")]),t._v(":       e8 "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" fe ff ff                  call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5330")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::static_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    551e:       e8 6d fe ff ff                  call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5390")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::static_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),e("p",[t._v("Our "),e("code",[t._v("static_dispatch")]),t._v(" function has no parameters, and calling it is the first thing we do in our "),e("code",[t._v("main()")]),t._v(" function, so the very first thing we see are three calls to the location of this function in memory. However, you’ll note that all three locations are different - 5360, 5330, and 5390. This is because they are actually three different functions - one for each of our concrete types.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0000000000005330 <polymorphism::static_dispatch>:\n    5330:       48 83 ec 18                     sub    rsp,0x18\n    5334:       48 89 e7                        mov    rdi,rsp\n    5337:       e8 34 01 00 00                  call   5470 <<polymorphism::Tiger as polymorphism::Growler>::growl>\n    ...\n\n0000000000005360 <polymorphism::static_dispatch>:\n    5360:       48 83 ec 18                     sub    rsp,0x18\n    5364:       48 89 e7                        mov    rdi,rsp\n    5367:       e8 b4 00 00 00                  call   5420 <<polymorphism::Lion as polymorphism::Growler>::growl>\n    ...\n\n0000000000005390 <polymorphism::static_dispatch>:\n    5390:       48 83 ec 18                     sub    rsp,0x18\n    5394:       48 89 e7                        mov    rdi,rsp\n    5397:       e8 24 01 00 00                  call   54c0 <<polymorphism::Bear as polymorphism::Growler>::growl>\n    ...\n")])])]),e("p",[t._v("The compiler took our single "),e("code",[t._v("static_dispatch")]),t._v(" function in Rust, and during compilation, created one instance for every concrete type that’s ever passed to it. Then, within each of these functions, it bakes in the call to the relevant method implementation, which is why you see a call to the three different types’ "),e("code",[t._v("growl()")]),t._v(" method in each.")]),t._v(" "),e("p",[t._v("It should now be obvious why the “static dispatch” approach results in a larger binary size - the compiler is able to perform all these pre-optimizations, but must store all the monomorphized code in the binary itself. However, our program is more efficient, since the decisions of which functions to call based on which types is all done at compile-time, not run-time. The Rust code we have to maintain is still as elegant and concise as we want.")]),t._v(" "),e("blockquote",[e("p",[t._v("By the way, this approach is not impacted at all performance-wise by the presence of a trait bound (in fact, the resulting compiled program is identical). This is still a zero-cost abstraction - the only difference is that the addition of trait bounds add compile-time checks for which concrete types can be used as a parameter to our function. If we were to pass in a type that didn’t implement the "),e("code",[t._v("Growler")]),t._v(" trait, our code would simply not compile.")])]),t._v(" "),e("p",[t._v("This is the core of what makes this “static” approach to polymorphism so powerful. We write concise code, and the compiler takes care of the rest to ensure that performance remains high.")]),t._v(" "),e("h2",{attrs:{id:"dynamic-dispatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-dispatch"}},[t._v("#")]),t._v(" Dynamic Dispatch "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#dynamic-dispatch",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Dynamic dispatch can be characterized as the opposite of static dispatch. Where static dispatch choses to create copies of all functions that use generic parameters and store these in the binary, dynamic dispatch choses to store only a single copy, but then calculates the necessary concrete implementation at runtime.")]),t._v(" "),e("p",[t._v("In Rust, this approach leverages “"),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch17-02-trait-objects.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Trait Objects"),e("OutboundLink")],1),t._v("” to achieve polymorphism. Unlike trait bounds, which is an optional constraint you can add to generic parameters, trait objects actually "),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects",target:"_blank",rel:"noopener noreferrer"}},[t._v("cannot be used with generics at all"),e("OutboundLink")],1),t._v(", and instead are the required method for "),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch",target:"_blank",rel:"noopener noreferrer"}},[t._v("performing dynamic dispatch in Rust"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("p",[t._v("The syntax for trait objects these days is characterized by the "),e("code",[t._v("dyn")]),t._v(" keyword, followed by the name of a Trait:")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("dynamic_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("dyn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Growler")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    t"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("growl")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("The "),e("code",[t._v("dyn")]),t._v(" keyword was introduced in Rust "),e("a",{attrs:{href:"https://blog.rust-lang.org/2018/06/21/Rust-1.27.html#dyn-trait",target:"_blank",rel:"noopener noreferrer"}},[t._v("1.27"),e("OutboundLink")],1),t._v(" and is now the idiomatic way to explicitly specify that you wish to use dynamic dispatch through trait objects. While it is still possible to imply the use of trait objects without this keyword at the time of this writing, it is officially deprecated and eventually you will have no option but to use this keyword in a future version of Rust.")]),t._v(" "),e("blockquote",[e("p",[t._v("Even though we’re not using generic parameters, the compiler still needs a little help to know the size of our types at compile-time. This is why you’ll commonly see trait bounds passed in via reference, as in the example above - but this can also be accomplished by wrapping the trait object in containers like "),e("code",[t._v("Box<dyn Growler>")]),t._v(", "),e("code",[t._v("Rc<dyn Growler>")]),t._v(" or "),e("code",[t._v("Arc<dyn Growler>")]),t._v(".")])]),t._v(" "),e("p",[t._v("We can then call these from the "),e("code",[t._v("main")]),t._v(" function by passing in references to each type:")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("dynamic_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lion")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("dynamic_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Tiger")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("dynamic_dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bear")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("Let’s take a look under the hood and see what the Rust compiler produced for these calls:")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("0000000000005510 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::main"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(":\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# "dynamic_dispatch" call with "Lion" type')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Populates "rax" with a pointer to 0x43558')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5523")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8d 05 2e e0 03 00        lea    rax,"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3e02e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43558")]),t._v("\n    552a:   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8b 0d ef "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("df")]),t._v(" 03 00        mov    rcx,QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3dfef"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43520")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5531")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" cf                    mov    rdi,rcx\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Moves pointer in "rax" into "rsi" register')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5534")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" c6                    mov    rsi,rax\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5537")]),t._v(":   e8 "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("44")]),t._v(" 00 00 00              call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5580")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::dynamic_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# "dynamic_dispatch" call with "Tiger" type')]),t._v("\n    553c:   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8d 05 "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("35")]),t._v(" e0 03 00        lea    rax,"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3e035"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43578")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5543")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8b 0d d6 "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("df")]),t._v(" 03 00        mov    rcx,QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3dfd6"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43520")]),t._v("\n    554a:   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" cf                    mov    rdi,rcx\n    554d:   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" c6                    mov    rsi,rax\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5550")]),t._v(":   e8 2b 00 00 00              call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5580")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::dynamic_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# "dynamic_dispatch" call with "Bear" type')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5555")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8d 05 3c e0 03 00        lea    rax,"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3e03c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43598")]),t._v("\n    555c:   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" 8b 0d bd "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("df")]),t._v(" 03 00        mov    rcx,QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rip+0x3dfbd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 43520")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5563")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" cf                    mov    rdi,rcx\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5566")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" c6                    mov    rsi,rax\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5569")]),t._v(":   e8 "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" 00 00 00              call   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5580")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::dynamic_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),e("p",[t._v("I’ve added some spacing above to make it easier to follow. In short, each section is responsible for making some calculations prior to calling the "),e("code",[t._v("dynamic_dispatch")]),t._v(" function, which will ultimately be used to determine which underlying concrete type and method is used.")]),t._v(" "),e("ul",[e("li",[t._v("The most important calculation is performed by the first instruction in each section, which loads a pointer ("),e("code",[t._v("lea")]),t._v(" instruction) into the "),e("code",[t._v("rax")]),t._v(" register. For example, the “Lion” section loads the location resulting from adding "),e("code",[t._v("rip + 0x3e02e")]),t._v(". Fortunately, the compiler gave us a helpful hint of what this results in - "),e("code",[t._v("0x43558")]),t._v(" (shown as a comment to the right). The Tiger section loads "),e("code",[t._v("0x43578")]),t._v(", and the Bear section loads "),e("code",[t._v("0x43598")]),t._v(". We’ll get into what these values mean in a little bit.")]),t._v(" "),e("li",[t._v("Then, on the fourth line, the contents of the "),e("code",[t._v("rax")]),t._v(" register (which contains the result of the first instruction) are copied into "),e("code",[t._v("rsi")]),t._v(".")]),t._v(" "),e("li",[t._v("Finally, on the final line of each section, you can see a call to the location 5580 - our "),e("code",[t._v("dynamic_dispatch")]),t._v(" function. All three sections call the same location - this is a stark contrast to what we saw in the static dispatch section, where each call was to a different memory location. This is a strong early clue that no monomorphization was used here!")])]),t._v(" "),e("p",[t._v("Next, lets take a look at our "),e("code",[t._v("dynamic_dispatch")]),t._v(" function. Unlike the section where we discussed static dispatch and “monomorphization”, we only find a single copy of this function in the compiled program:")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("0000000000005580 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("polymorphism::dynamic_dispatch"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(":\nfn dynamic_dispatch"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t: "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("dyn Growler"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5580")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("83")]),t._v(" ec "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),t._v("                 sub    rsp,0x18\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5584")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" 7c "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),t._v(" 08              mov    QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rsp+0x8"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(",rdi\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5589")]),t._v(":   "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("48")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("74")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("              mov    QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rsp+0x10"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(",rsi\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This is where the concrete type's method is called")]),t._v("\n    558e:   ff "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("56")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),t._v("                    call   QWORD PTR "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("rsi+0x18"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])])]),e("p",[t._v("The reason our "),e("code",[t._v("dynamic_dispatch")]),t._v(" function is able to appear once in the compiled program is because it’s designed to call a function at a "),e("strong",[t._v("calculated location")]),t._v(", specifically an offset based on whatever value is in the "),e("code",[t._v("rsi")]),t._v(" register. This is why our program does the hard work of calculating a pointer to the right location in memory, and placing it in "),e("code",[t._v("rsi")]),t._v(" up front, before the "),e("code",[t._v("dynamic_dispatch")]),t._v(" function is called.")]),t._v(" "),e("p",[t._v("So we know from the previous example that "),e("code",[t._v("rsi")]),t._v(" will contain "),e("code",[t._v("0x43558")]),t._v(" when our Lion type is used, "),e("code",[t._v("0x43578")]),t._v(" for Tiger, and "),e("code",[t._v("0x43598")]),t._v(" for Bear. But what do these values "),e("strong",[t._v("actually mean")]),t._v("? And why is the program adding "),e("code",[t._v("0x18")]),t._v(" to this value before calling the resulting memory location?")]),t._v(" "),e("p",[t._v("This gets us to the core of what a trait object actually is. In short, it’s a pointer. Specifically, it’s a pointer to portion of memory where a type’s bound methods can be found, as well as a few other things (like destructors). This is commonly referred to as a "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Virtual_method_table",target:"_blank",rel:"noopener noreferrer"}},[t._v("“virtual method table”"),e("OutboundLink")],1),t._v(", or “vtable”.")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p",title:"(with modifications) Copyright 2017 Google Inc., released under CC-BY (https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p)",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://oswalt.dev/assets/2021/06/vtable_diagram.png",alt:""}}),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Each concrete type with methods has a vtable created and stored in memory that can be accessed by our program when it’s time to figure out where a given method is for a given type. You can think of it as a directory for all of the concrete types and their methods.")]),t._v(" "),e("p",[t._v("Each of the three memory locations loaded into "),e("code",[t._v("rsi")]),t._v(" throughout the lifetime of our program is the location where a different type’s vtable is located:")]),t._v(" "),e("blockquote",[e("p",[t._v("Unfortunately I had some issues finding the vtable in "),e("code",[t._v("objdump")]),t._v(" output - for some reason what I found at the referenced offset was totally different from what other tools were showing me, and I couldn’t figure out why. So, the text below is copied from a really cool visual disassembler called "),e("a",{attrs:{href:"https://cutter.re/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cutter"),e("OutboundLink")],1),t._v(".")])]),t._v(" "),e("div",{staticClass:"language-asm extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("0x00043558      .qword 0x00000000000052b0 ; sym.core::ptr::drop_in_place::h1a84c45b0db95228 ; dbg.drop_in_place_polymorphism::Lion; RELOC 64 \n0x00043560      .qword 0x0000000000000000\n0x00043568      .qword 0x0000000000000001\n0x00043570      .qword 0x0000000000005420 ; sym._polymorphism::Lion_as_polymorphism::Growler_::growl::h9ba07c281cda2327; RELOC 64 \n\n0x00043578      .qword 0x00000000000052d0 ; sym.core::ptr::drop_in_place::hbe44f9f0e5cd7b58 ; dbg.drop_in_place_polymorphism::Tiger; RELOC 64 \n0x00043580      .qword 0x0000000000000000\n0x00043588      .qword 0x0000000000000001\n0x00043590      .qword 0x0000000000005470 ; sym._polymorphism::Tiger_as_polymorphism::Growler_::growl::hd8d4c2f459b86277; RELOC 64\n\n0x00043598      .qword 0x00000000000052c0 ; sym.core::ptr::drop_in_place::h5b23dc3563c0609b ; dbg.drop_in_place_polymorphism::Bear; RELOC 64 \n0x000435a0      .qword 0x0000000000000000\n0x000435a8      .qword 0x0000000000000001\n0x000435b0      .qword 0x00000000000054c0 ; sym._polymorphism::Bear_as_polymorphism::Growler_::growl::h4af959d647eb2439 ; dbg.growl; RELOC 64 \n")])])]),e("p",[t._v("Again, I added some spacing to make it easier to follow. You’ll note that each of the three memory locations loaded into "),e("code",[t._v("rsi")]),t._v(" mark the beginning of each type’s vtable in memory. However, the portion of the vtable that contains a pointer to the method we wish to call is actually located at an offset of 24 bytes from the beginning of each table. Incidentally, the hexidecimal equivalent for this is "),e("code",[t._v("0x18")]),t._v(", which is why our "),e("code",[t._v("dynamic_dispatch")]),t._v(" function adds this to "),e("code",[t._v("rsi")]),t._v(" before the "),e("code",[t._v("call")]),t._v(" instruction. "),e("code",[t._v("rsi")]),t._v(" contains the location of the vtable for the type we want, and adding "),e("code",[t._v("0x18")]),t._v(" to this gets us to the entry in this vtable that we want to access.")]),t._v(" "),e("p",[t._v("However, what’s located here is "),e("strong",[t._v("still")]),t._v(" not our method, but rather another pointer. For example, the memory location "),e("code",[t._v("0x43570")]),t._v(" just contains a pointer to "),e("code",[t._v("0x5420")]),t._v(". It is "),e("strong",[t._v("this")]),t._v(" location where we can find our method. This is why the "),e("code",[t._v("dynamic_dispatch")]),t._v(" function uses the instruction "),e("code",[t._v("call QWORD PTR [rsi+0x18]")]),t._v(" - it first loads the value located at "),e("code",[t._v("rsi + 0x18")]),t._v(" as a "),e("strong",[t._v("pointer")]),t._v(", and then calls the memory location represented by that pointer.")]),t._v(" "),e("blockquote",[e("p",[t._v("If you look closely, each of these pointers should look familiar - 5420, 5470, 54c0. These are the same addresses where we saw the methods for each type back in the static dispatch section! Regardless of whether we’re using static or dynamic dispatch, these functions still need to exist in our program - the difference is how we access them.")])]),t._v(" "),e("p",[t._v("As you can see, dynamic dispatch takes the opposite approach when compared to static dispatch. Instead of duplicating polymorphic functions based on the types that are used, a single implementation is created, but that implementation is designed to call different underlying types and methods based on a pointer that is calculated at runtime. Due to the lack of code duplication, the binary size is smaller, but because of the additional lookup that needs to take place, there’s a small performance hit. I’ll leave the analysis of this performance hit to others - there are plenty of blog posts out there that do a much better job of benchmarking dynamic dispatch than I ever will.")]),t._v(" "),e("h1",{attrs:{id:"conclusion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#conclusion",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("This was a fun blog post to write, and it gave me a much better understanding not only of Rust’s polymorphism options, but also a better understanding of how other languages offer similar tradeoffs. I hope it was useful for you as well.")]),t._v(" "),e("p",[t._v("I created a project in "),e("a",{attrs:{href:"https://godbolt.org/z/z8bfKccWb",target:"_blank",rel:"noopener noreferrer"}},[t._v("Compiler Explorer"),e("OutboundLink")],1),t._v(" which contains the full program with both approaches. This is an excellent tool which makes it "),e("strong",[t._v("very")]),t._v(" easy to see how our program actually works under the hood, so if you don’t feel like using "),e("code",[t._v("objdump")]),t._v(" or Cutter, this is a great learning tool as well.")]),t._v(" "),e("h1",{attrs:{id:"additional-links"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#additional-links"}},[t._v("#")]),t._v(" Additional Links "),e("a",{attrs:{href:"https://oswalt.dev/2021/06/polymorphism-in-rust/#additional-links",target:"_blank",rel:"noopener noreferrer"}},[e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Some additional links I found in my research that didn’t make it into the body of this post:")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://godbolt.org/z/u_yguS",target:"_blank",rel:"noopener noreferrer"}},[t._v("Very useful and instructive Compiler Explorer example"),e("OutboundLink")],1),t._v("; was inspired to create my own from this.")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://stackoverflow.com/questions/27567849/what-makes-something-a-trait-object",target:"_blank",rel:"noopener noreferrer"}},[t._v("Helpful SO thread"),e("OutboundLink")],1),t._v(" where trait object containers and vtables are discussed")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://medium.com/digitalfrontiers/rust-dynamic-dispatching-deep-dive-236a5896e49b",target:"_blank",rel:"noopener noreferrer"}},[t._v("Another useful post"),e("OutboundLink")],1),t._v(" on how this is done in Rust with some cool Cutter graph diagrams")])])])}),[],!1,null,null,null);e.default=n.exports}}]);