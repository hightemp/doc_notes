<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Obsidian notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Obsidian notes">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/doc_notes/assets/css/0.styles.60b82a90.css" as="style"><link rel="preload" href="/doc_notes/assets/js/app.d7b7570d.js" as="script"><link rel="preload" href="/doc_notes/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/doc_notes/assets/js/51.b9189617.js" as="script"><link rel="prefetch" href="/doc_notes/assets/js/10.466a3961.js"><link rel="prefetch" href="/doc_notes/assets/js/100.eed12daa.js"><link rel="prefetch" href="/doc_notes/assets/js/101.c2c72797.js"><link rel="prefetch" href="/doc_notes/assets/js/102.3a5b3674.js"><link rel="prefetch" href="/doc_notes/assets/js/103.4df54047.js"><link rel="prefetch" href="/doc_notes/assets/js/104.4e3d031e.js"><link rel="prefetch" href="/doc_notes/assets/js/105.fb56ad64.js"><link rel="prefetch" href="/doc_notes/assets/js/106.4cd1492c.js"><link rel="prefetch" href="/doc_notes/assets/js/107.a916259a.js"><link rel="prefetch" href="/doc_notes/assets/js/108.dfbcdb35.js"><link rel="prefetch" href="/doc_notes/assets/js/109.b85d5957.js"><link rel="prefetch" href="/doc_notes/assets/js/11.70fc3590.js"><link rel="prefetch" href="/doc_notes/assets/js/110.dc40183f.js"><link rel="prefetch" href="/doc_notes/assets/js/111.a9f83101.js"><link rel="prefetch" href="/doc_notes/assets/js/112.1b402c16.js"><link rel="prefetch" href="/doc_notes/assets/js/113.89928947.js"><link rel="prefetch" href="/doc_notes/assets/js/114.8be0db96.js"><link rel="prefetch" href="/doc_notes/assets/js/115.bd9e24bd.js"><link rel="prefetch" href="/doc_notes/assets/js/116.1979db39.js"><link rel="prefetch" href="/doc_notes/assets/js/117.7a439523.js"><link rel="prefetch" href="/doc_notes/assets/js/118.680aed03.js"><link rel="prefetch" href="/doc_notes/assets/js/119.dfdba03a.js"><link rel="prefetch" href="/doc_notes/assets/js/12.0f945969.js"><link rel="prefetch" href="/doc_notes/assets/js/120.37c405a9.js"><link rel="prefetch" href="/doc_notes/assets/js/121.672a368b.js"><link rel="prefetch" href="/doc_notes/assets/js/122.f1b5fad1.js"><link rel="prefetch" href="/doc_notes/assets/js/123.b0d4c3db.js"><link rel="prefetch" href="/doc_notes/assets/js/124.7f08733e.js"><link rel="prefetch" href="/doc_notes/assets/js/125.619db48f.js"><link rel="prefetch" href="/doc_notes/assets/js/126.048ed0c7.js"><link rel="prefetch" href="/doc_notes/assets/js/127.cc65fb73.js"><link rel="prefetch" href="/doc_notes/assets/js/128.27591c7f.js"><link rel="prefetch" href="/doc_notes/assets/js/129.e848d5ea.js"><link rel="prefetch" href="/doc_notes/assets/js/13.353aee93.js"><link rel="prefetch" href="/doc_notes/assets/js/130.0b6325e2.js"><link rel="prefetch" href="/doc_notes/assets/js/131.a4a8dc74.js"><link rel="prefetch" href="/doc_notes/assets/js/132.f78488ea.js"><link rel="prefetch" href="/doc_notes/assets/js/133.2c57ab36.js"><link rel="prefetch" href="/doc_notes/assets/js/134.c041a644.js"><link rel="prefetch" href="/doc_notes/assets/js/135.dd89210d.js"><link rel="prefetch" href="/doc_notes/assets/js/136.127b0247.js"><link rel="prefetch" href="/doc_notes/assets/js/137.1ff783eb.js"><link rel="prefetch" href="/doc_notes/assets/js/138.e72eaf60.js"><link rel="prefetch" href="/doc_notes/assets/js/139.135c74d8.js"><link rel="prefetch" href="/doc_notes/assets/js/14.a3283f94.js"><link rel="prefetch" href="/doc_notes/assets/js/140.4a7f191d.js"><link rel="prefetch" href="/doc_notes/assets/js/141.fa563aa9.js"><link rel="prefetch" href="/doc_notes/assets/js/142.266c8a69.js"><link rel="prefetch" href="/doc_notes/assets/js/143.3c3e596e.js"><link rel="prefetch" href="/doc_notes/assets/js/144.46a5cdc6.js"><link rel="prefetch" href="/doc_notes/assets/js/145.c33d2f51.js"><link rel="prefetch" href="/doc_notes/assets/js/146.ecf9ffa3.js"><link rel="prefetch" href="/doc_notes/assets/js/147.ecc8f162.js"><link rel="prefetch" href="/doc_notes/assets/js/148.57a0cc2c.js"><link rel="prefetch" href="/doc_notes/assets/js/149.243334a6.js"><link rel="prefetch" href="/doc_notes/assets/js/15.c66e3407.js"><link rel="prefetch" href="/doc_notes/assets/js/150.6811595e.js"><link rel="prefetch" href="/doc_notes/assets/js/151.a1b33f48.js"><link rel="prefetch" href="/doc_notes/assets/js/152.754c44e2.js"><link rel="prefetch" href="/doc_notes/assets/js/153.b6b30dd0.js"><link rel="prefetch" href="/doc_notes/assets/js/154.78d410b8.js"><link rel="prefetch" href="/doc_notes/assets/js/155.767f3fb1.js"><link rel="prefetch" href="/doc_notes/assets/js/156.f9095760.js"><link rel="prefetch" href="/doc_notes/assets/js/157.c538a726.js"><link rel="prefetch" href="/doc_notes/assets/js/158.9835a2a3.js"><link rel="prefetch" href="/doc_notes/assets/js/159.9d7c5a05.js"><link rel="prefetch" href="/doc_notes/assets/js/16.e7ecc933.js"><link rel="prefetch" href="/doc_notes/assets/js/160.addf636e.js"><link rel="prefetch" href="/doc_notes/assets/js/161.b9499ae3.js"><link rel="prefetch" href="/doc_notes/assets/js/162.9ebe738a.js"><link rel="prefetch" href="/doc_notes/assets/js/163.4860d1e7.js"><link rel="prefetch" href="/doc_notes/assets/js/164.148cebf3.js"><link rel="prefetch" href="/doc_notes/assets/js/165.41046f67.js"><link rel="prefetch" href="/doc_notes/assets/js/166.6deaed29.js"><link rel="prefetch" href="/doc_notes/assets/js/167.6d02a205.js"><link rel="prefetch" href="/doc_notes/assets/js/168.c86d38a7.js"><link rel="prefetch" href="/doc_notes/assets/js/169.eb313225.js"><link rel="prefetch" href="/doc_notes/assets/js/17.65a71bb5.js"><link rel="prefetch" href="/doc_notes/assets/js/170.889855cd.js"><link rel="prefetch" href="/doc_notes/assets/js/171.b95cf306.js"><link rel="prefetch" href="/doc_notes/assets/js/172.0b1e5fe3.js"><link rel="prefetch" href="/doc_notes/assets/js/173.99679181.js"><link rel="prefetch" href="/doc_notes/assets/js/174.f28ad52f.js"><link rel="prefetch" href="/doc_notes/assets/js/175.1c1f371e.js"><link rel="prefetch" href="/doc_notes/assets/js/176.662a9d28.js"><link rel="prefetch" href="/doc_notes/assets/js/177.6e464bd5.js"><link rel="prefetch" href="/doc_notes/assets/js/178.102c88e4.js"><link rel="prefetch" href="/doc_notes/assets/js/179.dddab088.js"><link rel="prefetch" href="/doc_notes/assets/js/18.8fedcbac.js"><link rel="prefetch" href="/doc_notes/assets/js/180.345e741e.js"><link rel="prefetch" href="/doc_notes/assets/js/181.59db7110.js"><link rel="prefetch" href="/doc_notes/assets/js/182.7f628252.js"><link rel="prefetch" href="/doc_notes/assets/js/183.e8653839.js"><link rel="prefetch" href="/doc_notes/assets/js/184.3eec36ec.js"><link rel="prefetch" href="/doc_notes/assets/js/185.cb0c13d5.js"><link rel="prefetch" href="/doc_notes/assets/js/186.1ccbe1a2.js"><link rel="prefetch" href="/doc_notes/assets/js/187.55e6bc99.js"><link rel="prefetch" href="/doc_notes/assets/js/188.1829998b.js"><link rel="prefetch" href="/doc_notes/assets/js/189.e86e8099.js"><link rel="prefetch" href="/doc_notes/assets/js/19.8fd4f833.js"><link rel="prefetch" href="/doc_notes/assets/js/190.3263ca68.js"><link rel="prefetch" href="/doc_notes/assets/js/191.6973d93a.js"><link rel="prefetch" href="/doc_notes/assets/js/192.8c648d4c.js"><link rel="prefetch" href="/doc_notes/assets/js/193.135dc6c4.js"><link rel="prefetch" href="/doc_notes/assets/js/194.2387809d.js"><link rel="prefetch" href="/doc_notes/assets/js/195.4e094a48.js"><link rel="prefetch" href="/doc_notes/assets/js/196.faae151e.js"><link rel="prefetch" href="/doc_notes/assets/js/197.6ca84b2f.js"><link rel="prefetch" href="/doc_notes/assets/js/198.99d5a7c7.js"><link rel="prefetch" href="/doc_notes/assets/js/199.5ac6f260.js"><link rel="prefetch" href="/doc_notes/assets/js/20.b7871733.js"><link rel="prefetch" href="/doc_notes/assets/js/200.434715d2.js"><link rel="prefetch" href="/doc_notes/assets/js/201.df5e4553.js"><link rel="prefetch" href="/doc_notes/assets/js/202.4f5738c7.js"><link rel="prefetch" href="/doc_notes/assets/js/203.7bdee8f2.js"><link rel="prefetch" href="/doc_notes/assets/js/204.5b4e69e3.js"><link rel="prefetch" href="/doc_notes/assets/js/205.58586a6e.js"><link rel="prefetch" href="/doc_notes/assets/js/206.b5603313.js"><link rel="prefetch" href="/doc_notes/assets/js/207.e1a4577a.js"><link rel="prefetch" href="/doc_notes/assets/js/208.2369d699.js"><link rel="prefetch" href="/doc_notes/assets/js/209.baadeea1.js"><link rel="prefetch" href="/doc_notes/assets/js/21.1cff06fb.js"><link rel="prefetch" href="/doc_notes/assets/js/210.2b107173.js"><link rel="prefetch" href="/doc_notes/assets/js/211.c8eea835.js"><link rel="prefetch" href="/doc_notes/assets/js/212.1fae6417.js"><link rel="prefetch" href="/doc_notes/assets/js/213.5696d97f.js"><link rel="prefetch" href="/doc_notes/assets/js/214.bbd783da.js"><link rel="prefetch" href="/doc_notes/assets/js/215.1c0c350c.js"><link rel="prefetch" href="/doc_notes/assets/js/216.498044dc.js"><link rel="prefetch" href="/doc_notes/assets/js/217.319f81c6.js"><link rel="prefetch" href="/doc_notes/assets/js/218.8911d413.js"><link rel="prefetch" href="/doc_notes/assets/js/219.f37e96ea.js"><link rel="prefetch" href="/doc_notes/assets/js/22.2cd72a62.js"><link rel="prefetch" href="/doc_notes/assets/js/220.b5ac8e75.js"><link rel="prefetch" href="/doc_notes/assets/js/221.cde91cfa.js"><link rel="prefetch" href="/doc_notes/assets/js/222.df059246.js"><link rel="prefetch" href="/doc_notes/assets/js/223.3ce433b3.js"><link rel="prefetch" href="/doc_notes/assets/js/224.36f2c1ff.js"><link rel="prefetch" href="/doc_notes/assets/js/225.fbee00f9.js"><link rel="prefetch" href="/doc_notes/assets/js/226.306f0e70.js"><link rel="prefetch" href="/doc_notes/assets/js/227.4e7373a0.js"><link rel="prefetch" href="/doc_notes/assets/js/228.44fd0171.js"><link rel="prefetch" href="/doc_notes/assets/js/229.f832a1d6.js"><link rel="prefetch" href="/doc_notes/assets/js/23.e9957abc.js"><link rel="prefetch" href="/doc_notes/assets/js/230.043a91e9.js"><link rel="prefetch" href="/doc_notes/assets/js/231.7616cdd1.js"><link rel="prefetch" href="/doc_notes/assets/js/232.c3eb262d.js"><link rel="prefetch" href="/doc_notes/assets/js/233.645ff598.js"><link rel="prefetch" href="/doc_notes/assets/js/234.bb763bdf.js"><link rel="prefetch" href="/doc_notes/assets/js/235.f6724c17.js"><link rel="prefetch" href="/doc_notes/assets/js/236.2fe5969c.js"><link rel="prefetch" href="/doc_notes/assets/js/237.c379ae13.js"><link rel="prefetch" href="/doc_notes/assets/js/238.bc474d07.js"><link rel="prefetch" href="/doc_notes/assets/js/239.b4b3094b.js"><link rel="prefetch" href="/doc_notes/assets/js/24.e4e0f07a.js"><link rel="prefetch" href="/doc_notes/assets/js/240.b7298fad.js"><link rel="prefetch" href="/doc_notes/assets/js/241.edc191c3.js"><link rel="prefetch" href="/doc_notes/assets/js/242.d79274ed.js"><link rel="prefetch" href="/doc_notes/assets/js/243.db97328a.js"><link rel="prefetch" href="/doc_notes/assets/js/244.68cd4704.js"><link rel="prefetch" href="/doc_notes/assets/js/245.f501295b.js"><link rel="prefetch" href="/doc_notes/assets/js/246.ddc4d5d9.js"><link rel="prefetch" href="/doc_notes/assets/js/247.ff22cc5b.js"><link rel="prefetch" href="/doc_notes/assets/js/248.4a61cd51.js"><link rel="prefetch" href="/doc_notes/assets/js/249.be49f5ca.js"><link rel="prefetch" href="/doc_notes/assets/js/25.c7ae079a.js"><link rel="prefetch" href="/doc_notes/assets/js/250.43caa09e.js"><link rel="prefetch" href="/doc_notes/assets/js/251.26d5a6e9.js"><link rel="prefetch" href="/doc_notes/assets/js/252.b3bcf0c8.js"><link rel="prefetch" href="/doc_notes/assets/js/253.1a1b2b11.js"><link rel="prefetch" href="/doc_notes/assets/js/254.1c4090ef.js"><link rel="prefetch" href="/doc_notes/assets/js/255.a49e9f41.js"><link rel="prefetch" href="/doc_notes/assets/js/256.78de4e85.js"><link rel="prefetch" href="/doc_notes/assets/js/257.3f3d8408.js"><link rel="prefetch" href="/doc_notes/assets/js/258.2a59b276.js"><link rel="prefetch" href="/doc_notes/assets/js/259.8916e4fc.js"><link rel="prefetch" href="/doc_notes/assets/js/26.1ae4ceb3.js"><link rel="prefetch" href="/doc_notes/assets/js/260.9e38f578.js"><link rel="prefetch" href="/doc_notes/assets/js/261.bb658a8a.js"><link rel="prefetch" href="/doc_notes/assets/js/262.e3dc3020.js"><link rel="prefetch" href="/doc_notes/assets/js/263.f1020a9b.js"><link rel="prefetch" href="/doc_notes/assets/js/264.b8f1ff3a.js"><link rel="prefetch" href="/doc_notes/assets/js/265.d3eb13d8.js"><link rel="prefetch" href="/doc_notes/assets/js/266.f27ca21b.js"><link rel="prefetch" href="/doc_notes/assets/js/267.338c834f.js"><link rel="prefetch" href="/doc_notes/assets/js/268.b9ebda2b.js"><link rel="prefetch" href="/doc_notes/assets/js/269.dc7525cf.js"><link rel="prefetch" href="/doc_notes/assets/js/27.42caa565.js"><link rel="prefetch" href="/doc_notes/assets/js/270.137ed51c.js"><link rel="prefetch" href="/doc_notes/assets/js/271.b6fdb998.js"><link rel="prefetch" href="/doc_notes/assets/js/272.ddc1ee03.js"><link rel="prefetch" href="/doc_notes/assets/js/273.df6133aa.js"><link rel="prefetch" href="/doc_notes/assets/js/274.9115305d.js"><link rel="prefetch" href="/doc_notes/assets/js/275.13342d76.js"><link rel="prefetch" href="/doc_notes/assets/js/276.a9e1f1ec.js"><link rel="prefetch" href="/doc_notes/assets/js/277.f2728f30.js"><link rel="prefetch" href="/doc_notes/assets/js/278.7e726870.js"><link rel="prefetch" href="/doc_notes/assets/js/279.648ad6bd.js"><link rel="prefetch" href="/doc_notes/assets/js/28.45f1bbb9.js"><link rel="prefetch" href="/doc_notes/assets/js/280.720a2918.js"><link rel="prefetch" href="/doc_notes/assets/js/281.5a2d475b.js"><link rel="prefetch" href="/doc_notes/assets/js/282.62bc635b.js"><link rel="prefetch" href="/doc_notes/assets/js/283.ff6be5f5.js"><link rel="prefetch" href="/doc_notes/assets/js/284.3f7c0af1.js"><link rel="prefetch" href="/doc_notes/assets/js/285.c2f51624.js"><link rel="prefetch" href="/doc_notes/assets/js/286.a5b99138.js"><link rel="prefetch" href="/doc_notes/assets/js/287.829ac9bd.js"><link rel="prefetch" href="/doc_notes/assets/js/288.54aabaae.js"><link rel="prefetch" href="/doc_notes/assets/js/289.71b4d090.js"><link rel="prefetch" href="/doc_notes/assets/js/29.0fdf0aa1.js"><link rel="prefetch" href="/doc_notes/assets/js/290.df175e90.js"><link rel="prefetch" href="/doc_notes/assets/js/291.014245fe.js"><link rel="prefetch" href="/doc_notes/assets/js/292.8d375ce2.js"><link rel="prefetch" href="/doc_notes/assets/js/293.8591ceba.js"><link rel="prefetch" href="/doc_notes/assets/js/294.d979d20b.js"><link rel="prefetch" href="/doc_notes/assets/js/295.372c2d39.js"><link rel="prefetch" href="/doc_notes/assets/js/296.07d572ab.js"><link rel="prefetch" href="/doc_notes/assets/js/297.5de1073e.js"><link rel="prefetch" href="/doc_notes/assets/js/298.5a6ac1ca.js"><link rel="prefetch" href="/doc_notes/assets/js/299.e87a7ab3.js"><link rel="prefetch" href="/doc_notes/assets/js/3.8087b6c9.js"><link rel="prefetch" href="/doc_notes/assets/js/30.33c143cb.js"><link rel="prefetch" href="/doc_notes/assets/js/300.c011f877.js"><link rel="prefetch" href="/doc_notes/assets/js/301.479875ba.js"><link rel="prefetch" href="/doc_notes/assets/js/302.fe22cf89.js"><link rel="prefetch" href="/doc_notes/assets/js/303.fe59bc5d.js"><link rel="prefetch" href="/doc_notes/assets/js/304.17566e0f.js"><link rel="prefetch" href="/doc_notes/assets/js/305.235d62da.js"><link rel="prefetch" href="/doc_notes/assets/js/306.6a899aaa.js"><link rel="prefetch" href="/doc_notes/assets/js/307.a6302576.js"><link rel="prefetch" href="/doc_notes/assets/js/308.53d18516.js"><link rel="prefetch" href="/doc_notes/assets/js/309.44746635.js"><link rel="prefetch" href="/doc_notes/assets/js/31.f3c83a33.js"><link rel="prefetch" href="/doc_notes/assets/js/310.2b0b41b5.js"><link rel="prefetch" href="/doc_notes/assets/js/311.a2425d85.js"><link rel="prefetch" href="/doc_notes/assets/js/312.ee8bb224.js"><link rel="prefetch" href="/doc_notes/assets/js/313.cdb7a074.js"><link rel="prefetch" href="/doc_notes/assets/js/314.5c46337b.js"><link rel="prefetch" href="/doc_notes/assets/js/315.d2f5d6ef.js"><link rel="prefetch" href="/doc_notes/assets/js/316.1d1b10d7.js"><link rel="prefetch" href="/doc_notes/assets/js/317.18978adf.js"><link rel="prefetch" href="/doc_notes/assets/js/318.725aaa9e.js"><link rel="prefetch" href="/doc_notes/assets/js/319.10c27323.js"><link rel="prefetch" href="/doc_notes/assets/js/32.2e4a5d25.js"><link rel="prefetch" href="/doc_notes/assets/js/320.be122112.js"><link rel="prefetch" href="/doc_notes/assets/js/321.21d59327.js"><link rel="prefetch" href="/doc_notes/assets/js/322.1c7aa8b5.js"><link rel="prefetch" href="/doc_notes/assets/js/323.61f2e664.js"><link rel="prefetch" href="/doc_notes/assets/js/324.d5ef212c.js"><link rel="prefetch" href="/doc_notes/assets/js/325.8dcaad1a.js"><link rel="prefetch" href="/doc_notes/assets/js/326.27ae755d.js"><link rel="prefetch" href="/doc_notes/assets/js/327.23295181.js"><link rel="prefetch" href="/doc_notes/assets/js/328.b1038029.js"><link rel="prefetch" href="/doc_notes/assets/js/329.685f438a.js"><link rel="prefetch" href="/doc_notes/assets/js/33.78d67de4.js"><link rel="prefetch" href="/doc_notes/assets/js/330.29d01e38.js"><link rel="prefetch" href="/doc_notes/assets/js/331.56ede5a6.js"><link rel="prefetch" href="/doc_notes/assets/js/332.26f5337e.js"><link rel="prefetch" href="/doc_notes/assets/js/333.7a1b5bed.js"><link rel="prefetch" href="/doc_notes/assets/js/334.ccc83ffa.js"><link rel="prefetch" href="/doc_notes/assets/js/335.dd4d24f2.js"><link rel="prefetch" href="/doc_notes/assets/js/336.5cd8a3be.js"><link rel="prefetch" href="/doc_notes/assets/js/337.725cd669.js"><link rel="prefetch" href="/doc_notes/assets/js/338.ca370789.js"><link rel="prefetch" href="/doc_notes/assets/js/339.4db35fe1.js"><link rel="prefetch" href="/doc_notes/assets/js/34.10602eab.js"><link rel="prefetch" href="/doc_notes/assets/js/340.11e5684e.js"><link rel="prefetch" href="/doc_notes/assets/js/341.87af888b.js"><link rel="prefetch" href="/doc_notes/assets/js/342.6288246d.js"><link rel="prefetch" href="/doc_notes/assets/js/343.10836901.js"><link rel="prefetch" href="/doc_notes/assets/js/344.85db1640.js"><link rel="prefetch" href="/doc_notes/assets/js/345.f1a97cf1.js"><link rel="prefetch" href="/doc_notes/assets/js/346.dd502824.js"><link rel="prefetch" href="/doc_notes/assets/js/347.b211385a.js"><link rel="prefetch" href="/doc_notes/assets/js/348.f255c270.js"><link rel="prefetch" href="/doc_notes/assets/js/349.36014517.js"><link rel="prefetch" href="/doc_notes/assets/js/35.03fbbb65.js"><link rel="prefetch" href="/doc_notes/assets/js/350.817bd0e1.js"><link rel="prefetch" href="/doc_notes/assets/js/351.abf45be4.js"><link rel="prefetch" href="/doc_notes/assets/js/352.4254451f.js"><link rel="prefetch" href="/doc_notes/assets/js/353.c0b15b9d.js"><link rel="prefetch" href="/doc_notes/assets/js/354.d725c37e.js"><link rel="prefetch" href="/doc_notes/assets/js/355.10f1ce9b.js"><link rel="prefetch" href="/doc_notes/assets/js/356.a5e2bfda.js"><link rel="prefetch" href="/doc_notes/assets/js/357.80f39a19.js"><link rel="prefetch" href="/doc_notes/assets/js/358.5c69b1d1.js"><link rel="prefetch" href="/doc_notes/assets/js/359.12d21c81.js"><link rel="prefetch" href="/doc_notes/assets/js/36.aa74ba81.js"><link rel="prefetch" href="/doc_notes/assets/js/360.1183658a.js"><link rel="prefetch" href="/doc_notes/assets/js/361.33b745b6.js"><link rel="prefetch" href="/doc_notes/assets/js/362.a56596c0.js"><link rel="prefetch" href="/doc_notes/assets/js/363.1fadef9e.js"><link rel="prefetch" href="/doc_notes/assets/js/364.e43e06a1.js"><link rel="prefetch" href="/doc_notes/assets/js/365.1b191379.js"><link rel="prefetch" href="/doc_notes/assets/js/366.77112bc2.js"><link rel="prefetch" href="/doc_notes/assets/js/367.cbbf1410.js"><link rel="prefetch" href="/doc_notes/assets/js/368.6e4af412.js"><link rel="prefetch" href="/doc_notes/assets/js/369.9d8214a4.js"><link rel="prefetch" href="/doc_notes/assets/js/37.bad965a6.js"><link rel="prefetch" href="/doc_notes/assets/js/370.5dcbc931.js"><link rel="prefetch" href="/doc_notes/assets/js/371.3e798a72.js"><link rel="prefetch" href="/doc_notes/assets/js/372.99fbe027.js"><link rel="prefetch" href="/doc_notes/assets/js/373.783fc78c.js"><link rel="prefetch" href="/doc_notes/assets/js/374.8fc2e9fe.js"><link rel="prefetch" href="/doc_notes/assets/js/375.2831b29c.js"><link rel="prefetch" href="/doc_notes/assets/js/376.8a690d9f.js"><link rel="prefetch" href="/doc_notes/assets/js/377.c6401c22.js"><link rel="prefetch" href="/doc_notes/assets/js/38.57a79422.js"><link rel="prefetch" href="/doc_notes/assets/js/39.7ab71035.js"><link rel="prefetch" href="/doc_notes/assets/js/4.da3ef268.js"><link rel="prefetch" href="/doc_notes/assets/js/40.ffa22594.js"><link rel="prefetch" href="/doc_notes/assets/js/41.b2fc54d1.js"><link rel="prefetch" href="/doc_notes/assets/js/42.c43bc930.js"><link rel="prefetch" href="/doc_notes/assets/js/43.5c93d7a1.js"><link rel="prefetch" href="/doc_notes/assets/js/44.605a54a6.js"><link rel="prefetch" href="/doc_notes/assets/js/45.f85a75a3.js"><link rel="prefetch" href="/doc_notes/assets/js/46.2cd25346.js"><link rel="prefetch" href="/doc_notes/assets/js/47.93f7d1a6.js"><link rel="prefetch" href="/doc_notes/assets/js/48.7fd0b6dc.js"><link rel="prefetch" href="/doc_notes/assets/js/49.c64bb839.js"><link rel="prefetch" href="/doc_notes/assets/js/5.dac787d8.js"><link rel="prefetch" href="/doc_notes/assets/js/50.d2fe7364.js"><link rel="prefetch" href="/doc_notes/assets/js/52.4689b562.js"><link rel="prefetch" href="/doc_notes/assets/js/53.f0b1d96b.js"><link rel="prefetch" href="/doc_notes/assets/js/54.f52a48ab.js"><link rel="prefetch" href="/doc_notes/assets/js/55.98bfca4a.js"><link rel="prefetch" href="/doc_notes/assets/js/56.6c0a81f6.js"><link rel="prefetch" href="/doc_notes/assets/js/57.e17dfa82.js"><link rel="prefetch" href="/doc_notes/assets/js/58.f9a5000b.js"><link rel="prefetch" href="/doc_notes/assets/js/59.3296ea1c.js"><link rel="prefetch" href="/doc_notes/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/doc_notes/assets/js/60.610d4eca.js"><link rel="prefetch" href="/doc_notes/assets/js/61.64b18740.js"><link rel="prefetch" href="/doc_notes/assets/js/62.87e34293.js"><link rel="prefetch" href="/doc_notes/assets/js/63.fbd2d78b.js"><link rel="prefetch" href="/doc_notes/assets/js/64.493b857a.js"><link rel="prefetch" href="/doc_notes/assets/js/65.0a60479c.js"><link rel="prefetch" href="/doc_notes/assets/js/66.800419f9.js"><link rel="prefetch" href="/doc_notes/assets/js/67.343f5dab.js"><link rel="prefetch" href="/doc_notes/assets/js/68.fed77f78.js"><link rel="prefetch" href="/doc_notes/assets/js/69.8b1601da.js"><link rel="prefetch" href="/doc_notes/assets/js/7.c9d31aa2.js"><link rel="prefetch" href="/doc_notes/assets/js/70.aedd0ab9.js"><link rel="prefetch" href="/doc_notes/assets/js/71.b166238f.js"><link rel="prefetch" href="/doc_notes/assets/js/72.27a66c82.js"><link rel="prefetch" href="/doc_notes/assets/js/73.1d9b487f.js"><link rel="prefetch" href="/doc_notes/assets/js/74.84702901.js"><link rel="prefetch" href="/doc_notes/assets/js/75.2f6ae560.js"><link rel="prefetch" href="/doc_notes/assets/js/76.4856c210.js"><link rel="prefetch" href="/doc_notes/assets/js/77.9fc6950e.js"><link rel="prefetch" href="/doc_notes/assets/js/78.cb2f07a0.js"><link rel="prefetch" href="/doc_notes/assets/js/79.5e43d0b7.js"><link rel="prefetch" href="/doc_notes/assets/js/8.da9db8f9.js"><link rel="prefetch" href="/doc_notes/assets/js/80.d59ea8af.js"><link rel="prefetch" href="/doc_notes/assets/js/81.9fc53f43.js"><link rel="prefetch" href="/doc_notes/assets/js/82.5838801e.js"><link rel="prefetch" href="/doc_notes/assets/js/83.d2006fd2.js"><link rel="prefetch" href="/doc_notes/assets/js/84.9b965f14.js"><link rel="prefetch" href="/doc_notes/assets/js/85.de0c498b.js"><link rel="prefetch" href="/doc_notes/assets/js/86.ce67f8b8.js"><link rel="prefetch" href="/doc_notes/assets/js/87.5d47b003.js"><link rel="prefetch" href="/doc_notes/assets/js/88.eee9be64.js"><link rel="prefetch" href="/doc_notes/assets/js/89.42153946.js"><link rel="prefetch" href="/doc_notes/assets/js/9.0ccc34a6.js"><link rel="prefetch" href="/doc_notes/assets/js/90.13a9f4b2.js"><link rel="prefetch" href="/doc_notes/assets/js/91.832ae5d2.js"><link rel="prefetch" href="/doc_notes/assets/js/92.bd7c25ca.js"><link rel="prefetch" href="/doc_notes/assets/js/93.8a6f3f34.js"><link rel="prefetch" href="/doc_notes/assets/js/94.221348bd.js"><link rel="prefetch" href="/doc_notes/assets/js/95.86b48f96.js"><link rel="prefetch" href="/doc_notes/assets/js/96.7c6d0372.js"><link rel="prefetch" href="/doc_notes/assets/js/97.307341f8.js"><link rel="prefetch" href="/doc_notes/assets/js/98.14120c7c.js"><link rel="prefetch" href="/doc_notes/assets/js/99.40560c36.js">
    <link rel="stylesheet" href="/doc_notes/assets/css/0.styles.60b82a90.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/doc_notes/" class="home-link router-link-active"><!----> <span class="site-name">Obsidian notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/doc_notes/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/doc_notes/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/doc_notes/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/doc_notes/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Sure, here are 100 keywords describing the Linux kernel along with their definitions and concepts:</p> <ol><li>Kernel - The core component of the operating system that manages system resources.</li> <li>Open source - A software model that allows users to freely access and modify the source code.</li> <li>Source code - The human-readable code that comprises a software program.</li> <li>Unix-like - A family of operating systems that share a similar design and command syntax with the original Unix system.</li> <li>Monolithic - A kernel design in which all operating system components run in a single address space.</li> <li>Modular - A kernel design in which operating system components run in separate address spaces and can be loaded and unloaded dynamically.</li> <li>Device driver - Software that allows the operating system to communicate with hardware devices.</li> <li>System call - A mechanism for communicating between user space and kernel space.</li> <li>Process - An instance of a running program.</li> <li>Scheduling - The process of determining which process gets to use the CPU.</li> <li>Time-sharing - A scheduling method that allows multiple processes to share the CPU.</li> <li>Preemption - The ability of the operating system to interrupt a running process and switch to another.</li> <li>Virtual memory - A technique that allows the operating system to use more memory than physically present in the system.</li> <li>Paging - A mechanism for managing virtual memory by dividing it into fixed-size blocks called pages.</li> <li>Page table - A data structure that maps virtual memory addresses to physical memory addresses.</li> <li>Memory management unit (MMU) - Hardware that translates virtual memory addresses to physical memory addresses.</li> <li>Interrupt - A signal sent to the CPU by a hardware device or software component.</li> <li>Interrupt handler - Software that handles interrupts.</li> <li>File system - A method for organizing and storing files on a storage device.</li> <li>Inode - A data structure that represents a file in a Unix-like file system.</li> <li>Superblock - A data structure that contains information about a file system, such as its size and location.</li> <li>Hard link - A file system feature that creates a new reference to an existing file.</li> <li>Soft link - A file system feature that creates a new file that points to another file.</li> <li>Block device - A storage device that reads and writes data in fixed-size blocks.</li> <li>Character device - A device that reads and writes data one character at a time.</li> <li>Network stack - The set of software components that manage network communication.</li> <li>Socket - A software endpoint for network communication.</li> <li>Protocol - A set of rules for transmitting data over a network.</li> <li>TCP/IP - The most common set of protocols used for internet communication.</li> <li>Routing - The process of sending data between networks.</li> <li>Firewall - Software or hardware that blocks unwanted network traffic.</li> <li>System initialization - The process of starting up the operating system.</li> <li>Boot loader - Software that loads the operating system into memory.</li> <li>BIOS - Basic Input/Output System, the firmware that initializes hardware components during system startup.</li> <li>UEFI - Unified Extensible Firmware Interface, a newer system firmware that replaces BIOS.</li> <li>GRUB - Grand Unified Bootloader, a popular boot loader for Linux systems.</li> <li>Init system - Software that manages system startup and service management.</li> <li>Systemd - A popular init system for modern Linux distributions.</li> <li>Upstart - An older init system used by some Linux distributions.</li> <li>Runlevel - A system state that determines which services are running.</li> <li>Service - A software component that runs in the background and provides a specific function.</li> <li>Daemon - A service that runs in the background and has no user interface.</li> <li>User space - The part of the operating system where user applications run.</li> <li>Kernel space - The part of the operating system where the kernel and operating system components run.</li> <li>Interprocess communication - The process of sending data between processes.</li> <li>Shared memory - A method for allowing processes to share memory.</li> <li>Message passing - A method for allowing processes to send messages to each other.</li> <li>Signal - A software interrupt used for interprocess communication.</li> <li>Mutex - A synchronization primitive used to prevent multiple processes from accessing a shared resource at the same time.</li> <li>Semaphore - A synchronization primitive used to control access to a shared resource.</li> <li>Spinlock - A synchronization primitive used to protect shared resources in a multiprocessor system.</li> <li>Lock-free programming - A programming technique that avoids the use of locks for synchronization.</li> <li>Multithreading - The process of running multiple threads within a single process.</li> <li>Thread - A lightweight process that shares the same memory space as the parent process.</li> <li>Thread pool - A collection of threads that can be reused to perform multiple tasks.</li> <li>Process group - A collection of related processes.</li> <li>Job control - The process of managing processes and job scheduling.</li> <li>Shell - A command-line interface for interacting with the operating system.</li> <li>Bash - A popular shell for Linux systems.</li> <li>Environment variable - A variable that contains information about the system environment.</li> <li>PATH - An environment variable that contains a list of directories where executable files are located.</li> <li>Standard input/output/error (stdin/stdout/stderr) - The standard ways for programs to input and output data.</li> <li>Redirection - A method for changing the input or output of a program.</li> <li>Pipe - A method for chaining multiple programs together, with the output of one program becoming the input of the next.</li> <li>Regular expression - A pattern-matching language used for searching and manipulating text.</li> <li>Shell script - A program written in a shell language, used for automating tasks or running multiple commands.</li> <li>Cron - A program for scheduling recurring tasks.</li> <li>File permissions - A method for controlling access to files and directories.</li> <li>User - A person who uses the system, with associated permissions and settings.</li> <li>Group - A collection of users with shared permissions.</li> <li>Root - The highest level of access in the system, with full permissions.</li> <li>sudo - A command for temporarily elevating a user's permissions to root.</li> <li>su - A command for switching to the root user.</li> <li>chroot - A command for changing the root directory for a process.</li> <li>Kernel module - A piece of software that can be loaded into the kernel at runtime.</li> <li>Loadable module support - A kernel feature that allows modules to be loaded and unloaded dynamically.</li> <li>Device tree - A data structure that describes the hardware components in a system.</li> <li>ACPI - Advanced Configuration and Power Interface, a standard for power management and hardware configuration.</li> <li>DMA - Direct Memory Access, a method for hardware devices to directly access system memory.</li> <li>Interrupt controller - Hardware that manages interrupts from multiple devices.</li> <li>Virtual memory - A technique for using disk space as an extension of RAM.</li> <li>Page table - A data structure used for mapping virtual addresses to physical addresses.</li> <li>Swap space - An area of disk space used for virtual memory.</li> <li>Scheduler - A component of the kernel that manages process and thread scheduling.</li> <li>CFS - Completely Fair Scheduler, a popular process scheduler for Linux systems.</li> <li>Real-time scheduling - A scheduling method for time-sensitive applications.</li> <li>I/O scheduler - A component of the kernel that manages I/O operations.</li> <li>Deadline scheduler - An I/O scheduler that prioritizes requests based on their deadline.</li> <li>CFQ scheduler - An I/O scheduler that prioritizes requests based on the process that issued them.</li> <li>Memory management unit (MMU) - Hardware that manages virtual memory.</li> <li>System call - A mechanism for accessing kernel functions from user space.</li> <li>File system - A method for organizing and accessing files on disk.</li> <li>Ext4 - A popular file system for Linux systems.</li> <li>XFS - Another popular file system for Linux systems.</li> <li>Btrfs - A newer file system with advanced features like snapshots and data checksumming.</li> <li>NFS - Network File System, a protocol for sharing files over a network.</li> <li>Samba - A software suite for sharing files and printers between Linux and Windows systems.</li> <li>RAID - Redundant Array of Independent Disks, a method for combining multiple disks into a single logical volume.</li> <li>LVM - Logical Volume Manager, a software layer that allows for flexible management of disk space.</li> <li>Backup - A method for creating copies of important data to protect against data loss.</li></ol> <p>Ядро Linux - это основной компонент операционной системы Linux, который управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением.</p> <p>Ядро Linux состоит из трех основных слоев: аппаратного, ядра и пользовательского. Слой аппаратного обеспечения включает в себя драйверы устройств, которые обеспечивают взаимодействие между ядром и аппаратным обеспечением.</p> <p>Слой ядра включает в себя различные подсистемы, такие как управление памятью, планировщик задач, управление файловой системой и сетевые подсистемы. Эти подсистемы обеспечивают работу ядра и взаимодействие с пользовательскими приложениями.</p> <p>Слой пользовательского пространства включает в себя все приложения и программы, которые работают в Linux. Ядро обеспечивает взаимодействие между пользовательскими приложениями и аппаратным обеспечением через драйверы устройств.</p> <p>Одним из основных компонентов ядра Linux является планировщик задач, который управляет выделением времени на процессоре для каждой задачи. Это позволяет управлять процессами и обеспечивает равномерное распределение ресурсов между приложениями.</p> <p>Другой важный компонент ядра Linux - это управление памятью. Ядро контролирует выделение памяти для каждого процесса и обеспечивает защиту от ошибок в программном обеспечении.</p> <p>Ядро Linux также включает в себя подсистемы управления файловой системой, которые обеспечивают доступ к файлам и каталогам на диске. Эти подсистемы поддерживают различные типы файловых систем, такие как ext4, NTFS и FAT.</p> <p>Ядро Linux также обеспечивает взаимодействие с сетью через сетевые подсистемы. Они позволяют подключаться к сети, обмениваться данными и управлять сетевыми ресурсами.</p> <p>Ядро Linux поставляется вместе с различными драйверами устройств, которые обеспечивают взаимодействие с аппаратным обеспечением. Эти драйверы управляют устройствами, такими как клавиатуры, мыши, принтеры, сетевые карты и многие другие.</p> <p>Ядро Linux также поддерживает многопоточность и многозадачность. Это означает, что множество задач может выполняться одновременно на одном компьютере, а каждая задача может иметь несколько потоков выполнения.</p> <p>Ядро Linux также поддерживает множество архитектур процессоров, таких как x86, ARM, MIPS и другие. Это позволяет использовать Linux на широком спектре устройств, включая персональные компьютеры, серверы, мобильные устройства и встроенные системы.</p> <p>Ядро Linux является открытым исходным кодом и имеет множество разработчиков, которые постоянно работают над его улучшением</p> <hr> <p>Ядро Linux играет важную роль в управлении памятью в компьютерной системе. Оно отвечает за управление физической памятью, виртуальной памятью и файловой системой.</p> <p>Физическая память - это область памяти в компьютере, в которой хранятся данные во время их обработки. Ядро Linux управляет доступом к физической памяти, а также отслеживает, какие участки памяти свободны и какие заняты.</p> <p>Виртуальная память - это механизм, который позволяет программам использовать больше памяти, чем доступно в физической памяти. Ядро Linux управляет виртуальной памятью, используя страницы памяти, которые могут быть загружены в физическую память по мере необходимости.</p> <p>Ядро Linux использует механизмы пагинации и сегментации для управления виртуальной памятью. Пагинация разбивает виртуальную память на страницы фиксированного размера, которые могут быть загружены в физическую память по мере необходимости. Сегментация разбивает виртуальную память на логические сегменты, такие как стек, куча и сегмент кода.</p> <p>Ядро Linux также использует механизм обмена страницами (swap), который позволяет временно хранить страницы памяти на жестком диске, когда физическая память заполнена. Это позволяет использовать больше памяти, чем доступно в физической памяти.</p> <p>Ядро Linux также поддерживает механизмы защиты памяти, которые позволяют изолировать память, используемую различными процессами. Это предотвращает ошибки доступа, которые могут привести к сбоям системы.</p> <p>Файловая система - это механизм, который используется для хранения и организации файлов на жестком диске. Ядро Linux управляет файловой системой, обеспечивая доступ к файлам и папкам, а также отслеживая изменения.</p> <p>Ядро Linux также поддерживает механизмы кэширования памяти, которые позволяют ускорить доступ к часто используемым данным. Кэширование памяти используется для хранения данных, которые были загружены из файловой системы или других источников, и которые могут быть повторно использованы в будущем.</p> <p>В целом, ядро Linux играет критическую роль в управлении памятью в компьютерной системе, обеспечивая доступ к памяти, управление виртуальной и физической памятью, управление файловой системой и механизмы защиты данных.</p> <hr> <p>Ядро Linux - это основная часть операционной системы Linux, которая управляет всеми аппаратными и программными ресурсами компьютера. Ядро связывает операционную систему и аппаратное обеспечение, обеспечивая функциональность устройств и управление ими.</p> <p>Ядро Linux использует драйвера устройств, которые отвечают за коммуникацию между ядром и устройствами. Драйвера устройств - это программы, которые позволяют ядру взаимодействовать с аппаратным обеспечением, такими как процессоры, жесткие диски, видеокарты, звуковые карты, сетевые интерфейсы и т.д.</p> <p>Драйвера устройств могут быть написаны как внутри самого ядра, так и как модули, которые загружаются в ядро при необходимости. Многие драйвера устройств уже встроены в ядро Linux, что делает его более компактным и быстрым. Однако, если нужен драйвер для конкретного устройства, можно загрузить модуль драйвера в ядро.</p> <p>Ядро Linux также использует интерфейс устройств, который позволяет приложениям и ядру взаимодействовать с устройствами. Интерфейс устройств предоставляет приложениям доступ к устройствам, таким как принтеры, сканеры, камеры, USB-устройства, и т.д.</p> <p>Устройства в Linux представляются в виде файлов. Каждое устройство имеет свой уникальный идентификатор, который можно использовать для обращения к нему из приложений. Файловая система Linux содержит специальные файлы, называемые устройствами символьных и блочных устройств, которые представляют физические устройства в системе.</p> <p>Ядро Linux также поддерживает механизмы системных вызовов, которые позволяют приложениям взаимодействовать с ядром. Системные вызовы - это функции, которые приложения могут вызывать для выполнения операций на уровне ядра, например, чтения или записи в файл, создания нового процесса или управления сетевыми интерфейсами.</p> <p>Также ядро Linux обеспечивает механизмы управления памятью, которые позволяют приложениям использовать память компьютера. Ядро управляет виртуальной памятью, которая представляет собой абстрактный слой между приложениями и физической памятью компьютера.</p> <p>В целом, ядро Linux является ключевым компонентом операционной системы, который обеспечивает работу с аппаратным обеспечением и управление им. Благодаря своей гибкости и расширяемости, ядро Linux может работать на широком спектре устройств, от мобильных телефонов до серверов.</p> <hr> <p>Ядро Linux является программным обеспечением, которое обеспечивает основные функции операционной системы. Одной из важнейших функций ядра Linux является работа с файловыми системами. Файловые системы позволяют пользователю хранить и организовывать файлы на жестком диске, а ядро Linux обеспечивает доступ к этим файлам.</p> <p>Одна из основных задач ядра Linux, связанных с файловыми системами, заключается в управлении доступом к файлам. Ядро контролирует доступ к файлам и папкам, определяет, какие пользователи имеют права на чтение и запись файлов, и обеспечивает защиту от несанкционированного доступа к файлам.</p> <p>Ядро Linux также отвечает за управление файловыми системами и их монтирование. Монтирование - это процесс подключения файловой системы к определенному разделу жесткого диска или другому устройству хранения данных. При запуске ядро Linux автоматически монтирует основную файловую систему, но пользователь может также монтировать другие файловые системы вручную.</p> <p>Ядро Linux поддерживает множество различных файловых систем, включая ext3, ext4, NTFS, FAT и многие другие. Каждая из этих файловых систем имеет свои уникальные особенности и применения. Ядро Linux должно быть способно работать с каждой из них, чтобы обеспечить максимальную гибкость и универсальность в работе с файлами.</p> <p>Кроме того, ядро Linux также отвечает за управление блоками данных на жестком диске. Оно определяет, какие блоки данных заняты, а какие свободны, и управляет процессом записи и чтения данных на жесткий диск.</p> <p>Ядро Linux также обеспечивает поддержку жестких дисков, USB-накопителей и других устройств хранения данных. Оно должно быть способно распознавать эти устройства и обеспечивать доступ к файлам на них.</p> <p>В целом, ядро Linux играет важную роль в работе с файловыми системами. Оно обеспечивает управление доступом к файлам, управление файловыми системами и их монтирование, поддержку различных файловых систем и управление блоками данных на жестком диске. Без ядра Linux, работа с файлами на компьютере была бы невозможна.</p> <hr> <p>Планировщик процессов является одной из ключевых компонентов ядра Linux и отвечает за распределение времени процессора между процессами. Он работает по принципу переключения между процессами с заданным интервалом времени, что позволяет каждому процессу &quot;думать&quot;, что он использует процессор на все 100%.</p> <p>Планировщик процессов в Linux использует очередь процессов, которые ждут выполнения. В этой очереди процессы располагаются по приоритету. Каждому процессу присваивается определенный приоритет, который может быть изменен в зависимости от текущей нагрузки на систему.</p> <p>Приоритеты процессов в Linux делятся на две категории: статические и динамические. Статические приоритеты устанавливаются при запуске процесса и остаются неизменными в течение всего времени его выполнения. Динамические приоритеты могут изменяться в зависимости от текущей нагрузки на систему, что позволяет более эффективно распределять вычислительные ресурсы.</p> <p>Планировщик процессов в Linux использует несколько алгоритмов планирования, в том числе:</p> <ul><li>Completely Fair Scheduler (CFS) - используется по умолчанию в Linux и обеспечивает справедливое распределение времени процессора между процессами с помощью алгоритма &quot;виртуального времени&quot;.</li> <li>Round Robin (RR) - простой алгоритм планирования, который распределяет время процессора между процессами в порядке их следования в очереди.</li> <li>Priority-based scheduling - используется для задания приоритетов процессам и распределения времени процессора в соответствии с этими приоритетами.</li></ul> <p>Планировщик процессов в Linux следит за тем, чтобы процессы получали нужное количество времени процессора, и управляет их выполнением. Он также отслеживает состояние процессов, в том числе их блокировку на ожидание ввода-вывода или других ресурсов, и пытается максимизировать использование процессора во всей системе.</p> <p>В целом, работа планировщика процессов в Linux крайне важна для обеспечения эффективной и безопасной работы системы, и его оптимизация может быть ключевым фактором в повышении производительности и стабильности системы.</p> <h2 id="written-by-chatsonic"><a href="#written-by-chatsonic" class="header-anchor">#</a> Written by Chatsonic</h2> <ol><li>Ядро Linux управляет памятью процессов в системе.</li> <li>Каждый процесс имеет свое адресное пространство в памяти.</li> <li>Ядро отслеживает доступность и использование памяти каждого процесса.</li> <li>Ядро управляет выделением и освобождением памяти процессов.</li> <li>Ядро использует виртуальную память для управления доступом к физической памяти.</li> <li>Виртуальная память позволяет процессам работать с большими объемами данных, чем физическая память.</li> <li>Ядро Linux использует страницы памяти для управления виртуальной памятью процессов.</li> <li>Каждая страница памяти имеет уникальный идентификатор (page frame number).</li> <li>Ядро отслеживает использование страниц памяти каждого процесса.</li> <li>Когда процесс запрашивает новую страницу памяти, ядро выделяет ее из свободных страниц памяти.</li> <li>Если свободных страниц памяти не хватает, ядро может освободить некоторые страницы из памяти других процессов.</li> <li>Этот процесс называется подкачкой.</li> <li>Ядро Linux использует файл подкачки для хранения страниц памяти, которые были вытеснены из физической памяти.</li> <li>Когда процесс обращается к странице памяти, которая была вытеснена, ядро загружает ее из файла подкачки.</li> <li>Этот процесс называется обменом страницами.</li> <li>Ядро Linux использует механизм кэширования страниц памяти для повышения производительности.</li> <li>Кэширование позволяет ядру быстро загружать страницы памяти, которые уже были использованы процессами.</li> <li>Ядро Linux использует механизмы блокировки для защиты доступа к памяти между процессами.</li> <li>Блокировки позволяют процессам работать с одной страницей памяти в одно и то же время.</li> <li>Ядро Linux использует механизм сегментации памяти для разделения адресного пространства процессов.</li> <li>Сегментация памяти позволяет ядру легко отслеживать использование памяти каждого процесса.</li> <li>Ядро Linux использует механизм разделения памяти для изоляции процессов друг от друга.</li> <li>Разделение памяти позволяет ядру предотвратить доступ процессов к памяти других процессов.</li> <li>Ядро Linux использует механизмы защиты памяти для предотвращения ошибок процессов.</li> <li>Защита памяти позволяет ядру предотвратить доступ процессов к неверным адресам памяти или к памяти других процессов.</li> <li>Ядро Linux использует механизмы управления памятью для определения, какие страницы памяти должны быть вытеснены из физической памяти.</li> <li>Управление памятью позволяет ядру эффективно использовать доступную физическую память.</li> <li>Ядро Linux использует механизмы сбора мусора для освобождения неиспользуемой памяти про</li></ol> <hr> <p>Ядро Linux управляет процессами и ресурсами, необходимыми для их выполнения. Оно следит за процессами, которые запущены на компьютере, и обеспечивает им доступ к ресурсам, таким как память, процессорное время и ввод-выводные устройства. Работа с процессами в Linux происходит следующим образом:</p> <ol><li>Ядро Linux создает новый процесс при запуске новой программы.</li> <li>Каждый процесс имеет свой уникальный идентификатор (PID).</li> <li>Ядро Linux обеспечивает механизмы межпроцессного взаимодействия, такие как сигналы и очереди сообщений.</li> <li>Ядро Linux может приостанавливать выполнение процессов и возобновлять его в нужный момент.</li> <li>Ядро Linux может управлять приоритетами процессов, определяя, какой процесс получает больше процессорного времени.</li> <li>Ядро Linux может управлять доступом процессов к ресурсам, таким как память и ввод-выводные устройства.</li> <li>Ядро Linux может обеспечивать безопасность процессов, ограничивая их действия в соответствии с правами пользователя.</li> <li>Ядро Linux может обнаруживать и устранять ошибки в работе процессов и предотвращать сбои в системе.</li> <li>Ядро Linux может управлять потоками процессов, позволяя им выполняться параллельно на нескольких процессорах.</li></ol> <hr> <p>Ядро Linux управляет процессами в операционной системе, включая их создание, управление и завершение. Когда пользователь запускает приложение, ядро создает новый процесс и назначает ему уникальный идентификатор процесса (PID). Ядро также назначает процессу ресурсы, такие как память, файлы и устройства ввода-вывода.</p> <p>Ядро отслеживает состояние процессов и может приостанавливать, возобновлять и завершать процессы в зависимости от их состояния и приоритета. Ядро использует планировщик процессов для распределения времени процессора между процессами и управления их выполнением.</p> <p>Каждый процесс имеет свою собственную область памяти, которая включает в себя код, данные и стек вызовов. Ядро использует механизмы защиты памяти для защиты памяти одного процесса от другого и от нежелательных операций.</p> <p>Ядро Linux также поддерживает многопоточность, что позволяет процессам выполнять несколько задач одновременно. Каждый поток имеет свой собственный стек вызовов и может использовать общие ресурсы процесса.</p> <p>Для взаимодействия между процессами ядро Linux предоставляет механизмы межпроцессного взаимодействия, такие как каналы, сокеты и сообщения. Эти механизмы позволяют процессам обмениваться данными и синхронизировать свою работу.</p> <p>В целом, ядро Linux является сердцем операционной системы, которое управляет процессами и ресурсами и обеспечивает эффективную и безопасную работу системы.</p> <hr> <hr> <p>Linux - это операционная система с открытым исходным кодом, которая является одной из самых популярных в мире. Она используется на серверах, настольных компьютерах и мобильных устройствах. Рассмотрим подробно строение и работу Linux.</p> <ol><li><p>Ядро Linux - это основная часть операционной системы, которая управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением.</p></li> <li><p>Ядро Linux состоит из набора драйверов устройств, которые обеспечивают взаимодействие с аппаратным обеспечением, а также из системных вызовов, которые обеспечивают взаимодействие с программным обеспечением.</p></li> <li><p>Файловая система - это способ организации данных на жестком диске. Linux поддерживает различные файловые системы, такие как ext4, NTFS, FAT32 и другие.</p></li> <li><p>Командная оболочка - это интерфейс между пользователем и операционной системой. В Linux используются различные командные оболочки, такие как Bash, Zsh, Ksh и другие.</p></li> <li><p>Система управления пакетами - это программное обеспечение, которое обеспечивает установку, обновление и удаление программ на компьютере. В Linux используются различные системы управления пакетами, такие как APT, Yum, Pacman и другие.</p></li> <li><p>Демоны - это программы, которые выполняются в фоновом режиме и обеспечивают работу различных сервисов на компьютере.</p></li> <li><p>Сетевые подсистемы - это компоненты операционной системы, которые обеспечивают работу сетевых интерфейсов и протоколов, таких как TCP/IP, DNS, HTTP и другие.</p></li> <li><p>Утилиты командной строки - это программы, которые запускаются из командной строки и обеспечивают выполнение различных задач, таких как управление файлами и каталогами, работа с сетью и т.д.</p></li> <li><p>Графический интерфейс пользователя - это компонент операционной системы, который обеспечивает взаимодействие пользователя с компьютером через графический интерфейс.</p></li> <li><p>Система инициализации - это компонент операционной системы, который запускает и управляет другими компонентами системы при старте компьютера.</p></li> <li><p>Системные вызовы - это функции, которые позволяют программам взаимодействовать с ядром операционной системы.</p></li> <li><p>Программное обеспечение, которое выполняется на Linux, обычно разделяется на два типа: пользовательское программное обеспечение и системное программное обеспечение.</p></li> <li><p>Пользовательское программное обеспечение - это программы, которые предназначены для использования конечными пользователями, например, браузеры, текстовые редакторы, графические редакторы и т.д.</p></li> <li><p>Системное программное обеспечение - это программы, которые обеспечивают работу операционной системы, например, ядро Linux, драйверы устройств, системные утилиты и т.д.</p></li> <li><p>Для управления файлами и каталогами в Linux используются команды</p></li></ol> <p>Written by Chatsonic</p> <p><strong>Q: Что такое ядро Linux?</strong></p> <p>A: Ядро Linux - это программное обеспечение, которое управляет ресурсами компьютера и обеспечивает взаимодействие между аппаратным и программным обеспечением. Оно является основой операционной системы Linux.</p> <p><strong>Q: Как установить ядро Linux?</strong></p> <p>A: Установка ядра Linux зависит от дистрибутива, который вы используете. Обычно ядро Linux уже установлено на большинстве дистрибутивов Linux. Если вам нужна более новая версия ядра, вы можете скачать и скомпилировать ее самостоятельно.</p> <p><strong>Q: Как проверить версию ядра Linux?</strong></p> <p>A: Чтобы проверить версию ядра Linux, вы можете воспользоваться командой &quot;uname -r&quot; в терминале. Она выведет текущую версию ядра.</p> <p><strong>Q: Как обновить ядро Linux?</strong></p> <p>A: Обновление ядра Linux также зависит от дистрибутива. Обычно для обновления ядра нужно скачать новую версию и скомпилировать ее самостоятельно. Некоторые дистрибутивы Linux предлагают автоматическое обновление ядра через менеджер пакетов.</p> <p><strong>Q: Какие драйверы нужны для ядра Linux?</strong></p> <p>A: Для работы с различным аппаратным обеспечением на компьютере могут потребоваться различные драйверы для ядра Linux. Однако большинство драйверов уже включены в само ядро Linux.</p> <p><strong>Q: Какие есть альтернативы ядру Linux?</strong></p> <p>A: Существуют различные операционные системы, которые не используют ядро Linux, например, Windows, MacOS, iOS, Android и многие другие. Однако Linux является одним из наиболее популярных и широко используемых ядер в мире.</p> <p><strong>Q: Что такое IPC в Linux?</strong></p> <p>A: IPC (Inter-Process Communication) - это механизм, который позволяет процессам взаимодействовать друг с другом в Linux. IPC может быть осуществлено посредством различных методов, таких как сокеты, каналы, сигналы, разделяемая память и межпроцессные очереди.</p> <p><strong>Q: Какие методы IPC доступны в Linux?</strong></p> <p>A: В Linux доступны различные методы межпроцессного взаимодействия, включая:</p> <ul><li>Сокеты</li> <li>Каналы</li> <li>Сигналы</li> <li>Разделяемая память</li> <li>Межпроцессные очереди</li></ul> <p><strong>Q: Как выбрать подходящий метод IPC для своего приложения?</strong></p> <p>A: Выбор подходящего метода IPC зависит от требований конкретного приложения. Например, для передачи больших объемов данных разделяемая память может быть наиболее эффективным методом, в то время как для передачи сообщений между процессами лучше использовать межпроцессные очереди или сокеты. Важно учитывать особенности каждого метода и выбирать наиболее подходящий для конкретной задачи.</p> <p><strong>Q: Что такое архитектура ядра Linux?</strong></p> <p>A: Архитектура ядра Linux - это общий план, который определяет структуру и организацию ядра Linux. Это включает в себя различные слои и подсистемы, такие как планировщик, файловая система, система управления памятью и другие.</p> <p><strong>Q: Какова внутренняя структура ядра Linux?</strong></p> <p>A: Внутренняя структура ядра Linux состоит из различных компонентов, таких как системный вызов, планировщик, драйверы устройств, файловая система, система управления памятью и другие. Каждый компонент выполняет свою функцию и взаимодействует с другими компонентами, чтобы обеспечить правильное функционирование операционной системы.</p> <p><strong>Q: Какова роль планировщика в ядре Linux?</strong></p> <p>A: Планировщик ядра Linux отвечает за распределение процессорного времени между различными процессами. Он использует различные алгоритмы планирования, чтобы определить, какой процесс должен выполняться в данный момент и на какое время. Это гарантирует, что процессы работают эффективно и не блокируют друг друга.</p> <p><strong>Q: Какова роль файловой системы в ядре Linux?</strong></p> <p>A: Файловая система является ключевой компонентой ядра Linux, которая управляет файлами и каталогами на диске. Она обеспечивает интерфейс для чтения, записи и удаления файлов, а также для создания и удаления каталогов. Кроме того, файловая система включает в себя различные функции, такие как защита файлов и управление правами</p> <ol><li><p>Ядро Linux - главный компонент, который управляет ресурсами и предоставляет интерфейс для общения между аппаратным обеспечением и программным обеспечением.</p></li> <li><p>Драйверы устройств - компоненты, которые обеспечивают поддержку аппаратных устройств в системе.</p></li> <li><p>Файловая система - структура для хранения и организации файлов на диске.</p></li> <li><p>Виртуальная файловая система - абстрактный слой, который обеспечивает единый интерфейс для работы с файловыми системами.</p></li> <li><p>Системные вызовы - интерфейс для взаимодействия между программами и ядром Linux.</p></li> <li><p>Процессы - работающие программы в операционной системе.</p></li> <li><p>Планировщик задач - компонент, который управляет выполнением процессов и планирует их работу на процессоре.</p></li> <li><p>Управление памятью - компонент, который управляет доступом к памяти и осуществляет ее выделение и освобождение.</p></li> <li><p>Управление файлами - компонент, который управляет файлами и каталогами в файловой системе.</p></li> <li><p>Сетевой стек - совокупность компонентов, которые обеспечивают поддержку сетевых протоколов и коммуникацию в сети.</p></li> <li><p>Управление учетными записями - компонент, который управляет пользователями и группами в системе.</p></li> <li><p>Утилиты командной строки - утилиты, которые позволяют выполнять команды и скрипты в терминале.</p></li> <li><p>Графические интерфейсы - компоненты, которые позволяют работать с графической оболочкой и графическими приложениями.</p></li> <li><p>Библиотеки - компоненты, которые содержат программный код, используемый другими приложениями.</p></li> <li><p>Файлы конфигурации - файлы, которые содержат настройки и параметры для приложений и системы.</p></li> <li><p>Интерпретаторы - компоненты, которые позволяют выполнять скрипты и интерпретировать код на различных языках программирования.</p></li> <li><p>Утилиты мониторинга - утилиты, которые позволяют мониторить работу системы и процессов.</p></li> <li><p>Сервисы - компоненты, которые предоставляют определенные функции и сервисы в системе.</p></li> <li><p>Системные журналы - журналы, которые содержат информацию о работе системы и приложений.</p></li> <li><p>Системные утилиты - утилиты, которые обеспечивают управление и настройку системы.</p></li> <li><p>Загрузчик - программа, которая загружает ядро и начинает процесс загрузки операционной системы.</p></li> <li><p>Ядро - основная часть операционной системы, которая управляет ресурсами компьютера, включая процессор, память, устройства ввода-вывода и файловую систему.</p></li> <li><p>Драйверы устройств - программы, которые управляют работой устройств в компьютере, таких как клавиатура, мышь, дисплей и т.д.</p></li> <li><p>Библиотеки - наборы программных компонентов, которые используются при разработке приложений.</p></li> <li><p>Утилиты командной строки - программы, которые выполняются в командной строке и обеспечивают управление системой и приложениями.</p></li> <li><p>Графический сервер - компонент операционной системы, который управляет работой графической среды и приложений.</p></li> <li><p>Графические библиотеки - наборы программных компонентов, которые используются при разработке графических приложений.</p></li> <li><p>Графические приложения - программы, которые используются для работы с графической средой, такие как браузеры, текстовые редакторы и т.д.</p></li> <li><p>Системные вызовы - интерфейс между ядром операционной системы и приложениями, который обеспечивает доступ к ресурсам системы.</p></li> <li><p>Пользовательские приложения - программы, которые используются для выполнения задач пользователей, такие как обработка текста, работа с графикой и т.д.</p></li> <li><p>Базы данных - программы, которые обеспечивают хранение и управление данными.</p></li> <li><p>Средства разработки - наборы программных инструментов, которые используются для разработки приложений.</p></li> <li><p>Сетевые протоколы - протоколы, которые обеспечивают связь между компьютерами в сети.</p></li> <li><p>Сетевые утилиты - программы, которые обеспечивают управление сетью и диагностику проблем.</p></li> <li><p>Серверные приложения - программы, которые выполняются на сервере и обеспечивают доступ клиентов к ресурсам сервера.</p></li> <li><p>Системные журналы - журналы, которые содержат информацию о работе системы и приложений.</p></li> <li><p>Файловая система - система, которая управляет хранением и организацией файлов и каталогов на диске.</p></li> <li><p>Защита и безопасность - компоненты операционной системы, которые обеспечивают защиту от несанкционированного доступа к системе и ее данным.</p></li> <li><p>Системные настройки - настройки, которые позволяют пользователям настраивать и управлять системой, такие как язык интерфейса, настройки сети и т.д.</p></li> <li><p>Обновление и управление программным обеспечением - программы, которые обеспечивают управление установкой и обновлением приложений и компонентов операционной системы.</p></li></ol> <hr> <p>The Linux kernel is a complex system consisting of various components that work together to provide a stable and efficient operating system. The kernel is responsible for managing system resources such as memory, input/output devices, and CPU scheduling. In this article, we will explore the different components of the Linux kernel and how they work together.</p> <p>Process Management: One of the most important functions of the Linux kernel is process management. The kernel is responsible for creating, starting, and stopping processes. It also manages process scheduling, which determines which process gets to use the CPU at any given time.</p> <p>Memory Management: The kernel is also responsible for memory management. This includes allocating and deallocating memory for processes, managing virtual memory, and implementing memory protection mechanisms.</p> <p>Input/Output (I/O) Management: The Linux kernel also manages I/O operations. This includes managing disk and network I/O operations and providing a uniform interface for accessing these devices. The kernel also provides buffering and caching mechanisms to improve performance.</p> <p>File System Management: The kernel provides a file system abstraction that allows programs to access files and directories in a uniform way. The kernel also includes support for various file system types, including ext4, NTFS, and FAT32.</p> <p>Networking: The kernel provides networking support, including support for various network protocols such as TCP/IP, UDP, and ICMP. The kernel also includes drivers for network devices such as Ethernet and Wi-Fi cards.</p> <p>Device Drivers: The kernel includes device drivers that allow it to communicate with various hardware devices such as graphics cards, sound cards, and USB devices. These drivers are responsible for managing the device and providing a uniform interface for accessing it.</p> <p>Kernel Security: The Linux kernel includes various security features, including access control mechanisms, memory protection mechanisms, and support for encryption.</p> <p>In conclusion, the Linux kernel is a complex system consisting of various components that work together to provide a stable and efficient operating system. Each component has its own specific tasks and responsibilities, and they all work together to provide a seamless user experience. Understanding how these components work is essential for developers and system administrators who work with Linux systems.</p> <hr> <p>The Linux scheduler is responsible for determining which process should get CPU time and for how long. It does this by using a variety of scheduling policies, each of which is designed to handle different types of workloads.</p> <p>Completely Fair Scheduler (CFS) is the default scheduling policy in Linux since version 2.6.23. CFS aims to provide fair sharing of CPU time among all processes. It does this by dividing the CPU time in a way that is proportional to the amount of work each process has done. CFS uses Red-Black Trees to keep track of the current state of the system, which allows it to make scheduling decisions quickly and efficiently.</p> <p>Another scheduling policy used in Linux is Brain Fuck Scheduler (BFS). BFS is designed to prioritize interactive processes over batch processes. It does this by using a virtual deadline formula to prioritize processes. However, BFS has an O(n) time complexity, which makes it slow and inefficient for large systems.</p> <p>Rotating Staircase Deadline Scheduler (RSDL) is another scheduling policy used in Linux. RSDL is designed to provide better handling of I/O-bound processes. It uses a multi-level scheduling algorithm to prioritize processes based on their deadlines. RSDL is particularly useful for systems that have a mix of CPU-bound and I/O-bound processes.</p> <p>Overall, the Linux scheduler is a complex system that uses a variety of scheduling policies to provide fair sharing of CPU time among all processes. Understanding how these policies work is essential for developers and system administrators who work with Linux systems.</p> <hr> <p>The Linux kernel provides a powerful set of networking features that allow it to manage network devices and protocols efficiently. Some of the core network management features of the Linux kernel include:</p> <ol><li><p>Network Device Drivers: The Linux kernel includes drivers for various network devices, such as Ethernet cards, Wi-Fi cards, and modems. These drivers provide a uniform interface for accessing the devices and manage the communication between the device and the kernel.</p></li> <li><p>Network Protocols: The Linux kernel supports a wide range of network protocols, including TCP/IP, UDP, ICMP, and many others. These protocols are implemented in the kernel and provide the basic building blocks for network communication.</p></li> <li><p>Network Stack: The Linux kernel includes a network stack that handles network communication. This stack is responsible for managing network protocols, routing network traffic, and handling network I/O operations.</p></li> <li><p>Socket API: The Linux kernel provides a socket API that allows applications to communicate with the network stack. The socket API provides a uniform interface for accessing network resources and allows applications to send and receive network data.</p></li> <li><p>Netfilter: Netfilter is a powerful packet filtering framework included in the Linux kernel. It allows administrators to filter and modify network packets as they pass through the network stack. Netfilter is widely used for implementing firewalls, packet shaping, and quality of service (QoS) systems.</p></li> <li><p>IPTables: IPTables is a command-line utility that provides a user-friendly interface for configuring Netfilter rules. It allows administrators to filter and modify network packets based on a wide range of criteria, such as source IP address, destination IP address, and protocol type.</p></li></ol> <p>Overall, the Linux kernel provides a comprehensive set of network management features that allow it to manage network devices and protocols efficiently. Understanding how these features work is essential for developers and system administrators who work with Linux systems.</p> <hr> <p>The networking stack in the Linux kernel works differently depending on the type of network communication being used. Here are some examples of how the networking stack works in different cases:</p> <ol><li>TCP/IP Communication:</li></ol> <p>Scheme: Application -&gt; Socket API -&gt; TCP -&gt; IP -&gt; Network Driver -&gt; Physical Device</p> <p>Algorithm:</p> <ol><li><p>The application creates a socket and uses the socket API to connect to a remote server.</p></li> <li><p>The socket API sends the connection request to the TCP layer.</p></li> <li><p>The TCP layer establishes a connection with the remote server.</p></li> <li><p>The TCP layer sends data to the IP layer.</p></li> <li><p>The IP layer adds the appropriate headers to the data and sends it to the network driver.</p></li> <li><p>The network driver sends the data to the physical device for transmission over the network.</p></li></ol> <p>UDP Communication:</p> <p>Scheme: Application -&gt; Socket API -&gt; UDP -&gt; IP -&gt; Network Driver -&gt; Physical Device</p> <p>Algorithm:</p> <ol><li><p>The application creates a socket and uses the socket API to send data to a remote server.</p></li> <li><p>The socket API sends the data to the UDP layer.</p></li> <li><p>The UDP layer adds the appropriate headers to the data and sends it to the IP layer.</p></li> <li><p>The IP layer adds the appropriate headers to the data and sends it to the network driver.</p></li> <li><p>The network driver sends the data to the physical device for transmission over the network.</p></li></ol> <p>ICMP Communication:</p> <p>Scheme: Application -&gt; Socket API -&gt; ICMP -&gt; IP -&gt; Network Driver -&gt; Physical Device</p> <p>Algorithm:</p> <ol><li>The application creates a socket and uses the socket API to send an ICMP packet to a remote server.</li> <li>The socket API sends the ICMP packet to the ICMP layer.</li> <li>The ICMP layer adds the appropriate headers to the packet and sends it to the IP layer.</li> <li>The IP layer adds the appropriate headers to the packet and sends it to the network driver.</li> <li>The network driver sends the packet to the physical device for transmission over the network.</li></ol> <p>Overall, the Linux networking stack follows a similar pattern for all types of network communication. The application communicates with the socket API, which then communicates with the appropriate protocol layer. The protocol layer adds appropriate headers to the data and sends it to the IP layer, which in turn sends it to the network driver for transmission over the network.</p> <hr> <p>Network Routing:</p> <p>Scheme: Application -&gt; Socket API -&gt; Routing Table -&gt; Network Driver -&gt; Physical Device</p> <p>Algorithm:</p> <ol><li>The application creates a socket and uses the socket API to send data to a remote server.</li> <li>The routing table is consulted to determine the best route for the data.</li> <li>The network driver sends the data to the appropriate physical device for transmission over the network.</li></ol> <p>The routing table is a key component of the Linux networking stack, and it is used to determine the best route for data based on the destination IP address. The routing table contains a list of network destinations and the best route for reaching each destination. The routing decision is based on the destination IP address and the network mask. The network driver is responsible for sending the data to the appropriate physical device for transmission over the network.</p> <p>Overall, the Linux networking stack uses the routing table to determine the best route for data and then sends the data to the appropriate physical device for transmission over the network. Understanding how routing works is essential for developers and system administrators who work with Linux systems.</p> <hr> <p>Dynamic routing programs are a key component of the Linux networking stack, and they are used to automatically discover and update network routes. Dynamic routing programs use a variety of protocols, such as Routing Information Protocol (RIP), Open Shortest Path First (OSPF), and Border Gateway Protocol (BGP), to exchange routing information with other devices on the network.</p> <p>Dynamic routing programs work by periodically sending and receiving routing updates to and from other devices on the network. These updates contain information about the network topology, such as the availability of network devices and the best routes for reaching different destinations. Based on this information, the dynamic routing program updates the routing table to reflect the current state of the network.</p> <p>One of the key advantages of dynamic routing programs is that they are able to adapt to changes in the network topology in real-time. For example, if a network device fails or a new device is added to the network, the dynamic routing program will automatically update the routing table to reflect the new topology. This ensures that data is always sent along the most efficient route and helps to prevent network congestion and delays.</p> <p>However, dynamic routing programs can also be complex and resource-intensive. They require significant processing power and memory to manage the routing updates and to maintain the routing table. In addition, misconfigurations or errors in the dynamic routing program can lead to network instability or security vulnerabilities.</p> <p>Overall, dynamic routing programs play a critical role in the Linux networking stack by providing automatic discovery and updating of network routes. Understanding how these programs work is essential for developers and system administrators who work with Linux systems, and can help to ensure that networks are efficient, reliable, and secure.</p> <hr> <p>XDP_COPY is a feature in the Linux kernel that allows for zero-copy packet processing using the eXpress Data Path (XDP) framework. With XDP_COPY, network packets can be processed without copying them into kernel memory, which can significantly reduce the CPU overhead and improve network performance.</p> <p>When a network packet arrives at the network interface, it is first processed by the XDP program attached to the interface. If the XDP program returns XDP_PASS, the packet is forwarded to the kernel network stack for further processing. However, if the XDP program returns XDP_TX or XDP_REDIRECT, the packet is processed by the XDP_COPY mechanism.</p> <p>XDP_COPY works by creating a copy of the network packet in a memory buffer, which is then passed to the kernel network stack for further processing. The original network packet is left untouched, and the XDP program can continue processing other packets without blocking.</p> <p>One of the key benefits of XDP_COPY is that it allows for efficient packet processing in high-speed networks. By avoiding the need to copy packets into kernel memory, XDP_COPY can significantly reduce the CPU overhead and improve network throughput.</p> <p>However, there are some limitations to using XDP_COPY. For example, it can increase memory usage and latency, and it may not be suitable for all network traffic patterns. It is important to carefully evaluate the trade-offs of using XDP_COPY for a specific network application.</p> <p>Overall, XDP_COPY is a powerful feature in the Linux kernel that can help to improve network performance in high-speed networks. Understanding how it works and when to use it is essential for developers and system administrators who work with Linux networking.</p> <hr> <p>Sure, as a developer of the Linux core, here's a possible table of contents for a book I would write:</p> <p><strong>Chapter 1: Introduction</strong></p> <ul><li>Overview of Linux and its history</li> <li>The role of the Linux kernel</li> <li>Understanding the Linux ecosystem</li></ul> <p><strong>Chapter 2: Linux Kernel Architecture</strong></p> <ul><li>Kernel architecture overview</li> <li>Kernel space vs User space</li> <li>Process management and scheduling</li> <li>Memory management</li></ul> <p><strong>Chapter 3: Kernel Modules and Device Drivers</strong></p> <ul><li>Understanding kernel modules</li> <li>Developing and deploying kernel modules</li> <li>Device drivers and their role in the kernel</li></ul> <p><strong>Chapter 4: System Calls and Interprocess Communication</strong></p> <ul><li>System calls and their role in the kernel</li> <li>Understanding interprocess communication (IPC)</li> <li>IPC mechanisms in the Linux kernel</li></ul> <p><strong>Chapter 5: File Systems and Storage</strong></p> <ul><li>Overview of file systems in Linux</li> <li>Virtual file system (VFS) layer</li> <li>Storage management and file system types</li> <li>File system performance tuning</li></ul> <p><strong>Chapter 6: Network Stack</strong></p> <ul><li>Overview of the Linux network stack</li> <li>Network protocols and their implementation</li> <li>Socket programming and network applications</li></ul> <p><strong>Chapter 7: Security and Performance</strong></p> <ul><li>Linux security mechanisms</li> <li>Performance tuning and optimization techniques</li> <li>Kernel profiling and debugging</li></ul> <p><strong>Chapter 8: Future of the Linux Kernel</strong></p> <ul><li>Emerging trends in Linux development</li> <li>The future of the Linux kernel</li> <li>The role of community in Linux development</li></ul> <p><strong>Chapter 9: Conclusion</strong></p> <ul><li>Summary of the book</li> <li>Final thoughts on Linux kernel development</li></ul> <p>This is just one possible table of contents, and there are many other topics that could be included in a book on Linux kernel development depending on the author's goals and audience.</p> <hr> <p>Chapter 1 of the proposed book provides an introduction to Linux and its history, outlining the role of the Linux kernel and the ecosystem surrounding it. The chapter explains that Linux is an open-source operating system that is used in a wide range of devices, from servers to smartphones. It also discusses the history of Linux, including Linus Torvalds' initial development of the kernel and the growth of the Linux community. Finally, the chapter touches on the various components of the Linux ecosystem, including distributions, package managers, and the GNU tools that are commonly used with Linux.</p> <hr> <p>Chapter 2 of the book focuses on the architecture of the Linux kernel. It starts by providing an overview of the kernel architecture and explores the difference between kernel space and user space. The chapter then delves into the process management and scheduling mechanisms used by the kernel, as well as memory management techniques. By the end of the chapter, readers should have a good understanding of the architecture of the Linux kernel and how it manages processes and memory.</p> <hr> <p>Chapter 3 of the book goes in-depth on the subject of kernel modules and device drivers. It begins with a detailed explanation of kernel modules, what they are, and how they work. The chapter then covers the process of developing and deploying kernel modules, including compiling, loading, and unloading. It also explains the role of device drivers in the kernel and how they interact with hardware. The chapter covers several types of device drivers and provides examples of how to develop them. By the end of the chapter, readers should have a solid understanding of how kernel modules and device drivers work in the Linux kernel.</p> <hr> <p>Chapter 3: Kernel Modules and Device Drivers</p> <p>One of the key features of the Linux kernel is its modular architecture. The kernel is designed to be modular, which means that functionality can be added or removed from the kernel at runtime by loading and unloading kernel modules. A kernel module is a piece of code that can be loaded into the kernel to provide additional functionality.</p> <h2 id="kernel-modules"><a href="#kernel-modules" class="header-anchor">#</a> Kernel Modules</h2> <p>Kernel modules are an essential part of the Linux kernel. They are used to add new functionality to the kernel without the need to recompile the entire kernel. Kernel modules can be loaded and unloaded at runtime without affecting the running system. This means that new functionality can be added to a running system without the need to reboot.</p> <p>To develop a kernel module, you need to have a basic understanding of the kernel architecture and programming in the C language. The development process involves writing the code for the module and compiling it into a loadable kernel module (LKM). Once the module is compiled, it can be loaded into the kernel using the <code>insmod</code> command.</p> <h2 id="device-drivers"><a href="#device-drivers" class="header-anchor">#</a> Device Drivers</h2> <p>A device driver is a piece of code that allows the kernel to communicate with hardware devices. The kernel communicates with devices through the use of device drivers. Device drivers are essential to the operation of the kernel as they provide a bridge between the hardware and the operating system.</p> <p>Device drivers are typically written in the C language and follow a specific interface defined by the kernel. There are several types of device drivers, including character device drivers, block device drivers, and network device drivers. Each type of driver is responsible for handling a specific type of device.</p> <h2 id="developing-device-drivers"><a href="#developing-device-drivers" class="header-anchor">#</a> Developing Device Drivers</h2> <p>Developing a device driver for Linux involves writing code that interacts with the hardware through the device driver interface. The driver needs to be able to communicate with the hardware, handle interrupts, and manage data transfer between the device and the kernel.</p> <p>In addition to writing the driver code, you also need to create a device file that corresponds to the driver. The device file is used by the operating system to communicate with the driver.</p> <h2 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion</h2> <p>Kernel modules and device drivers are essential components of the Linux kernel. They provide the flexibility and extensibility that make Linux such a powerful operating system. Understanding how kernel modules and device drivers work is essential for anyone interested in developing for the Linux platform. With this knowledge, you can develop custom functionality for the kernel and hardware devices.</p> <hr> <p>Chapter 4: System Calls and User Space</p> <p>The Linux kernel provides a mechanism for user-level applications to interact with the kernel through a set of APIs called system calls. This chapter will explore the system call interface and the user space components of Linux.</p> <h2 id="system-calls"><a href="#system-calls" class="header-anchor">#</a> System Calls</h2> <p>The Linux kernel provides over 300 system calls, which allow user-level applications to request services from the kernel. System calls provide a way for user space applications to interact with the kernel, such as reading and writing files, allocating memory, and creating new processes.</p> <p>System calls are accessed through the C library, which wraps the system call interface and provides a standardized API for user-level applications. Understanding the system call interface is essential for Linux application development.</p> <h2 id="user-space-components"><a href="#user-space-components" class="header-anchor">#</a> User Space Components</h2> <p>User space components are the applications and libraries that run in a separate address space from the kernel. In Linux, user space components are typically written in C, C++, or other programming languages.</p> <p>User space components include system utilities, command-line applications, graphical user interfaces, and web applications. These components interact with the kernel through system calls and other kernel interfaces, such as the proc filesystem.</p> <h2 id="conclusion-2"><a href="#conclusion-2" class="header-anchor">#</a> Conclusion</h2> <p>The system call interface and user space components are essential parts of the Linux operating system. Understanding how these components work is necessary for developing Linux applications and system administration. In the next chapter, we will explore file systems and storage management in Linux.</p> <hr> <p>As an AI language model, I can provide you with a list of 300 Linux syscalls with their short descriptions. Please note that the descriptions provided here are brief and may not cover all the details of each syscall.</p> <ol><li><code>access</code> - check file access permissions</li> <li><code>acct</code> - enable/disable process accounting</li> <li><code>add_key</code> - add a key to the kernel keyring</li> <li><code>adjtimex</code> - adjust kernel time variables</li> <li><code>afs_syscall</code> - unimplemented system calls for AFS</li> <li><code>alarm</code> - set an alarm clock for delivery of a signal</li> <li><code>arch_prctl</code> - set architecture-specific thread state</li> <li><code>bdflush</code> - start or stop background writeback of dirty buffers</li> <li><code>bind</code> - bind a name to a socket</li> <li><code>bpf</code> - perform BPF system calls</li> <li><code>break</code> - change the limit of the stack segment</li> <li><code>brk</code> - change the location of the program break</li> <li><code>cacheflush</code> - flush or invalidate cache contents</li> <li><code>capget</code> - get process capabilities</li> <li><code>capset</code> - set process capabilities</li> <li><code>chdir</code> - change current working directory</li> <li><code>chmod</code> - change file mode bits</li> <li><code>chown</code> - change file owner and group</li> <li><code>chroot</code> - change root directory</li> <li><code>clock_getres</code> - get clock resolution</li> <li><code>clock_gettime</code> - get time from a specified clock</li> <li><code>clock_nanosleep</code> - high-resolution sleep</li> <li><code>clone</code> - create a new process</li> <li><code>close</code> - close a file descriptor</li> <li><code>connect</code> - initiate a connection on a socket</li> <li><code>creat</code> - create a new file or truncate an existing file</li> <li><code>create_module</code> - create a loadable kernel module</li> <li><code>delete_module</code> - delete a loadable kernel module</li> <li><code>dup</code> - duplicate a file descriptor</li> <li><code>dup2</code> - duplicate a file descriptor to a specified file descriptor</li> <li><code>dup3</code> - duplicate a file descriptor to a specified file descriptor with flags</li> <li><code>epoll_create</code> - create an epoll instance</li> <li><code>epoll_create1</code> - create an epoll instance with flags</li> <li><code>epoll_ctl</code> - control an epoll instance</li> <li><code>epoll_wait</code> - wait for events on an epoll instance</li> <li><code>eventfd</code> - create a file descriptor for event notification</li> <li><code>eventfd2</code> - create a file descriptor for event notification with flags</li> <li><code>execve</code> - execute a program</li> <li><code>exit</code> - terminate the calling process</li> <li><code>exit_group</code> - terminate all threads in a process</li> <li><code>faccessat</code> - check file access permissions relative to a directory file descriptor</li> <li><code>fadvise64</code> - predeclare an access pattern for file data</li> <li><code>fallocate</code> - manipulate file space</li> <li><code>fanotify_init</code> - initialize a fanotify group</li> <li><code>fanotify_mark</code> - add, remove, or modify an fanotify mark on a filesystem object</li> <li><code>fchdir</code> - change current working directory relative to a file descriptor</li> <li><code>fchmod</code> - change file mode bits relative to a file descriptor</li> <li><code>fchmodat</code> - change file mode bits relative to a directory file descriptor</li> <li><code>fchown</code> - change file owner and group relative to a file descriptor</li> <li><code>fchownat</code> - change file owner and group relative to a directory file descriptor</li> <li><code>fcntl</code> - manipulate file descriptor</li> <li><code>fdatasync</code> - synchronize a file's in-core state with storage device</li> <li><code>fgetxattr</code> - get an extended attribute value</li> <li><code>finit_module</code> - load a kernel module</li> <li><code>flistxattr</code> - list extended attribute names</li> <li><code>flock</code> - apply or remove an advisory lock on an open file</li> <li><code>fork</code> - create a new process</li> <li><code>fremovexattr</code> - remove an extended attribute</li> <li><code>fsetxattr</code> - set an extended attribute value</li> <li><code>fstat</code> - get file status</li> <li><code>fstatat</code> - get file status relative to a directory file descriptor</li> <li><code>fstatfs</code> - get file system statistics</li> <li><code>fsync</code> - synchronize a file's in-core state with storage device</li> <li><code>ftruncate</code> - truncate a file to a specified length</li> <li><code>futex</code> - fast user-space locking</li> <li><code>futimesat</code> - change file timestamps relative to a directory file descriptor</li> <li><code>getcpu</code> - determine CPU and NUMA node on which the calling thread is running</li> <li><code>getcwd</code> - get current working directory</li> <li><code>getdents</code> - get directory entries</li> <li><code>getdents64</code> - get directory entries with 64-bit inode numbers</li> <li><code>getegid</code> - get effective group ID</li> <li><code>geteuid</code> - get effective user ID</li> <li><code>getgid</code> - get real group ID</li> <li><code>getgroups</code> - get list of supplementary group IDs</li> <li><code>getitimer</code> - get value of interval timer</li> <li><code>getpeername</code> - get name of connected peer socket</li> <li><code>getpgid</code> - get process group ID of a process</li> <li><code>getpgrp</code> - get process group ID of calling process</li> <li><code>getpid</code> - get process ID of calling process</li> <li><code>getppid</code> - get parent process ID</li> <li><code>getpriority</code> - get program scheduling priority</li> <li><code>getrandom</code> - obtain a series of random bytes</li> <li><code>getresgid</code> - get real, effective, and saved set group ID</li> <li><code>getresuid</code> - get real, effective, and saved set user ID</li> <li><code>getrlimit</code> - get/set resource limits</li> <li><code>getrusage</code> - get resource usage</li> <li><code>getsid</code> - get session ID</li> <li><code>getsockname</code> - get name of local socket</li> <li><code>getsockopt</code> - get and set options on sockets</li> <li><code>gettid</code> - get thread ID</li> <li><code>gettimeofday</code> - get time of day</li> <li><code>getuid</code> - get real user ID</li> <li><code>getxattr</code> - get an extended attribute value</li> <li><code>init_module</code> - load a kernel module</li> <li><code>inotify_add_watch</code> - add a watch to an inotify instance</li> <li><code>inotify_init</code> - initialize an inotify instance</li> <li><code>inotify_init1</code> - initialize an inotify instance with flags</li> <li><code>inotify_rm_watch</code> - remove a watch from an inotify instance</li> <li><code>io_cancel</code> - cancel an outstanding asynchronous I/O operation</li> <li><code>ioctl</code> - control device</li> <li><code>io_destroy</code> - destroy an asynchronous I/O context</li> <li><code>io_getevents</code> - retrieve the results of asynchronous I/O operations</li> <li><code>ioprio_get</code> - get I/O scheduling class and priority</li> <li><code>ioprio_set</code> - set I/O scheduling class and priority</li> <li><code>kcmp</code> - compare two processes to determine similarities and differences</li> <li><code>kexec_file_load</code> - load a new kernel for later execution</li> <li><code>kexec_load</code> - load a new kernel for later execution</li> <li><code>keyctl</code> - manipulate the kernel's key management facility</li> <li><code>kill</code> - send a signal to a process</li> <li><code>lchown</code> - change file owner and group</li> <li><code>lgetxattr</code> - get an extended attribute value</li> <li><code>link</code> - make a hard link</li> <li><code>linkat</code> - make a hard link relative to a directory file descriptor</li> <li><code>listen</code> - listen for connections on a socket</li> <li><code>listxattr</code> - list extended attribute names</li> <li><code>llistxattr</code> - list extended attribute names with long inode numbers</li> <li><code>lookup_dcookie</code> - get directory entry cookies</li> <li><code>lremovexattr</code> - remove an extended attribute</li> <li><code>lseek</code> - set file offset</li> <li><code>lsetxattr</code> - set an extended attribute value</li> <li><code>lstat</code> - get file status</li> <li><code>madvise</code> - give advice about use of memory</li> <li><code>mbind</code> - set memory policy and binding for a process or memory range</li> <li><code>membarrier</code> - issue memory barriers on a set of threads</li> <li><code>memfd_create</code> - create an anonymous file and return a file descriptor for it</li> <li><code>migrate_pages</code> - migrate a set of pages to a different set of nodes</li> <li><code>mincore</code> - determine whether pages are resident in memory</li> <li><code>mkdir</code> - make a directory</li> <li><code>mkdirat</code> - make a directory relative to a directory file descriptor</li> <li><code>mknod</code> - create a special or ordinary file</li> <li><code>mknodat</code> - create a special or ordinary file relative to a directory file descriptor</li> <li><code>mlock</code> - lock part of the calling process's virtual address space</li> <li><code>mlock2</code> - lock part of the calling process's virtual address space (version 2)</li> <li><code>mlockall</code> - lock all of the calling process's virtual address space</li> <li><code>mmap</code> - map or unmap files or devices into memory</li> <li><code>modify_ldt</code> - manipulate a local descriptor table</li> <li><code>mount</code> - mount or unmount a file system</li> <li><code>move_pages</code> - move pages of a process to a different set of nodes</li> <li><code>mprotect</code> - set protection on a region of memory</li> <li><code>mq_getsetattr</code> - get or set message queue attributes</li> <li><code>mq_notify</code> - register for notification when a message is available on a queue</li> <li><code>mq_open</code> - open a message queue</li> <li><code>mq_timedreceive</code> - receive a message from a message queue, with a timeout</li> <li><code>mq_timedsend</code> - send a message to a message queue, with a timeout</li> <li><code>mq_unlink</code> - remove a message queue</li> <li><code>mremap</code> - remap a virtual memory address</li> <li><code>msgctl</code> - control a message queue</li> <li><code>msgget</code> - get a message queue identifier</li> <li><code>msgrcv</code> - receive a message from a message queue</li> <li><code>msgsnd</code> - send a message to a message queue</li> <li><code>msync</code> - synchronize a file or memory map with memory and/or storage</li> <li><code>munlock</code> - unlock part of the calling process's virtual address space</li> <li><code>munlockall</code> - unlock all of the calling process's virtual address space</li> <li><code>munmap</code> - unmap a file or device from memory</li> <li><code>name_to_handle_at</code> - convert a pathname to a file handle</li> <li><code>nanosleep</code> - suspend execution for a specified time interval</li> <li><code>newfstatat</code> - get file status relative to a directory file descriptor</li> <li><code>nfsservctl</code> - NFS server control</li> <li><code>open</code> - open and possibly create a file or device</li> <li><code>openat</code> - open and possibly create a file or device relative to a directory file descriptor</li> <li><code>open_by_handle_at</code> - open a file by file handle</li> <li><code>perf_event_open</code> - request the creation of a performance monitoring counter</li> <li><code>personality</code> - get or set process execution domain</li> <li><code>pipe</code> - create a pipe</li> <li><code>pipe2</code> - create a pipe with specified flags</li> <li><code>pivot_root</code> - change the root file system</li> <li><code>pkey_alloc</code> - allocate a protection key</li> <li><code>pkey_free</code> - free a protection key</li> <li><code>pkey_mprotect</code> - set protection key on a region of memory</li> <li><code>poll</code> - wait for some event on a file descriptor</li> <li><code>ppoll</code> - wait for some event on a file descriptor, with a timeout and signal mask</li> <li><code>prctl</code> - get or set process capabilities and attributes</li> <li><code>pread64</code> - read from a file at a specified offset</li> <li><code>preadv</code> - read from a file at specified offsets into multiple buffers</li> <li><code>preadv2</code> - read from a file at specified offsets into multiple buffers (version 2)</li> <li><code>prlimit64</code> - get or set process resource limits</li> <li><code>process_vm_readv</code> - read memory from another process</li> <li><code>process_vm_writev</code> - write memory to another process</li> <li><code>pselect6</code> - wait for some event on a file descriptor, with a timeout and signal mask (version 6)</li> <li><code>ptrace</code> - trace a process or get/modify its memory or registers</li> <li><code>pwrite64</code> - write to a file at a specified offset</li> <li><code>pwritev</code> - write to a file at specified offsets from multiple buffers</li> <li><code>pwritev2</code> - write to a file at specified offsets from multiple buffers (version 2)</li> <li><code>quotactl</code> - manipulate disk quotas</li> <li><code>read</code> - read data from a file descriptor</li> <li><code>readahead</code> - read ahead in a file</li> <li><code>readdir</code> - get directory entries</li> <li><code>readlink</code> - read the value of a symbolic link</li> <li><code>readlinkat</code> - read the value of a symbolic link relative to a directory file descriptor</li> <li><code>readv</code> - read data into multiple buffers from a file descriptor</li> <li><code>reboot</code> - reboot or halt the system</li> <li><code>recvfrom</code> - receive a message from a socket</li> <li><code>recvmmsg</code> - receive multiple messages from a socket with a single system call</li> <li>`recvtion</li> <li><code>setfsuid</code> - set the filesystem UID</li> <li><code>setgid</code> - set group identity</li> <li><code>setgroups</code> - set process group IDs</li> <li><code>setitimer</code> - set an interval timer</li> <li><code>set_mempolicy</code> - set default NUMA memory policy for a process or memory range</li> <li><code>setns</code> - reassociate a thread with a namespace</li> <li><code>setpgid</code> - set process group ID of a process</li> <li><code>setpriority</code> - set process scheduling priority</li> <li><code>setregid</code> - set real and/or effective group ID of calling process</li> <li><code>setresgid</code> - set real, effective, and saved group ID of calling process</li> <li><code>setresuid</code> - set real, effective, and saved user ID of calling process</li> <li><code>setreuid</code> - set real and/or effective user ID of calling process</li> <li><code>setrlimit</code> - control maximum system resource consumption</li> <li><code>set_robust_list</code> - set or get list of robust futexes</li> <li><code>setsid</code> - set session ID</li> <li><code>setsockopt</code> - set options on a socket</li> <li><code>set_tid_address</code> - set pointer to thread ID</li> <li><code>settimeofday</code> - set date and time</li> <li><code>setuid</code> - set user identity</li> <li><code>setxattr</code> - set an extended attribute value</li> <li><code>shmat</code> - attach a shared memory segment to the calling process</li> <li><code>shmctl</code> - control operations on a shared memory segment</li> <li><code>shmdt</code> - detach a shared memory segment from the calling process</li> <li><code>shmget</code> - allocate a shared memory segment</li> <li><code>shutdown</code> - shut down part of a full-duplex connection</li> <li><code>sigaltstack</code> - set and/or get alternate signal stack</li> <li><code>signalfd</code> - create a file descriptor for accepting signals</li> <li><code>signalfd4</code> - create a file descriptor for accepting signals (version 4)</li> <li><code>socket</code> - create an endpoint for communication</li> <li><code>socketpair</code> - create a pair of connected sockets</li> <li><code>splice</code> - move data between two file descriptors</li> <li><code>stat</code> - get file status</li> <li><code>statfs</code> - get file system statistics</li> <li><code>statx</code> - get file status (extended)</li> <li><code>swapoff</code> - disable swapping</li> <li><code>swapon</code> - enable swapping</li> <li><code>symlink</code> - make a symbolic link</li> <li><code>symlinkat</code> - make a symbolic link relative to a directory file descriptor</li> <li><code>sync</code> - commit file system caches to disk</li> <li><code>sync_file_range</code> - write a range of data to a file without flushing other ranges</li> <li><code>syncfs</code> - synchronize a file system with disk</li> <li><code>sysfs</code> - manipulate kernel objects in the <code>sysfs</code> filesystem</li> <li><code>sysinfo</code> - get system information</li> <li><code>syslog</code> - send a message to the system logger</li> <li><code>tee</code> - duplicate data between two file descriptors</li> <li><code>tgkill</code> - send a signal to a specific thread of a specific process</li> <li><code>timer_create</code> - create a per-process timer</li> <li><code>timer_delete</code> - delete a per-process timer</li> <li><code>timerfd_create</code> - create a file descriptor for timer notifications</li> <li><code>timerfd_gettime</code> - get expiration time of a file descriptor timer</li> <li><code>timerfd_settime</code> - arm or disarm a file descriptor timer</li> <li><code>timer_getoverrun</code> - get overrun count for a per-process timer</li> <li><code>timer_gettime</code> - get expiration time for a per-process timer</li> <li><code>timer_settime</code> - arm or disarm a per-process timer</li> <li><code>times</code> - get process times</li> <li><code>tkill</code> - send a signal to a specific thread of a specific process</li> <li><code>truncate</code> - truncate a file to a specified length</li> <li><code>umask</code> - set file creation mode mask</li> <li><code>umount2</code> - unmount file system</li> <li><code>uname</code> - get name and information about current kernel</li> <li><code>unlink</code> - delete a name and possibly the file it refers to</li> <li><code>unlinkat</code> - delete a name and possibly the file it refers to relative to a directory file descriptor</li> <li><code>unshare</code> - create a new namespace for a process</li></ol> <hr> <p>The usefulness of a particular Linux syscall depends on the context in which it is being used. However, some syscalls are commonly used in development, especially when working with system-level programming, file I/O, and networking applications. Here are some examples:</p> <ol><li><code>open</code> - opens a file or creates one if it doesn't exist</li> <li><code>read</code> - reads data from a file</li> <li><code>write</code> - writes data to a file</li> <li><code>close</code> - closes a file descriptor</li> <li><code>socket</code> - creates an endpoint for communication</li> <li><code>bind</code> - assigns a name to a socket</li> <li><code>listen</code> - marks a socket as passive, ready to accept incoming connections</li> <li><code>accept</code> - accepts a connection on a socket</li> <li><code>connect</code> - initiates a connection on a socket</li> <li><code>select</code> - waits for one or more file descriptors to become ready for I/O</li></ol> <p>These are just a few examples of syscalls that are commonly used in development. The choice of syscall depends on the specific requirements of the application being developed.</p> <hr> <p>The Linux kernel is responsible for managing the memory of the system it runs on. It is a complex process that involves several components, including virtual memory, physical memory, and swap space. The kernel has to ensure that all processes have access to the memory they need while also preventing them from interfering with each other.</p> <p>Virtual memory is a technique that allows the kernel to use more memory than is physically available. This is achieved by dividing the memory into pages and storing them in a page table. The kernel uses the page table to map virtual addresses used by processes to physical addresses in memory.</p> <p>When a process requests memory, the kernel checks if there is enough free memory available. If there is not enough memory available, the kernel will allocate memory from the swap space. Swap space is a portion of the hard disk used to store memory pages that are not currently in use.</p> <p>The kernel also manages memory through a technique called memory allocation. Memory allocation is the process by which the kernel allocates memory to running processes. The kernel maintains a list of free memory blocks, which it uses to satisfy memory requests.</p> <p>Another important aspect of memory management is memory protection. The kernel uses memory protection to prevent processes from accessing memory they are not authorized to access. This is achieved by using a technique called memory segmentation, which divides memory into segments and assigns access control attributes to each segment.</p> <p>The kernel also handles memory fragmentation, which is the phenomenon where free memory blocks become too small to satisfy memory requests. The kernel uses a technique called memory compaction to reduce memory fragmentation. Memory compaction is the process of rearranging memory blocks to create larger contiguous blocks of free memory.</p> <p>In conclusion, the Linux kernel manages memory through a complex process that involves several components such as virtual memory, physical memory, and swap space. It handles memory allocation, memory protection, and memory fragmentation, as well as using techniques like memory segmentation and memory compaction to ensure that all processes have access to the memory they need while also preventing them from interfering with each other.</p> <hr> <p>The Linux kernel also employs a technique called memory caching to improve system performance. Memory caching is the process of storing frequently accessed data in memory to reduce the number of disk reads required. This is achieved by maintaining a cache of recently accessed data in memory.</p> <p>The kernel also has a component called the memory management unit (MMU), which is responsible for translating virtual memory addresses to physical memory addresses. The MMU uses the page table to map virtual addresses to physical addresses.</p> <p>The kernel also employs a technique called demand paging to improve system performance. Demand paging is the process of loading only the portions of a program into memory that are currently in use. This reduces the amount of memory required to run the program and improves system performance.</p> <p>Another important aspect of memory management is memory sharing. The kernel allows multiple processes to share memory, which reduces the amount of memory required by the system. This is achieved by using a technique called memory mapping, which allows multiple processes to map the same memory region into their virtual address space.</p> <p>The Linux kernel also has a feature called the Out-of-Memory (OOM) killer, which is responsible for terminating processes when the system runs out of memory. The OOM killer selects the process with the largest memory footprint and terminates it to free up memory for other processes.</p> <p>In addition to the techniques mentioned above, the kernel also employs several other techniques to manage memory, including transparent huge pages, kernel same-page merging, and memory compression.</p> <p>In conclusion, the Linux kernel uses a variety of complex techniques to manage memory. These techniques include virtual memory, physical memory, swap space, memory allocation, memory protection, memory fragmentation, memory caching, demand paging, memory sharing, the MMU, and the OOM killer. By using these techniques, the kernel is able to ensure that all processes have access to the memory they need while also preventing them from interfering with each other.</p> <hr> <p>Another technique used by the Linux kernel for memory management is the use of memory zones. Memory zones allow the kernel to organize memory into different areas based on their usage. There are several memory zones, including the DMA zone, the Normal zone, and the High memory zone. The DMA zone is used for direct memory access devices, such as sound cards and network adapters. The Normal zone is used for general-purpose memory, while the High memory zone is used for memory that is not directly accessible by the kernel.</p> <p>The Linux kernel also employs a technique called the slab allocator, which is a memory management mechanism used for kernel objects. The slab allocator is responsible for allocating and deallocating memory for kernel objects, such as data structures and buffers. The slab allocator uses a technique called slab caching to improve performance by reducing the overhead of memory allocation and deallocation.</p> <p>The kernel also has a component called the memory controller, which is responsible for managing the memory usage of individual processes. The memory controller uses a technique called memory cgroup to group processes and limit their memory usage. This helps prevent processes from consuming too much memory and causing the system to become unresponsive.</p> <p>The Linux kernel also has a feature called the kernel same-page merging (KSM), which is responsible for reducing memory usage by merging identical memory pages. KSM identifies identical memory pages and merges them into a single page. This can reduce memory usage by up to 50% in some cases.</p> <p>In addition to the techniques mentioned above, the Linux kernel also employs several other techniques to manage memory, including lazy page allocation, page migration, and huge pages. Lazy page allocation is the process of allocating memory only when it is actually needed, which can improve system performance. Page migration is the process of moving memory pages between different physical memory locations to improve memory utilization. Huge pages are larger than normal memory pages and can reduce the overhead of page table management.</p> <p>In summary, the Linux kernel uses a variety of complex techniques to manage memory. These techniques include memory zones, the slab allocator, the memory controller, KSM, lazy page allocation, page migration, and huge pages. By using these techniques, the kernel is able to ensure that all processes have access to the memory they need while also preventing them from interfering with each other, and improving system performance.</p> <hr> <p>Another important aspect of memory management in the Linux kernel is memory protection. Memory protection is the process of preventing unauthorized access to memory. The kernel uses a technique called memory segmentation to divide memory into segments and assigns access control attributes to each segment. This technique ensures that processes can only access the memory they are authorized to access.</p> <p>The kernel also handles memory fragmentation, which is the phenomenon where free memory blocks become too small to satisfy memory requests. The kernel uses a technique called memory compaction to reduce memory fragmentation. Memory compaction is the process of rearranging memory blocks to create larger contiguous blocks of free memory.</p> <p>The Linux kernel also employs a technique called demand paging to improve system performance. Demand paging is the process of loading only the portions of a program into memory that are currently in use. This reduces the amount of memory required to run the program and improves system performance.</p> <p>In addition to the techniques mentioned above, the Linux kernel also uses several other techniques to manage memory, including transparent huge pages, memory compression, and the Out-of-Memory (OOM) killer. Transparent huge pages are larger than normal memory pages and can reduce the overhead of page table management. Memory compression is the process of compressing memory pages to reduce memory usage. The OOM killer is responsible for terminating processes when the system runs out of memory.</p> <p>Overall, the Linux kernel uses a combination of complex techniques to manage memory. These techniques include virtual memory, physical memory, swap space, memory allocation, memory protection, memory fragmentation, memory caching, demand paging, memory sharing, the MMU, and the OOM killer. Using these techniques, the kernel is able to ensure that all processes have access to the memory they need while also preventing them from interfering with each other, and improving system performance.</p> <hr> <p>Another important technique used by the Linux kernel to manage memory is memory overcommitment. Memory overcommitment is the process of allocating more memory to processes than is physically available in the system. This technique is possible because many processes do not use all of the memory that they request, and because the kernel uses techniques like demand paging to reduce the amount of memory required to run a process. However, overcommitting memory can lead to the system running out of memory and becoming unresponsive. To prevent this, the kernel uses the OOM killer to terminate processes when the system runs out of memory.</p> <p>The Linux kernel also uses a technique called memory ballooning to dynamically adjust the amount of memory allocated to a virtual machine. Memory ballooning is used in virtualized environments to allow the hypervisor to reclaim memory from idle or over-provisioned virtual machines and allocate it to other virtual machines that need more memory.</p> <p>In addition to the techniques mentioned above, the Linux kernel uses several other techniques to manage memory, including NUMA (Non-Uniform Memory Access) support, memory cgroups, and the memory controller. NUMA support is used in systems with multiple processors to improve memory performance by reducing the latency of memory access. Memory cgroups and the memory controller are used to limit the amount of memory that can be used by a particular process or group of processes, which can improve system stability and prevent processes from monopolizing memory resources.</p> <p>In conclusion, the Linux kernel uses a complex set of techniques to manage memory, including virtual memory, physical memory, swap space, memory allocation, memory protection, memory fragmentation, memory caching, demand paging, memory sharing, the MMU, the OOM killer, memory overcommitment, memory ballooning, NUMA support, memory cgroups, and the memory controller. By using these techniques, the kernel is able to ensure that all processes have access to the memory they need while also preventing them from interfering with each other, and improving system performance and stability.</p> <hr> <p>The Linux kernel manages memory through a combination of hardware support and software algorithms. At the hardware level, the kernel interacts with the Memory Management Unit (MMU) to map physical memory addresses to virtual addresses that are used by processes. This allows processes to access memory without worrying about the physical location of memory cells.</p> <p>The kernel uses a variety of algorithms to manage memory, including swapping, paging, and demand paging. Swapping involves moving entire processes to disk when memory becomes scarce, while paging involves moving individual memory pages to disk. Demand paging is similar to paging, but only loads the pages that are actually needed by a process.</p> <p>The kernel also uses the buddy system to manage physical memory allocation. This involves dividing memory into blocks of equal size, and then grouping these blocks into larger blocks as needed. When a process requests memory, the kernel allocates a block of the appropriate size from the available free blocks.</p> <p>In addition to these basic algorithms, the Linux kernel also supports advanced memory management features such as memory-mapped files, shared memory, and memory overcommitment. Overall, the Linux kernel's memory management system is designed to be flexible, efficient, and scalable, ensuring that it can handle the memory needs of a wide range of applications and workloads.</p> <hr> <p>The Linux kernel also includes a variety of memory management subsystems that work together to ensure efficient use of memory resources. One such subsystem is the slab allocator, which is used to allocate kernel objects such as data structures and buffers. The slab allocator is designed to be fast and efficient, minimizing the overhead of memory allocation and freeing.</p> <p>Another important memory management subsystem in the Linux kernel is the virtual file system (VFS), which provides a uniform interface for accessing files and other resources across various file systems. The VFS uses a caching system to improve performance, storing frequently accessed data in memory for faster access.</p> <p>The Linux kernel also includes support for various memory technologies, including conventional RAM, non-volatile memory (NVM), and memory-mapped input/output (MMIO). The kernel's support for NVM is particularly important, as it allows for persistent storage of data even when power is lost.</p> <p>Finally, the Linux kernel provides a wide range of tools and utilities for monitoring and managing memory usage. These tools include the top command, which provides real-time information about memory usage and CPU load, as well as the vmstat command, which provides detailed information about memory usage, paging, swapping, and other metrics.</p> <p>Overall, the Linux kernel's memory management system is a complex and highly optimized subsystem that is critical to the performance and stability of the operating system. Developers working on the Linux kernel must have a deep understanding of memory management principles and algorithms, as well as the ability to write efficient and scalable code that can handle a wide range of memory-intensive workloads.</p> <hr> <p>In addition to the aforementioned memory management subsystems, the Linux kernel also provides support for memory protection mechanisms, such as access control lists (ACLs) and capabilities. These mechanisms ensure that only authorized processes can access specific memory regions, providing an additional layer of security to the system.</p> <p>Another important aspect of the Linux kernel's memory management system is its support for virtual memory. Virtual memory allows for the efficient use of physical memory by mapping virtual addresses used by processes to physical addresses in memory. This allows multiple processes to share the same physical memory, increasing the overall efficiency of the system.</p> <p>To further optimize memory usage, the Linux kernel provides support for transparent huge pages (THP), which allows the kernel to group multiple small memory pages into a single large page. This can significantly reduce the overhead of memory management, improving the performance of memory-intensive applications.</p> <p>Finally, the Linux kernel includes support for memory hotplug, which allows system administrators to add or remove memory from a running system without rebooting. This can be particularly useful in large-scale data center environments, where memory upgrades or replacements are common.</p> <p>In conclusion, the Linux kernel's memory management system is a critical component of the operating system, providing efficient and secure management of physical and virtual memory resources. Developers working on the kernel must have a deep understanding of memory management principles, algorithms, and subsystems, as well as the ability to write efficient and scalable code that can handle a wide range of memory-intensive workloads.</p> <hr> <p>Linux kernel plays a vital role in managing memory in a computer system. The kernel is responsible for allocating and deallocating memory, ensuring data integrity, and providing protection between processes. When a process needs memory, it requests it from the kernel, which then allocates it from the available memory pool. If there isn't enough memory, the kernel will free up memory by swapping pages to disk or killing processes.</p> <p>The kernel uses a virtual memory system that maps physical memory addresses to virtual addresses. This allows processes to access memory without needing to know its physical location. The kernel also uses techniques like demand paging, where pages are only loaded into memory when needed, to optimize memory usage.</p> <p>The kernel also provides mechanisms for sharing memory between processes. For example, two processes can share memory by mapping the same physical pages to their virtual address spaces.</p> <p>To better understand how the Linux kernel works with memory, let's take a look at some example code:</p> <div class="language- extra-class"><pre class="language-text"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
   int *ptr = NULL;
   ptr = malloc(10 * sizeof(int));
   if (ptr == NULL) {
      printf(&quot;Memory allocation failed\n&quot;);
      exit(1);
   }
   for (int i = 0; i &lt; 10; i++) {
      ptr[i] = i;
   }
   for (int i = 0; i &lt; 10; i++) {
      printf(&quot;%d &quot;, ptr[i]);
   }
   free(ptr);
   return 0;
}
</code></pre></div><p>In this code, we are allocating memory using the <code>malloc()</code> function and deallocating it using the <code>free()</code> function. The <code>malloc()</code> function requests memory from the kernel and returns a pointer to the allocated memory if successful. If there isn't enough memory available, <code>malloc()</code> will return <code>NULL</code>. The <code>free()</code> function deallocates the memory previously allocated by <code>malloc()</code>, returning it to the kernel's free memory pool.</p> <p>Overall, the Linux kernel's management of memory is complex and highly optimized, with many advanced techniques and algorithms in place to ensure efficient and secure memory usage.</p> <hr> <p>The Linux kernel also implements a virtual memory system that allows each process to have its own virtual address space, which is mapped to physical memory by the kernel. This allows processes to access memory without needing to know its physical location, and also allows the kernel to perform optimizations such as demand paging and memory sharing.</p> <p>The virtual memory system is implemented using a combination of hardware support (such as the Memory Management Unit) and software support (such as the Page Table). The kernel maintains a Page Table for each process, which maps the process's virtual address space to physical memory.</p> <p>When a process accesses a virtual memory address that is not currently in physical memory, a Page Fault occurs. The kernel then loads the required page from disk into physical memory, and updates the Page Table to reflect the new mapping.</p> <p>The Linux kernel also provides several mechanisms for controlling memory usage and protecting processes from each other. For example, the kernel can use memory cgroups to limit the amount of memory that a group of processes can use. The kernel can also use address space layout randomization to protect against buffer overflow attacks.</p> <p>In summary, the Linux kernel's management of memory is a complex and critical part of its operation. With advanced techniques such as virtual memory, demand paging, and memory sharing, the kernel is able to efficiently manage memory usage and protect processes from each other.</p> <hr></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/doc_notes/assets/js/app.d7b7570d.js" defer></script><script src="/doc_notes/assets/js/2.733019b2.js" defer></script><script src="/doc_notes/assets/js/51.b9189617.js" defer></script>
  </body>
</html>
