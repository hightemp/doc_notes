<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.dec9f71a.js" as="script"><link rel="preload" href="/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/assets/js/32.566fa885.js" as="script"><link rel="prefetch" href="/assets/js/10.3c45a7ae.js"><link rel="prefetch" href="/assets/js/100.945d3075.js"><link rel="prefetch" href="/assets/js/101.c304dc04.js"><link rel="prefetch" href="/assets/js/102.c4ea246f.js"><link rel="prefetch" href="/assets/js/103.3fa17de4.js"><link rel="prefetch" href="/assets/js/104.10b346d7.js"><link rel="prefetch" href="/assets/js/105.37af8494.js"><link rel="prefetch" href="/assets/js/106.580b656c.js"><link rel="prefetch" href="/assets/js/107.bbf35ca8.js"><link rel="prefetch" href="/assets/js/108.ef31db2d.js"><link rel="prefetch" href="/assets/js/109.e0b67167.js"><link rel="prefetch" href="/assets/js/11.2369400d.js"><link rel="prefetch" href="/assets/js/110.f5f9eacf.js"><link rel="prefetch" href="/assets/js/111.a566b9a5.js"><link rel="prefetch" href="/assets/js/112.9872e360.js"><link rel="prefetch" href="/assets/js/113.55c7a352.js"><link rel="prefetch" href="/assets/js/114.12ee164e.js"><link rel="prefetch" href="/assets/js/115.1fb2093f.js"><link rel="prefetch" href="/assets/js/116.d46141e0.js"><link rel="prefetch" href="/assets/js/117.d60c7d89.js"><link rel="prefetch" href="/assets/js/118.c3b7612c.js"><link rel="prefetch" href="/assets/js/119.10367318.js"><link rel="prefetch" href="/assets/js/12.286d27d6.js"><link rel="prefetch" href="/assets/js/120.be792f55.js"><link rel="prefetch" href="/assets/js/121.9b95acc0.js"><link rel="prefetch" href="/assets/js/122.eaab2843.js"><link rel="prefetch" href="/assets/js/123.cc552dc6.js"><link rel="prefetch" href="/assets/js/124.cce7d459.js"><link rel="prefetch" href="/assets/js/125.c5c5f203.js"><link rel="prefetch" href="/assets/js/126.9fb20891.js"><link rel="prefetch" href="/assets/js/127.06235e8b.js"><link rel="prefetch" href="/assets/js/128.a7d21829.js"><link rel="prefetch" href="/assets/js/129.cf5cb2cd.js"><link rel="prefetch" href="/assets/js/13.47981763.js"><link rel="prefetch" href="/assets/js/130.53cfb33f.js"><link rel="prefetch" href="/assets/js/131.3a8b27b3.js"><link rel="prefetch" href="/assets/js/132.872dde3d.js"><link rel="prefetch" href="/assets/js/133.82865bbc.js"><link rel="prefetch" href="/assets/js/134.f3b5d42f.js"><link rel="prefetch" href="/assets/js/135.4c91805f.js"><link rel="prefetch" href="/assets/js/136.dcb8f9e2.js"><link rel="prefetch" href="/assets/js/137.07d2bab8.js"><link rel="prefetch" href="/assets/js/138.ea94033d.js"><link rel="prefetch" href="/assets/js/139.79ad652e.js"><link rel="prefetch" href="/assets/js/14.2f49c0ab.js"><link rel="prefetch" href="/assets/js/140.d6518035.js"><link rel="prefetch" href="/assets/js/141.6b166b92.js"><link rel="prefetch" href="/assets/js/142.c4466c2b.js"><link rel="prefetch" href="/assets/js/143.141061b6.js"><link rel="prefetch" href="/assets/js/144.5cee20dc.js"><link rel="prefetch" href="/assets/js/145.97956c27.js"><link rel="prefetch" href="/assets/js/146.23cb4066.js"><link rel="prefetch" href="/assets/js/147.bb1e6c1a.js"><link rel="prefetch" href="/assets/js/148.a5bd7077.js"><link rel="prefetch" href="/assets/js/149.57694ad8.js"><link rel="prefetch" href="/assets/js/15.0cb65b1e.js"><link rel="prefetch" href="/assets/js/150.faf7fa9f.js"><link rel="prefetch" href="/assets/js/151.2ee47c84.js"><link rel="prefetch" href="/assets/js/152.9a82c536.js"><link rel="prefetch" href="/assets/js/153.5bd8c4a5.js"><link rel="prefetch" href="/assets/js/154.7cdc00ab.js"><link rel="prefetch" href="/assets/js/155.a2a1c88e.js"><link rel="prefetch" href="/assets/js/156.92796b90.js"><link rel="prefetch" href="/assets/js/157.f247bf22.js"><link rel="prefetch" href="/assets/js/158.eaeb08c7.js"><link rel="prefetch" href="/assets/js/159.555a6593.js"><link rel="prefetch" href="/assets/js/16.6fd62cc7.js"><link rel="prefetch" href="/assets/js/160.bf19eb80.js"><link rel="prefetch" href="/assets/js/161.7ce1d12b.js"><link rel="prefetch" href="/assets/js/162.f6dc5f4b.js"><link rel="prefetch" href="/assets/js/163.16df5c09.js"><link rel="prefetch" href="/assets/js/164.bdd3ee47.js"><link rel="prefetch" href="/assets/js/165.ba85290c.js"><link rel="prefetch" href="/assets/js/166.6b1a560c.js"><link rel="prefetch" href="/assets/js/167.59b9445e.js"><link rel="prefetch" href="/assets/js/168.69cc230d.js"><link rel="prefetch" href="/assets/js/169.55882eed.js"><link rel="prefetch" href="/assets/js/17.94447945.js"><link rel="prefetch" href="/assets/js/170.129124fc.js"><link rel="prefetch" href="/assets/js/171.cf1a85f9.js"><link rel="prefetch" href="/assets/js/172.36f3cdfc.js"><link rel="prefetch" href="/assets/js/173.cddbfa1b.js"><link rel="prefetch" href="/assets/js/174.a32fe0ad.js"><link rel="prefetch" href="/assets/js/175.c1414217.js"><link rel="prefetch" href="/assets/js/176.a678371f.js"><link rel="prefetch" href="/assets/js/177.583b2ac2.js"><link rel="prefetch" href="/assets/js/178.6dd3c8d6.js"><link rel="prefetch" href="/assets/js/179.dac91cd2.js"><link rel="prefetch" href="/assets/js/18.75e97365.js"><link rel="prefetch" href="/assets/js/180.9dfd9728.js"><link rel="prefetch" href="/assets/js/181.9afd854f.js"><link rel="prefetch" href="/assets/js/182.d0dbacf1.js"><link rel="prefetch" href="/assets/js/183.1dbeb096.js"><link rel="prefetch" href="/assets/js/184.27b34aeb.js"><link rel="prefetch" href="/assets/js/185.13641773.js"><link rel="prefetch" href="/assets/js/186.d79c8675.js"><link rel="prefetch" href="/assets/js/187.484bb501.js"><link rel="prefetch" href="/assets/js/188.f73564d2.js"><link rel="prefetch" href="/assets/js/189.25f0971d.js"><link rel="prefetch" href="/assets/js/19.9abedc68.js"><link rel="prefetch" href="/assets/js/190.00b862d0.js"><link rel="prefetch" href="/assets/js/191.a255f76b.js"><link rel="prefetch" href="/assets/js/192.6b6a1c68.js"><link rel="prefetch" href="/assets/js/193.916ffb26.js"><link rel="prefetch" href="/assets/js/194.2c928fb3.js"><link rel="prefetch" href="/assets/js/195.20a9fc51.js"><link rel="prefetch" href="/assets/js/196.f2abf901.js"><link rel="prefetch" href="/assets/js/197.871f3d6a.js"><link rel="prefetch" href="/assets/js/198.3ea5cf81.js"><link rel="prefetch" href="/assets/js/199.3f37d030.js"><link rel="prefetch" href="/assets/js/20.1c33d690.js"><link rel="prefetch" href="/assets/js/200.7e20b89c.js"><link rel="prefetch" href="/assets/js/201.ae9ed05e.js"><link rel="prefetch" href="/assets/js/202.d686563a.js"><link rel="prefetch" href="/assets/js/203.5a9ac59e.js"><link rel="prefetch" href="/assets/js/204.4abf0169.js"><link rel="prefetch" href="/assets/js/205.94fe861e.js"><link rel="prefetch" href="/assets/js/206.76e93465.js"><link rel="prefetch" href="/assets/js/207.92c5e562.js"><link rel="prefetch" href="/assets/js/208.79f31d54.js"><link rel="prefetch" href="/assets/js/209.eb534898.js"><link rel="prefetch" href="/assets/js/21.de3ad1f7.js"><link rel="prefetch" href="/assets/js/210.38242c09.js"><link rel="prefetch" href="/assets/js/211.ca8aa9a4.js"><link rel="prefetch" href="/assets/js/212.189fa4e2.js"><link rel="prefetch" href="/assets/js/213.239f2bd6.js"><link rel="prefetch" href="/assets/js/214.b1a9ece6.js"><link rel="prefetch" href="/assets/js/215.823222d2.js"><link rel="prefetch" href="/assets/js/216.6c3fbaad.js"><link rel="prefetch" href="/assets/js/217.c2bd084b.js"><link rel="prefetch" href="/assets/js/218.7ad57fcc.js"><link rel="prefetch" href="/assets/js/219.4ef0266b.js"><link rel="prefetch" href="/assets/js/22.a45331de.js"><link rel="prefetch" href="/assets/js/220.e9fd4c5f.js"><link rel="prefetch" href="/assets/js/221.0b0f609a.js"><link rel="prefetch" href="/assets/js/222.ff25599e.js"><link rel="prefetch" href="/assets/js/223.8319d2d0.js"><link rel="prefetch" href="/assets/js/224.da5c4d3e.js"><link rel="prefetch" href="/assets/js/225.9378291a.js"><link rel="prefetch" href="/assets/js/226.0d8b2ef5.js"><link rel="prefetch" href="/assets/js/227.82cd2e2d.js"><link rel="prefetch" href="/assets/js/228.db49009d.js"><link rel="prefetch" href="/assets/js/229.e735fec4.js"><link rel="prefetch" href="/assets/js/23.de5de683.js"><link rel="prefetch" href="/assets/js/230.47e7011d.js"><link rel="prefetch" href="/assets/js/231.7f0e5905.js"><link rel="prefetch" href="/assets/js/232.a6cb0759.js"><link rel="prefetch" href="/assets/js/233.09bbd53b.js"><link rel="prefetch" href="/assets/js/234.b9341514.js"><link rel="prefetch" href="/assets/js/235.3563b4bf.js"><link rel="prefetch" href="/assets/js/236.7d5da9ca.js"><link rel="prefetch" href="/assets/js/237.c7a693f3.js"><link rel="prefetch" href="/assets/js/238.803df100.js"><link rel="prefetch" href="/assets/js/239.ef64fcf2.js"><link rel="prefetch" href="/assets/js/24.b363b117.js"><link rel="prefetch" href="/assets/js/240.2befed40.js"><link rel="prefetch" href="/assets/js/241.10a01506.js"><link rel="prefetch" href="/assets/js/242.3b369ac8.js"><link rel="prefetch" href="/assets/js/243.31958eb9.js"><link rel="prefetch" href="/assets/js/244.b9489a7d.js"><link rel="prefetch" href="/assets/js/245.b9b191e5.js"><link rel="prefetch" href="/assets/js/246.18aeb9f6.js"><link rel="prefetch" href="/assets/js/247.39cc492f.js"><link rel="prefetch" href="/assets/js/248.b08e232c.js"><link rel="prefetch" href="/assets/js/249.6d660682.js"><link rel="prefetch" href="/assets/js/25.5e2fe982.js"><link rel="prefetch" href="/assets/js/250.235cee85.js"><link rel="prefetch" href="/assets/js/251.66edac43.js"><link rel="prefetch" href="/assets/js/252.28ec4821.js"><link rel="prefetch" href="/assets/js/253.828cd3b6.js"><link rel="prefetch" href="/assets/js/254.6b19e7b7.js"><link rel="prefetch" href="/assets/js/255.7808e23e.js"><link rel="prefetch" href="/assets/js/256.33572d7d.js"><link rel="prefetch" href="/assets/js/257.8044242f.js"><link rel="prefetch" href="/assets/js/258.2eb93b76.js"><link rel="prefetch" href="/assets/js/259.6d222e72.js"><link rel="prefetch" href="/assets/js/26.b3336cf9.js"><link rel="prefetch" href="/assets/js/260.b3345d12.js"><link rel="prefetch" href="/assets/js/261.6f64a148.js"><link rel="prefetch" href="/assets/js/262.283e9e13.js"><link rel="prefetch" href="/assets/js/263.10934b95.js"><link rel="prefetch" href="/assets/js/264.52a220d8.js"><link rel="prefetch" href="/assets/js/265.3099a02f.js"><link rel="prefetch" href="/assets/js/266.d093c25c.js"><link rel="prefetch" href="/assets/js/267.ffd0ea6c.js"><link rel="prefetch" href="/assets/js/268.71a5b2a5.js"><link rel="prefetch" href="/assets/js/269.e02d0a12.js"><link rel="prefetch" href="/assets/js/27.bacb7462.js"><link rel="prefetch" href="/assets/js/270.717bdd21.js"><link rel="prefetch" href="/assets/js/271.ceef3037.js"><link rel="prefetch" href="/assets/js/272.b040f2d8.js"><link rel="prefetch" href="/assets/js/273.e06cd101.js"><link rel="prefetch" href="/assets/js/274.9c206962.js"><link rel="prefetch" href="/assets/js/275.46ae609d.js"><link rel="prefetch" href="/assets/js/276.16e277a9.js"><link rel="prefetch" href="/assets/js/277.fcb15734.js"><link rel="prefetch" href="/assets/js/278.0cc37dab.js"><link rel="prefetch" href="/assets/js/279.55e66e78.js"><link rel="prefetch" href="/assets/js/28.f9359f93.js"><link rel="prefetch" href="/assets/js/280.e4809dbc.js"><link rel="prefetch" href="/assets/js/281.0889dba5.js"><link rel="prefetch" href="/assets/js/282.459e1cec.js"><link rel="prefetch" href="/assets/js/283.0b2d1fb1.js"><link rel="prefetch" href="/assets/js/284.ffe54aa9.js"><link rel="prefetch" href="/assets/js/285.d9ed13ce.js"><link rel="prefetch" href="/assets/js/286.5574e754.js"><link rel="prefetch" href="/assets/js/287.f9187311.js"><link rel="prefetch" href="/assets/js/288.cd2b56c3.js"><link rel="prefetch" href="/assets/js/289.8552c742.js"><link rel="prefetch" href="/assets/js/29.9a6765b0.js"><link rel="prefetch" href="/assets/js/290.7d0673a7.js"><link rel="prefetch" href="/assets/js/291.5c185731.js"><link rel="prefetch" href="/assets/js/292.fab6d535.js"><link rel="prefetch" href="/assets/js/293.457fd94a.js"><link rel="prefetch" href="/assets/js/294.748e6f29.js"><link rel="prefetch" href="/assets/js/295.99a4bc36.js"><link rel="prefetch" href="/assets/js/296.f02a6f54.js"><link rel="prefetch" href="/assets/js/297.a2899d72.js"><link rel="prefetch" href="/assets/js/298.8e5a5ef7.js"><link rel="prefetch" href="/assets/js/299.eff3af7f.js"><link rel="prefetch" href="/assets/js/3.e54eedac.js"><link rel="prefetch" href="/assets/js/30.8899ae33.js"><link rel="prefetch" href="/assets/js/300.ea47d06a.js"><link rel="prefetch" href="/assets/js/301.0f51c16c.js"><link rel="prefetch" href="/assets/js/302.0672bd76.js"><link rel="prefetch" href="/assets/js/303.99557654.js"><link rel="prefetch" href="/assets/js/304.069ee3f6.js"><link rel="prefetch" href="/assets/js/305.bbbcb69f.js"><link rel="prefetch" href="/assets/js/306.458f04ac.js"><link rel="prefetch" href="/assets/js/307.d8a121f6.js"><link rel="prefetch" href="/assets/js/308.4e353bdf.js"><link rel="prefetch" href="/assets/js/309.41135b53.js"><link rel="prefetch" href="/assets/js/31.907a86ff.js"><link rel="prefetch" href="/assets/js/310.d9900cca.js"><link rel="prefetch" href="/assets/js/311.4c8d1049.js"><link rel="prefetch" href="/assets/js/312.e461412c.js"><link rel="prefetch" href="/assets/js/313.b481fec8.js"><link rel="prefetch" href="/assets/js/314.7c9d7531.js"><link rel="prefetch" href="/assets/js/315.493dd60b.js"><link rel="prefetch" href="/assets/js/316.b892fdb3.js"><link rel="prefetch" href="/assets/js/317.0488dbc0.js"><link rel="prefetch" href="/assets/js/318.e3024dfc.js"><link rel="prefetch" href="/assets/js/319.cbeb3017.js"><link rel="prefetch" href="/assets/js/320.6bbdcb6f.js"><link rel="prefetch" href="/assets/js/321.393ba5b9.js"><link rel="prefetch" href="/assets/js/322.e1ac37db.js"><link rel="prefetch" href="/assets/js/323.ecada34d.js"><link rel="prefetch" href="/assets/js/324.b5a78957.js"><link rel="prefetch" href="/assets/js/325.78a07f6c.js"><link rel="prefetch" href="/assets/js/326.18acb16b.js"><link rel="prefetch" href="/assets/js/327.f1fdf85e.js"><link rel="prefetch" href="/assets/js/328.cb4e6a88.js"><link rel="prefetch" href="/assets/js/329.7064a56d.js"><link rel="prefetch" href="/assets/js/33.089e8d27.js"><link rel="prefetch" href="/assets/js/330.eb5d365c.js"><link rel="prefetch" href="/assets/js/331.7413cc1f.js"><link rel="prefetch" href="/assets/js/332.268810a7.js"><link rel="prefetch" href="/assets/js/333.14b9f266.js"><link rel="prefetch" href="/assets/js/334.79f3c205.js"><link rel="prefetch" href="/assets/js/335.4c1fa2f4.js"><link rel="prefetch" href="/assets/js/336.2a555b98.js"><link rel="prefetch" href="/assets/js/337.c8d1a7eb.js"><link rel="prefetch" href="/assets/js/338.027e65ab.js"><link rel="prefetch" href="/assets/js/339.e913eb02.js"><link rel="prefetch" href="/assets/js/34.5cbcf358.js"><link rel="prefetch" href="/assets/js/340.ccfb0701.js"><link rel="prefetch" href="/assets/js/341.2bf59012.js"><link rel="prefetch" href="/assets/js/342.43214bf6.js"><link rel="prefetch" href="/assets/js/343.860e5acc.js"><link rel="prefetch" href="/assets/js/344.af2b1413.js"><link rel="prefetch" href="/assets/js/345.6dfaf1a7.js"><link rel="prefetch" href="/assets/js/346.4bccf6c8.js"><link rel="prefetch" href="/assets/js/347.c42d14ab.js"><link rel="prefetch" href="/assets/js/348.f00c8f2c.js"><link rel="prefetch" href="/assets/js/349.47f740a6.js"><link rel="prefetch" href="/assets/js/35.e9eab731.js"><link rel="prefetch" href="/assets/js/350.30d3e969.js"><link rel="prefetch" href="/assets/js/351.1295792b.js"><link rel="prefetch" href="/assets/js/352.363b9177.js"><link rel="prefetch" href="/assets/js/353.601c5370.js"><link rel="prefetch" href="/assets/js/354.047a1d22.js"><link rel="prefetch" href="/assets/js/355.3f32b1c2.js"><link rel="prefetch" href="/assets/js/356.1816f3c9.js"><link rel="prefetch" href="/assets/js/357.c81f86b9.js"><link rel="prefetch" href="/assets/js/358.a2fdfdd3.js"><link rel="prefetch" href="/assets/js/359.a5e1fa6a.js"><link rel="prefetch" href="/assets/js/36.a655d7e3.js"><link rel="prefetch" href="/assets/js/360.cecc875b.js"><link rel="prefetch" href="/assets/js/361.c8915051.js"><link rel="prefetch" href="/assets/js/362.5c07a421.js"><link rel="prefetch" href="/assets/js/363.adc2e062.js"><link rel="prefetch" href="/assets/js/364.f0f96ce6.js"><link rel="prefetch" href="/assets/js/365.a4a5cc32.js"><link rel="prefetch" href="/assets/js/366.4dbc70ea.js"><link rel="prefetch" href="/assets/js/367.626ad073.js"><link rel="prefetch" href="/assets/js/368.033096e1.js"><link rel="prefetch" href="/assets/js/369.ba1ab9e8.js"><link rel="prefetch" href="/assets/js/37.46464e89.js"><link rel="prefetch" href="/assets/js/370.5a4de7d9.js"><link rel="prefetch" href="/assets/js/371.8e19304c.js"><link rel="prefetch" href="/assets/js/372.00d24aa5.js"><link rel="prefetch" href="/assets/js/373.5d43f401.js"><link rel="prefetch" href="/assets/js/374.eeea88f6.js"><link rel="prefetch" href="/assets/js/38.5710d281.js"><link rel="prefetch" href="/assets/js/39.22cd4ce1.js"><link rel="prefetch" href="/assets/js/4.d12742be.js"><link rel="prefetch" href="/assets/js/40.ac785c50.js"><link rel="prefetch" href="/assets/js/41.e52206b8.js"><link rel="prefetch" href="/assets/js/42.fbd0e0ce.js"><link rel="prefetch" href="/assets/js/43.e0830f9d.js"><link rel="prefetch" href="/assets/js/44.23c6ba45.js"><link rel="prefetch" href="/assets/js/45.b9a24221.js"><link rel="prefetch" href="/assets/js/46.83cf1192.js"><link rel="prefetch" href="/assets/js/47.220fb3ae.js"><link rel="prefetch" href="/assets/js/48.130760fa.js"><link rel="prefetch" href="/assets/js/49.d6f4ded1.js"><link rel="prefetch" href="/assets/js/5.216cae74.js"><link rel="prefetch" href="/assets/js/50.9cbfe92f.js"><link rel="prefetch" href="/assets/js/51.3446f694.js"><link rel="prefetch" href="/assets/js/52.72649f7e.js"><link rel="prefetch" href="/assets/js/53.6f0f60f7.js"><link rel="prefetch" href="/assets/js/54.a1d865f2.js"><link rel="prefetch" href="/assets/js/55.474dea5b.js"><link rel="prefetch" href="/assets/js/56.34577514.js"><link rel="prefetch" href="/assets/js/57.f6fc2205.js"><link rel="prefetch" href="/assets/js/58.a47a439e.js"><link rel="prefetch" href="/assets/js/59.06b99b85.js"><link rel="prefetch" href="/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/assets/js/60.20e5a404.js"><link rel="prefetch" href="/assets/js/61.06eb00d3.js"><link rel="prefetch" href="/assets/js/62.ef43b805.js"><link rel="prefetch" href="/assets/js/63.96d7abec.js"><link rel="prefetch" href="/assets/js/64.828a623b.js"><link rel="prefetch" href="/assets/js/65.8270a1b7.js"><link rel="prefetch" href="/assets/js/66.3da895e0.js"><link rel="prefetch" href="/assets/js/67.30e83906.js"><link rel="prefetch" href="/assets/js/68.c5db27df.js"><link rel="prefetch" href="/assets/js/69.561fe0b5.js"><link rel="prefetch" href="/assets/js/7.929bde26.js"><link rel="prefetch" href="/assets/js/70.0b3415d2.js"><link rel="prefetch" href="/assets/js/71.4351b7f3.js"><link rel="prefetch" href="/assets/js/72.ce1be2c6.js"><link rel="prefetch" href="/assets/js/73.d9f4c187.js"><link rel="prefetch" href="/assets/js/74.b8e2035e.js"><link rel="prefetch" href="/assets/js/75.f721109d.js"><link rel="prefetch" href="/assets/js/76.1fffa028.js"><link rel="prefetch" href="/assets/js/77.392e6f02.js"><link rel="prefetch" href="/assets/js/78.788b59e8.js"><link rel="prefetch" href="/assets/js/79.0118ba12.js"><link rel="prefetch" href="/assets/js/8.81ac42c3.js"><link rel="prefetch" href="/assets/js/80.41299197.js"><link rel="prefetch" href="/assets/js/81.d5c7efcc.js"><link rel="prefetch" href="/assets/js/82.0686785a.js"><link rel="prefetch" href="/assets/js/83.1c3c9afc.js"><link rel="prefetch" href="/assets/js/84.77cbfea0.js"><link rel="prefetch" href="/assets/js/85.a72511bb.js"><link rel="prefetch" href="/assets/js/86.ee7de8e7.js"><link rel="prefetch" href="/assets/js/87.6725a162.js"><link rel="prefetch" href="/assets/js/88.de798e46.js"><link rel="prefetch" href="/assets/js/89.e3b19fd4.js"><link rel="prefetch" href="/assets/js/9.0286aa6e.js"><link rel="prefetch" href="/assets/js/90.15a0b0a1.js"><link rel="prefetch" href="/assets/js/91.9c080a3d.js"><link rel="prefetch" href="/assets/js/92.2d7e99de.js"><link rel="prefetch" href="/assets/js/93.3a7c19cd.js"><link rel="prefetch" href="/assets/js/94.da299190.js"><link rel="prefetch" href="/assets/js/95.54d70fa0.js"><link rel="prefetch" href="/assets/js/96.68967f40.js"><link rel="prefetch" href="/assets/js/97.6ec5cb5a.js"><link rel="prefetch" href="/assets/js/98.4ce5bd4a.js"><link rel="prefetch" href="/assets/js/99.de11b345.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="content__default"><p>https://habr.com/ru/post/490842/</p> <h1 id="gpt-2-в-картинках-визуализация-языковых-моделеи-трансформера"><a href="#gpt-2-в-картинках-визуализация-языковых-моделеи-трансформера" class="header-anchor">#</a> GPT-2 в картинках (визуализация языковых моделей Трансформера)</h1> <p><img src="https://habrastorage.org/r/w1560/webt/1k/58/ea/1k58ea5w9egy2dc5z3jtsiip3sc.png" alt="openAI-GPT-2-3"></p> <p>В 2019 году мы стали свидетелями блистательного использования машинного обучения. <a href="https://openai.com/blog/better-language-models/" target="_blank" rel="noopener noreferrer">Модель GPT-2 от OpenAI<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> продемонстрировала впечатляющую способность писать связные и эмоциональные тексты, превосходящие наши представления о том, что могут генерировать современные языковые модели. GPT-2 не является какой-то особенно новой архитектурой – она очень напоминает Трансформер-Декодер (decoder-only Transformer). Отличие GPT-2 в том, что это поистине громадная языковая модель на основе Трансформера, обученная на внушительном наборе данных. В этой статье мы посмотрим на архитектуру модели, позволяющую добиться таких результатов: подробно рассмотрим слой внутреннего внимания (self-attention layer) и применение декодирующего Трансформера для задач, выходящих за рамки языкового моделирования.</p> <p><strong>Содержание</strong></p> <ul><li><a href="https://habr.com/ru/post/490842/#part_1" target="_blank" rel="noopener noreferrer">Часть 1: GPT-2 и языковое моделирование<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>Что такое языковая модель</li> <li>Трансформеры для языкового моделирования</li> <li>Одно отличие от BERT'а</li> <li>Эволюция блока Трансформера</li> <li>Экспресс-курс по нейрохирургии: заглядывая внутрь GPT-2</li> <li>Заглянем поглубже</li> <li>Конец первой части: GPT-2, дамы и господа</li></ul></li> <li><a href="https://habr.com/ru/post/490842/#part_2" target="_blank" rel="noopener noreferrer">Часть 2: визуализация внутреннего внимания<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>Внутреннее внимание (без маскирования)</li> <li>1 – Создание векторов Запроса, Ключа и Значения</li> <li>2 – Подсчет коэффициентов</li> <li>3 – Суммирование</li> <li>Визуализация маскированного внутреннего внимания</li> <li>Маскированное внутреннее внимание в GPT-2</li> <li>Вы сделали это!</li></ul></li> <li><a href="https://habr.com/ru/post/490842/#part_3" target="_blank" rel="noopener noreferrer">Часть 3: за пределами языкового моделирования<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>Машинный перевод</li> <li>Суммаризация</li> <li>Трансферное обучение</li> <li>Генерация музыки</li></ul></li> <li><a href="https://habr.com/ru/post/490842/#conclusion" target="_blank" rel="noopener noreferrer">Заключение<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://habr.com/ru/post/490842/#resources" target="_blank" rel="noopener noreferrer">Материалы<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h1 id="часть-1-gpt-2-и-языковое-моделирование"><a href="#часть-1-gpt-2-и-языковое-моделирование" class="header-anchor">#</a> Часть 1: GPT-2 и языковое моделирование</h1> <p>Что же такое языковое моделирование?</p> <h2 id="что-такое-языковая-модель"><a href="#что-такое-языковая-модель" class="header-anchor">#</a> Что такое языковая модель</h2> <p>В статье <a href="https://habr.com/ru/post/446530/" target="_blank" rel="noopener noreferrer">Word2vec в картинках<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> было описано, что такое языковая модель – по сути, это модель машинного обучения, которая смотрит на несколько слов в предложении и предсказывает следующее слово. Наиболее известная языковая модель – это клавиатура смартфона, которая по мере набора текста подсказывает вам продолжение.</p> <p><img src="https://habrastorage.org/r/w1560/webt/98/yv/br/98yvbr3q4hpjs8hfsg1rajz3n9m.png" alt="swiftkey-keyboard"></p> <p>В этом смысле можно сказать, что GPT-2 представляет собой алгоритм предсказывания следующего слова клавиатурного приложения, но более тяжеловесный и умный, чем тот, что реализован в вашем телефоне. GPT-2 была обучена на большом наборе данных размером 40 Гб (WebText), который OpenAI собрали из интернета в рамках своего исследовательского проекта. С точки зрения объема хранения данных, клавиатурное приложение, например SwiftKey, занимает до 78 Мб, в то время как самый маленький вариант обученной GPT-2 использует уже 500 Мб для хранения всех ее параметров, а самая большая модель GPT-2 – в 13 раз больше (так что она может занимать до 6,5 Гб).</p> <p><img src="https://habrastorage.org/r/w1560/webt/md/qg/ve/mdqgveo0tsyxqapfzqpomuu5nzo.png" alt="gpt2-sizes"></p> <p>Отличный способ поэкспериментировать с GPT-2 предоставляет сервис <a href="https://gpt2.apps.allenai.org/?text=Joel%20is" target="_blank" rel="noopener noreferrer">AllenAI GPT-2 Explorer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Он использует GPT-2 для отображения предсказания десяти наиболее вероятных слов (наряду с их вероятностью), идущих после введенного вами слова.</p> <h2 id="трансформеры-для-языкового-моделирования"><a href="#трансформеры-для-языкового-моделирования" class="header-anchor">#</a> Трансформеры для языкового моделирования</h2> <p>Как мы увидели в статье <a href="https://habr.com/ru/post/486358/" target="_blank" rel="noopener noreferrer">Трансформер в картинках<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, релизная модель Трансформера состояла из энкодера и декодера – каждый представляет собой стек т.н. блоков Трансформера. Эта архитектура подходила для машинного перевода – задачи, где архитектуры энкодер-декодер показывали хорошие результаты и в прошлом.</p> <p><img src="https://habrastorage.org/r/w1560/webt/sv/tx/hm/svtxhmcbpksa7rjn0wb0o2jj_wc.png" alt="transformer-encoder-decoder"></p> <p>Последовавшие за релизом исследования показали, что мы можем отбросить декодер или энкодер и использовать всего один стек блоков Трансформера, надстраивая эти блоки столько, сколько вообще возможно, скармливая им огромные объемы текстовых данных для обучения и выполняя громадные объемы вычислений на них (некоторые из этих моделей требуют сотни тысяч долларов для обучения и даже миллионы в случае с AlphaStar).</p> <p><img src="https://habrastorage.org/r/w1560/webt/j4/sb/4r/j4sb4rysituzcqsafgktspu0pa8.png" alt="gpt-2-transformer-xl-bert-3"></p> <p>Как высоко мы можем надстраивать эти блоки? Выясняется, что это и есть одно из главных отличий между моделями GPT-2 разных размеров:</p> <p><img src="https://habrastorage.org/r/w1560/webt/gg/og/nr/ggognri38aojdzkkzazvnetxfvy.png" alt="gpt2-sizes-hyperparameters-3"></p> <h2 id="одно-отличие-от-bert-а"><a href="#одно-отличие-от-bert-а" class="header-anchor">#</a> Одно отличие от BERT'а</h2> <blockquote><p><strong>Первый закон робототехники:</strong><br>
Робот не может причинить вред человеку или своим бездействием допустить, чтобы человеку был причинён вред.</p></blockquote> <p>Модель GPT-2 построена с помощью блоков декодера Трансформера. BERT же, напротив, использует блоки энкодера. Мы посмотрим на разницу двух подходов в следующей части. Но одно ключевое различие состоит в том, что GPT-2, как и все традиционные языковые модели, генерирует на выходе один токен за раз. Посмотрим для примера, как хорошо обученная модель GPT-2 генерирует первый закон робототехники:</p> <p><img src="https://habrastorage.org/webt/so/pv/tj/sopvtjhr-crr3rgtf_zaoqomgck.gif" alt="gpt-2-output"></p> <p>На деле происходит следующее: после того, как был вычислен каждый токен, он добавляется во входную последовательность. И эта новая последовательность подается на вход модели на следующем шаге. Эта идея называется «авторегрессией» (auto-regression) и именно она <a href="https://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener noreferrer">сделала RNN сети неоправданно эффективными<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><img src="https://habrastorage.org/webt/un/7x/ir/un7xirwndekafrdeixsce0ocmmm.gif" alt="gpt-2-autoregression-2"></p> <p>GPT-2 и некоторые новые модели вроде TransformerXL и XLNet авторегрессивны по своей природе. BERT нет. И это своего рода компромисс. Потеряв авторегрессию, BERT приобрел способность включать контекст по обе стороны слова для получения лучших результатов. XLNet вернул себе авторегрессию, найдя при этом альтернативный способ инкорпорировать контекст по обе стороны.</p> <h2 id="эволюция-блока-трансформера"><a href="#эволюция-блока-трансформера" class="header-anchor">#</a> Эволюция блока Трансформера</h2> <p><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer">Релизная статья<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> предложила два типа блоков Трансформера.</p> <h3 id="блок-энкодера"><a href="#блок-энкодера" class="header-anchor">#</a> Блок энкодера</h3> <p>Первый – это блок энкодера:</p> <p><img src="https://habrastorage.org/r/w1560/webt/f_/ym/xb/f_ymxbcpvszucrhogiurzwqypzk.png" alt="transformer-encoder-block-2"></p> <p><em>Блок энкодера из релизной статьи Трансформера может принимать на вход последовательности ограниченной длины (например, 512 токенов). Если входная последовательность меньше этого ограничения, то мы можем просто заполнить остаток последовательности нулями.</em></p> <h3 id="блок-декодера"><a href="#блок-декодера" class="header-anchor">#</a> Блок декодера</h3> <p>Второй – это блок декодера, который архитектурно мало отличается от энкодера. Он позволяет обращать внимание на особые сегменты энкодера:</p> <p><img src="https://habrastorage.org/r/w1560/webt/gh/so/u6/ghsou6icfirnjbj1abkj7ouqohg.png" alt="transformer-decoder-block-2"></p> <p>Ключевая разница заключается в механизме работы слоя внутреннего внимания и состоит в том, что здесь будущие токены маскируются не заменой слова на [mask] токен, как в BERT'е, а с помощью изменения процесса подсчета внутреннего внимания и блокирования информации от токенов, находящихся справа от той позиции, которая высчитывается в данный момент.</p> <p>Если, например, мы хотим подсветить траекторию позиции #4, мы можем увидеть, что можно обратиться лишь к этому и предыдущему токену:</p> <p><img src="https://habrastorage.org/r/w1560/webt/ta/9r/td/ta9rtdiimdxkwmwpmdxy2ig-0h8.png" alt="transformer-decoder-block-self-attention-2"></p> <p>Важно провести различие между внутренним вниманием, которое использует BERT, и маскированным внутренним вниманием GPT-2. Обычный блок внутреннего внимания позволяет достать до токенов справа. Маскированное внутреннее внимание не позволяет этого сделать:</p> <p><img src="https://habrastorage.org/r/w1560/webt/43/cq/pd/43cqpdiypmyuccr1gznrhr4tioo.png" alt="self-attention-and-masked-self-attention"></p> <h3 id="блок-декодирования"><a href="#блок-декодирования" class="header-anchor">#</a> Блок декодирования</h3> <p>Следуя за релизной, статья <a href="https://arxiv.org/pdf/1801.10198.pdf" target="_blank" rel="noopener noreferrer">«Generating Wikipedia by Summarizing Long Sequences»<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> предложила другую организацию блоков трансформера, позволяющую создавать языковые модели: она отбросила энкодер Трансформера. Поэтому давайте назовем эту модель «Трансформер-Декодер». Эта ранняя языковая модель на основе Трансформера состояла из стека с 6 блоками декодера Трансформера:</p> <p><img src="https://habrastorage.org/r/w1560/webt/rd/l7/k-/rdl7k--_z3kg4ajejaycksxqpt0.png" alt="transformer-decoder-intro"></p> <p><em>Блоки декодера идентичны. На развернутом изображении одного из них видно, что слой внутреннего внимания маскирован. Заметьте, что модель теперь может обращаться к 4000 токенов в отдельном сегменте – значительное улучшение по сравнению с 512 токенами оригинального трансформера.</em></p> <p>Эти блоки весьма похожи на оригинальные блоки декодера, кроме того, что они отбросили второй слой внутреннего внимания. Схожая архитектура была исследована в статье <a href="https://arxiv.org/pdf/1808.04444.pdf" target="_blank" rel="noopener noreferrer">«Языковое моделирование на уровне символов с более глубоким внутренним вниманием»<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, где была создана языковая модель для предсказания одной буквы/символа за один период времени.</p> <p>Модель GPT-2 от OpenAI использует именно такие блоки декодирования.</p> <h2 id="экспресс-курс-по-неирохирургии-заглядывая-внутрь-gpt-2"><a href="#экспресс-курс-по-неирохирургии-заглядывая-внутрь-gpt-2" class="header-anchor">#</a> Экспресс-курс по нейрохирургии: заглядывая внутрь GPT-2</h2> <blockquote><p>Загляни вглубь, и ты увидишь, как слова режут глубоко в моём мозге. Гроза обжигает, быстро обжигает, словесный нож вводит меня в безумие, безумие, да. (Budgie)</p></blockquote> <p>Давайте положим обученную GPT-2 модель на наш операционный стол и посмотрим, как она работает.</p> <p><img src="https://habrastorage.org/r/w1560/webt/he/ig/hj/heighjb23joyolbax5b7__fvj6a.png" alt="gpt-2-layers-2"></p> <p><em>GPT-2 может обработать 1024 токена. Каждый токен проходит через все блоки декодера по своей собственной траектории.</em></p> <p>Самый простой способ запустить обученную GPT-2 – пустить ее в свободное плавание (что технически называется генерацией безусловных выборок) или дать ей пример (подсказку), чтобы она могла говорить на определенную тему (т.е. генерация интерактивных условных выборок). В первом случае мы можем просто передать ей стартовый токен, и модель начнет генерировать слова (обученная модель использует в качестве стартового токена &lt;|endoftext|&gt;; обозначим его просто как &lt;|s|&gt;).</p> <p><img src="https://habrastorage.org/webt/ho/yz/o0/hoyzo0yvmbi3gf-1awm__udx0fi.gif" alt="gpt2-simple-output-2"></p> <p>У модели есть только один входной токен, так что первая траектория окажется единственной активной. Токен успешно обрабатывается всеми слоями декодера и преобразуется в вектор, которому присваивается коэффициент (score) относительно словаря – всех слов, которые модель знает (50 тысяч слов у GPT-2). В нашем случае мы выбрали токен с наибольшей вероятностью – «the». Но есть шанс что-то перепутать – вы знаете, как бывает, когда вы пытаетесь нажать на предложенное слово на клавиатуре, и оно застревает в повторяющемся цикле, единственный выход из которого – нажать на второе или третье предложенное слово. То же может произойти и здесь. GPT-2 имеет параметр top-k, который мы можем использовать для того, чтобы модель рассматривала некоторую выборку слов, а не только топ слово (последнее, по сути, является случаем top-k = 1).</p> <p>На следующем этапе мы добавляем наш выход во входную последовательность и модель предсказывает следующее слово:</p> <p><img src="https://habrastorage.org/webt/hg/2x/ps/hg2xpsd1kuverowaqcd4z_w--ki.gif" alt="gpt-2-simple-output-3"></p> <p>Обратите внимание, что в этой итерации активна лишь вторая траектория. Каждый слой GPT-2 сохраняет свою собственную интерпретацию первого токена и будет использовать ее в обработке второго (более подробно мы расскажем чуть ниже в разделе о внутреннем внимании). GPT-2 не переинтерпретирует первый токен после появления второго.</p> <h2 id="заглянем-поглубже"><a href="#заглянем-поглубже" class="header-anchor">#</a> Заглянем поглубже</h2> <h3 id="кодирование-входа"><a href="#кодирование-входа" class="header-anchor">#</a> Кодирование входа</h3> <p>Рассмотрим модель более детально. Начнем со входа. Как и в других NLP-моделях, о которых мы говорили ранее, эта модель ищет эмбеддинг слова в своей матрице эмбеддингов – один из компонентов, входящих в обученную модель.</p> <p><img src="https://habrastorage.org/r/w1560/webt/qo/ml/jl/qomljlikh-rqxyud6otmaxrtyum.png" alt="gpt2-token-embeddings-wte-2"></p> <p><em>В строках расположены эмбеддинги – наборы чисел, представляющие слова и улавливающие какую-то часть их значения. Размеры этих наборов могут быть разным в зависимости от размера модели GPT-2. Самая маленькая модель использует эмбеддинги размерностью 768 на слово/токен.</em></p> <p>Итак, сначала мы ищем эмбеддинг стартового слова &lt;|s|&gt; в матрице эмбеддингов. Прежде чем передать его в первый блок модели, нам нужно применить позиционное кодирование – сигнал, указывающий на порядок слов в последовательности в блоке Трансформера. Частью обученной модели является матрица, содержащая позиционные кодирующие векторы для каждой из 1024 позиций во входе.</p> <p><img src="https://habrastorage.org/r/w1560/webt/zp/mu/cg/zpmucgftth4mabqo60oolwdohey.png" alt="gpt2-positional-encoding"></p> <p>Таким образом обрабатывается входное слово перед поступлением в первый блок Трансформера. Мы также знаем две матрицы весов, входящих в состав обученной GPT-2.</p> <p><img src="https://habrastorage.org/r/w1560/webt/me/r8/bx/mer8bx3ofjqcpydqnfsvo1fk4ok.png" alt="gpt2-input-embedding-positional-encoding-3"></p> <p><em>Передача слова в первый блок трансформера означает поиск его эмбеддинга и добавление вектора позиционного кодирования для позиции #1.</em></p> <h3 id="путешествие-вверх-по-стеку"><a href="#путешествие-вверх-по-стеку" class="header-anchor">#</a> Путешествие вверх по стеку</h3> <p>Первый блок может теперь обработать токен, сначала проведя его через механизм внутреннего внимания, а затем через слой нейронной сети. Как только первый блок трансформера обработает токен, он высылает результирующий вектор вверх по стеку для последующей обработки вышестоящими блоками. Этот процесс идентичен в каждом блоке, но их веса как для внутреннего внимания, так и для нейронных подслоев отличаются.</p> <p><img src="https://habrastorage.org/r/w1560/webt/ij/9e/3a/ij9e3alc1pc5ihgpd8njpbh2-vy.png" alt="gpt2-transformer-block-vectors-2"></p> <h3 id="обзор-внутреннего-внимания"><a href="#обзор-внутреннего-внимания" class="header-anchor">#</a> Обзор внутреннего внимания</h3> <p>Язык в значительной мере опирается на контекст. Например, посмотрите на Второй закон робототехники:</p> <blockquote><p>Робот должен повиноваться всем приказам, которые даёт <strong>ему</strong> человек, кроме тех случаев, когда <strong>эти приказы</strong> противоречат <strong>Первому Закону</strong>.</p></blockquote> <p>Мы выделили несколько мест в предложении, где слова отсылают к другим словам. Невозможно понять или обработать эти слова без учета контекста, на который они ссылаются. Когда модель обрабатывает такое предложение, ей необходимо уметь понимать, что:</p> <ul><li><strong>ему</strong> относится к роботу;</li> <li><strong>эти приказы</strong> относится к упоминавшимся ранее приказам («которые даёт ему человек»);</li> <li><strong>Первому Закону</strong> относится к целому первому закону.</li></ul> <p>Именно это и делает внутреннее внимание: оно помогает модели понять релевантные и связанные слова для того, чтобы оценить контекст для каждого слова, прежде чем приступить к его обработке (прохождению через нейронную сеть). Для этого всем словам присваивают коэффициенты, обозначающие степень релевантности каждого из них в сегменте текста, и добавляют их в векторы представления этих слов.</p> <p>Рассмотрим пример, где слой внутреннего внимания в верхнем блоке обращает внимание на «a robot» во время обработки слова «it». Вектор, который он передаст в свою нейронную сеть, будет суммой векторов для каждого из трех слов, умноженных на их коэффициенты.</p> <p><img src="https://habrastorage.org/r/w1560/webt/yx/vw/ou/yxvwoujcadhlalw2xgq3dnoezjq.png" alt="gpt2-self-attention-example-2"></p> <h3 id="алгоритм-внутреннего-внимания"><a href="#алгоритм-внутреннего-внимания" class="header-anchor">#</a> Алгоритм внутреннего внимания</h3> <p>Внутреннее внимание работает параллельно для каждой траектории токена в сегменте. Важными компонентами являются три вектора:</p> <ul><li><strong>Запрос</strong> – это представление текущего слова, которое используется для вычисления коэффициентов для всех других слов (используя их ключи). Мы рассматриваем лишь запрос для токена, который обрабатываем в данный момент;</li> <li><strong>Ключ</strong> – своего рода лейбл для слов в сегменте. Именно его мы сопоставляем при поиске релевантных слов;</li> <li><strong>Значение</strong> – это фактическое представление самих слов; как только мы посчитаем коэффициент того, насколько слово релевантно, мы добавляем векторы Значения для представления текущего слова.</li></ul> <p><img src="https://habrastorage.org/r/w1560/webt/ds/30/gu/ds30gubjhv2r7ubicxiq-idgdlg.png" alt="self-attention-example-folders-3"></p> <p>В качестве грубой аналогии можно сравнить это с поиском по картотеке. Запрос – это бумажка с названием того, что необходимо найти. Ключами будут подписи на папках внутри картотеки. Найдя подходящую папку, мы можем достать ее содержимое – вектор значения. Но в случае с внутренним вниманием мы ищем не одно значение, а сочетание значений из набора папок.</p> <p>Умножение вектора запроса на каждый из векторов ключа даст нам коэффициенты для каждой папки (технически: скалярное произведение с последующей функцией софтмакс).</p> <p><img src="https://habrastorage.org/r/w1560/webt/br/mp/xd/brmpxdc2ngiqgrkmrgn1wb5aud4.png" alt="self-attention-example-folders-scores-3"></p> <p>Сложив произведения каждого значения на его коэффициент, мы получим результат внутреннего внимания.</p> <p><img src="https://habrastorage.org/r/w1560/webt/xv/7n/ez/xv7nezgfhygrknpndfsptjwucpe.png" alt="gpt2-value-vector-sum"></p> <p>Этот набор взвешенных векторов значений представляет собой вектор, который 50% своего внимания обратил на слово «robot», 30% на слово «a» и 19% – на слово «it». Ниже в статье мы подробнее остановимся на внутреннем внимании. Но прежде продолжим наше путешествие вверх по стеку к выходу модели.</p> <h3 id="выход-модели"><a href="#выход-модели" class="header-anchor">#</a> Выход модели</h3> <p>Когда верхний блок модели выдает выходной вектор (результат его собственного слоя внутреннего внимания и последующего слоя нейронной сети), модель умножает его на матрицу эмбеддингов.</p> <p><img src="https://habrastorage.org/r/w1560/webt/vz/tt/mf/vzttmfwinmu2z7v3m0hkxijm5o8.png" alt="gpt2-output-projection-2"></p> <p>Как вы помните, каждая строка в матрице эмбеддингов соответствует эмбеддингу слова в словаре модели. Результатом этого произведения будет коэффициент для каждого слова из словаря.</p> <p><img src="https://habrastorage.org/r/w1560/webt/fg/ib/yq/fgibyqwocamlo1cax73ck1qxrwg.png" alt="gpt2-output-scores-2"></p> <p>Мы можем просто выбрать токен с наибольшим коэффициентом (top_k = 1). Но результаты будут лучше, если модель будет учитывать также и другие слова. Поэтому хорошей стратегией будет выбрать слово из целого списка, используя коэффициент в качестве вероятности того, что это слово будет выбрано (так слова с наивысшим коэффициентом будут иметь больше шансов быть выбранными). Компромиссный вариант – установить top_k равный 40: так модель будет иметь в виду 40 слов с наибольшими коэффициентами.</p> <p><img src="https://habrastorage.org/r/w1560/webt/ji/zl/mk/jizlmk0ywrvlljh6ynxq_eqacjs.png" alt="gpt2-output"></p> <p>Таким образом, модель завершила одну итерацию и выдала одно слово. Далее этот процесс повторяется до тех пор, пока не будет сгенерирован весь контекст (1024 токена) или пока не появится токен конца предложения.</p> <h2 id="конец-первои-части-gpt-2-дамы-и-господа"><a href="#конец-первои-части-gpt-2-дамы-и-господа" class="header-anchor">#</a> Конец первой части: GPT-2, дамы и господа</h2> <p>Итак, мы прошлись по тому, как работает GPT-2. Если вам любопытно узнать, что именно происходит внутри слоя внутреннего внимания, то следующая бонусная часть определенно для вас. Она была создана для того, чтобы предложить некоторые визуальные средства для описания механизма внутреннего внимания и облегчить дальнейший разбор моделей трансформера (таких как TransformerXL и XLNet).</p> <p>Хотелось бы отметить некоторые упрощения, к которым пришлось прибегнуть в этой статье:</p> <ul><li>«Слова» и «токены» использовались как синонимы и в этой статье взаимозаменяемы; однако на самом деле GPT-2 использует парную байтовую кодировку (Byte Pair Encoding) для создания токенов своего словаря. Это означает, что обычно токенами являются части слова.</li> <li>В нашем примере модель GPT-2 работает в режиме вывода/оценки (inference/evaluation mode). Вот почему она обрабатывает только одно слово за раз. Во время обучения модель будет обучаться на более длинных последовательностях текста и обрабатывать единовременно несколько токенов. Также на этапе обучения модель может обрабатывать батчи больших размеров (512), в отличие от батчей размером 1, которые используются в режиме оценки.</li> <li>Автор был несколько волен в ротации/транспозиции векторов для лучшей организации пространства и картинок. Во время применения модели необходимо быть более точным.</li> <li>В Трансформерах широко применяется техника нормализации слоев, и это достаточно важно. Мы отметили некоторые примеры ее использования в <a href="https://habr.com/ru/post/486358/" target="_blank" rel="noopener noreferrer">Transformer в картинках<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, а в этой статье в основном сосредоточимся на внутреннем внимании.</li> <li>В некоторых случаях было необходимо изобразить больше квадратиков для представления вектора. Эти случаи были описаны как «zoom in», например:</li></ul> <p><img src="https://habrastorage.org/r/w1560/webt/q_/kq/35/q_kq35nsjwiycnwcafi8ctxl_tm.png" alt="zoom-in"></p> <h1 id="часть-2-визуализация-внутреннего-внимания"><a href="#часть-2-визуализация-внутреннего-внимания" class="header-anchor">#</a> Часть 2: визуализация внутреннего внимания</h1> <p>Ранее в статье мы показывали эту картинку для иллюстрации применения внутреннего внимания в слое, обрабатывающем слово «it»:</p> <p><img src="https://habrastorage.org/r/w1560/webt/ss/7h/dk/ss7hdk8hwx43lbghil2t3os95bm.png" alt="gpt2-self-attention-1-2"></p> <p>В этой части мы рассмотрим более детально то, как это происходит. При этом мы будем пытаться понять, что происходит с каждым конкретным словом, поэтому далее будет много иллюстраций отдельных векторов. И хотя в реальности применение внутреннего внимания происходит с помощью перемножения гигантского размера матриц, мы остановимся здесь на интуиции того, что происходит на уровне одного слова.</p> <h2 id="внутреннее-внимание-без-маскирования"><a href="#внутреннее-внимание-без-маскирования" class="header-anchor">#</a> Внутреннее внимание (без маскирования)</h2> <p>Давайте посмотрим на оригинальное внутреннее внимание, которое подсчитывается в блоке энкодера. Рассмотрим упрощенный блок Трансформера, обрабатывающий всего 4 токена за раз.</p> <p>Применение внутреннего внимания требует выполнения трех основных шагов:</p> <ol><li>Создание векторов Запроса, Ключа и Значения для каждой траектории;</li> <li>Использование вектора Запроса каждого входного токена для подсчета коэффициента относительно всех других векторов Ключа;</li> <li>Умножение векторов Значения на присвоенный им коэффициент и суммирование получившихся значений.</li></ol> <p><img src="https://habrastorage.org/r/w1560/webt/ab/l8/ax/abl8ax5sj4nuqdq8jihtayycpvc.png" alt="self-attention-summary"></p> <h2 id="_1-создание-векторов-запроса-ключа-и-значения"><a href="#_1-создание-векторов-запроса-ключа-и-значения" class="header-anchor">#</a> 1 – Создание векторов Запроса, Ключа и Значения</h2> <p>Сфокусируемся на первой траектории. Мы возьмем ее вектор Запроса и сравним со всеми ключами. Это создаст коэффициент для каждого ключа. Первым шагом во внутреннем внимании является подсчет трех векторов для траектории каждого токена (опустим пока «головы» внимания):</p> <p><img src="https://habrastorage.org/r/w1560/webt/qc/7c/0l/qc7c0ll_eqaebzsk5jqluip1j7k.png" alt="self-attention-1"></p> <p><em>Для каждого входного токена создается вектор Запроса, вектор Ключа и вектор Значения путем произведения на соответствующие матрицы весов WQ, WK, WV</em></p> <h2 id="_2-подсчет-коэффициентов"><a href="#_2-подсчет-коэффициентов" class="header-anchor">#</a> 2 – Подсчет коэффициентов</h2> <p>Теперь, когда у нас есть векторы, мы можем использовать векторы Запроса и Ключа для выполнения шага №2: перемножим вектор Запроса рассматриваемого нами первого токена на все векторы Ключа и получим коэффициент для каждого из четырех токенов.</p> <p><img src="https://habrastorage.org/r/w1560/webt/47/tl/vm/47tlvmotgdunt0od7rzfptulwxi.png" alt="self-attention-2"></p> <p><em>Перемножим (скалярное произведение) вектор Запроса рассматриваемого токена на все векторы Ключа и получим коэффициент того, насколько токены соответствуют друг другу</em></p> <h2 id="_3-суммирование"><a href="#_3-суммирование" class="header-anchor">#</a> 3 – Суммирование</h2> <p>Теперь мы можем перемножить коэффициенты и векторы Значений. Значение с наибольшим коэффициентом будет составлять большую часть результирующего вектора после того, как мы подсчитаем их сумму.</p> <p><img src="https://habrastorage.org/r/w1560/webt/nz/aa/sl/nzaaslrrr6etmrs-qlkhlb9o6oc.png" alt="self-attention-3-2"></p> <p><em>Перемножим векторы Значений на их коэффициенты и сложим получившиеся произведения</em></p> <p>Чем меньше коэффициент, тем более прозрачным изображен вектор Значения – наглядная визуализация того, как умножение на небольшой коэффициент уменьшает долю этого вектора в результирующем векторе.</p> <p>Если мы выполним данную операцию для каждой траектории, мы получим вектор, представляющий соответствующий токен и содержащий подходящий контекст этого токена. Эти векторы затем передаются в следующий подслой блока Трансформера (нейронную сеть прямого распространения).</p> <h2 id="визуализация-маскированного-внутреннего-внимания"><a href="#визуализация-маскированного-внутреннего-внимания" class="header-anchor">#</a> Визуализация маскированного внутреннего внимания</h2> <p>Теперь, когда мы посмотрели на то, что происходит внутри этапа внутреннего внимания Трансформера, мы перейдем к маскированному внутреннему вниманию. Оно идентично внутреннему вниманию вплоть до шага №2. Предположим, модель имеет только два токена на входе и мы рассматриваем второй. В этом случае последние два токена маскируются. Таким образом модель вмешивается в процесс распределения коэффициентов, наделяя все будущие токены нулевыми весами:</p> <p><img src="https://habrastorage.org/r/w1560/webt/di/h6/vx/dih6vxt0pa-5ipj_qtruxbmbcae.png" alt="masked-self-attention-2"></p> <p>Это маскирование часто применяется в качестве матрицы, называемой маской внимания (attention mask). Возьмем, например, последовательность из четырех слов («robot must obey orders»). В случае языкового моделирования эта последовательность обрабатывается за 4 шага: один для каждого слова (с допущением, что каждое слово – это один токен). Т.к. эти модели работают батчами, мы можем установить размер батча 4 для нашей упрощенной модели, которая будет обрабатывать целую последовательность (с ее 4 шагами) как один батч.</p> <p><img src="https://habrastorage.org/r/w1560/webt/ot/_d/k9/ot_dk95ismt5lcax-xeomlzxigu.png" alt="transformer-decoder-attention-mask-dataset"></p> <p>Мы подсчитываем коэффициенты в матричной форме, перемножая матрицу Запроса на матрицу Ключа. Изобразим это следующим образом, имея в виду, что вместо слова будет стоять вектор Запроса (или Ключа), соответствующий слову в ячейке:</p> <p><img src="https://habrastorage.org/r/w1560/webt/2_/kz/ws/2_kzws5vewj2dvdy-rtcgwjxdd8.png" alt="queries-keys-attention-mask"></p> <p>После перемножения мы «нахлобучиваем» нашу треугольную маску внимания. В те ячейки, которые мы хотим спрятать, она ставит или маску –бесконечность (-inf) или очень большое отрицательное число (например, -1 миллиард в GPT-2):</p> <p><img src="https://habrastorage.org/r/w1560/webt/86/aw/oh/86awoh2nlrcsdh3_hveet0rh3vw.png" alt="transformer-attention-mask"></p> <p>Затем, применяя функцию софтмакс для каждой строки, получим реальные коэффициенты, которые и будем использовать для внутреннего внимания:</p> <p><img src="https://habrastorage.org/r/w1560/webt/cr/-o/ku/cr-okuz6tuuuaeht--j8mjblnqo.png" alt="transformer-attention-masked-scores-softmax"></p> <p>Эта таблица коэффициентов означает следующее:</p> <ul><li>Когда модель обрабатывает первый пример из набора данных (строка №1), который содержит только одно слово («robot»), 100% всего внимания будет на самом слове.</li> <li>Когда модель обрабатывает второй пример из набора данных (строка №2), который содержит слова («robot must»), во время обработки слова «must» 48% всего внимания будет на «robot» и 52% будет на слове «must».</li> <li>И т.д.</li></ul> <h2 id="маскированное-внутреннее-внимание-в-gpt-2"><a href="#маскированное-внутреннее-внимание-в-gpt-2" class="header-anchor">#</a> Маскированное внутреннее внимание в GPT-2</h2> <p>Рассмотрим более подробно маскированное внутреннее внимание в GPT-2.</p> <h3 id="время-оценки-обработка-одного-токена-за-раз"><a href="#время-оценки-обработка-одного-токена-за-раз" class="header-anchor">#</a> Время оценки: обработка одного токена за раз</h3> <p>Мы можем сделать так, чтобы GPT-2 работала в точности так же, как маскированное внутреннее внимание. Но во время оценки, когда наша модель только добавляет одно новое слово после каждой итерации, будет неэффективно пересчитывать внутреннее внимание для более ранних траекторий токенов, которые уже были обработаны.</p> <p>В этом случае мы обрабатываем первый токен (пока игнорируя &lt;|s|&gt;).</p> <p><img src="https://habrastorage.org/r/w1560/webt/oc/r2/ps/ocr2ps037_1vvr2uajz1idbe76g.png" alt="gpt2-self-attention-qkv-1-2"></p> <p>GPT-2 ждет векторы Ключа и Значения токена «a». Каждый слой внутреннего внимания ожидает соответствующие векторы Ключа и Значения для этого токена:</p> <p><img src="https://habrastorage.org/r/w1560/webt/0e/wf/vx/0ewfvx7snx6azpvwietxqfd9zzg.png" alt="gpt2-self-attention-qkv-2-2"></p> <p>На следующей итерации, когда модель обрабатывает слово «robot», уже не нужно генерировать векторы Запроса, Ключа и Значения для токена «a» – модель просто использует векторы, сохраненные на первой итерации:</p> <p><img src="https://habrastorage.org/r/w1560/webt/re/qe/ff/reqeffjn9neoql-qqpiqp8hwmjq.png" alt="gpt2-self-attention-qkv-3-2"></p> <h3 id="внутреннее-внимание-gpt-2-1-создание-векторов-запроса-ключа-и-значения"><a href="#внутреннее-внимание-gpt-2-1-создание-векторов-запроса-ключа-и-значения" class="header-anchor">#</a> Внутреннее внимание GPT-2: 1 – Создание векторов Запроса, Ключа и Значения</h3> <p>Предположим, что модель обрабатывает слово «it». Что касается нижнего блока, то его вход для этого токена будет эмбеддингом «it» + вектор позиционного кодирования для слота #9:</p> <p><img src="https://habrastorage.org/r/w1560/webt/k1/ol/ee/k1oleegivyrvsvcx-glsjjxdt14.png" alt="gpt2-self-attention-1"></p> <p>Каждый блок в Трансформере имеет свои собственные матрицы весов (подробнее о них далее в статье), которые мы используем для создания векторов Запросов, Ключей и Значений.</p> <p><img src="https://habrastorage.org/r/w1560/webt/ws/nc/1k/wsnc1kowztsdydbbgkevy7ycene.png" alt="gpt2-self-attention-2"></p> <p><em>Внутреннее внимание перемножает входные данные на матрицу весов и добавляет вектор смещения (bias vector), отсутствующий на картинке</em></p> <p>Результатом этого произведения будет вектор, который является по сути конкатенацией векторов Запроса, Ключа и Значения для слова «it».</p> <p><img src="https://habrastorage.org/r/w1560/webt/od/oc/ag/odocagmiv-m420l-3wy8sdila4w.png" alt="gpt2-self-attention-3"></p> <p><em>Перемножение входного вектора на вектора весов внимания (и последующее сложение с вектором смещения) образует векторы Ключа, Значения и Запроса для этого токена</em></p> <h3 id="внутреннее-внимание-gpt-2-1-5-разделение-на-«головы»-внимания"><a href="#внутреннее-внимание-gpt-2-1-5-разделение-на-«головы»-внимания" class="header-anchor">#</a> Внутреннее внимание GPT-2: 1.5 – Разделение на «головы» внимания</h3> <p>В предыдущих примерах мы сразу окунулись во внутреннее внимание, игнорируя его «многоголовую» часть. Будет полезно кратко пролить свет на этот концепт. Внутреннее внимание осуществляется множество раз в разных частях векторов Запроса (Q), Ключа (K) и Значения (V). Разделение на «головы» внимания – это просто преобразование длинных векторов в матрицу. У маленьких GPT-2 есть по 12 «голов» внимания, что является первым измерением преобразованной матрицы:</p> <p><img src="https://habrastorage.org/r/w1560/webt/zt/qf/wr/ztqfwr4l3kaoq243xhlleg4ro2i.png" alt="gpt2-self-attention-split-attention-heads-1"></p> <p>В предыдущих примерах мы рассматривали, что происходит внутри одной «головы» внимания. Что касается множественных «голов» внимания, то можно изобразить этот процесс следующим образом (для простоты изобразим только три из 12 «голов» внимания):</p> <p><img src="https://habrastorage.org/r/w1560/webt/lu/8a/5c/lu8a5cqdztpnonylf6jfxpopngg.png" alt="gpt2-self-attention-split-attention-heads-2"></p> <h3 id="внутреннее-внимание-gpt-2-2-подсчет-коэффициентов"><a href="#внутреннее-внимание-gpt-2-2-подсчет-коэффициентов" class="header-anchor">#</a> Внутреннее внимание GPT-2: 2 – Подсчет коэффициентов</h3> <p>Теперь мы можем перейти к вычислению коэффициентов (помня о том, что мы рассматриваем только одну «голову» внимания и что в других происходят схожие операции):</p> <p><img src="https://habrastorage.org/r/w1560/webt/ab/0b/nm/ab0bnmrgkb-3knzrtitk2e64opi.png" alt="gpt2-self-attention-scoring"></p> <p>Токен получает коэффициент относительно всех Ключей других токенов (которые мы посчитали в «голове» внимания #1 в предыдущие итерации):</p> <p><img src="https://habrastorage.org/r/w1560/webt/zc/ll/nt/zcllnthmdvddhniljejpbgke8is.png" alt="gpt2-self-attention-scoring-2"></p> <h3 id="внутреннее-внимание-gpt-2-3-суммирование"><a href="#внутреннее-внимание-gpt-2-3-суммирование" class="header-anchor">#</a> Внутреннее внимание GPT-2: 3 – Суммирование</h3> <p>Как мы видели ранее, теперь мы умножаем каждое Значение на его коэффициент и, суммируя, получаем результат внутреннего внимания для «головы» внимания #1:</p> <p><img src="https://habrastorage.org/r/w1560/webt/dv/rf/-i/dvrf-ik3yxkidhzgihbuuqv4sww.png" alt="gpt2-self-attention-multihead-sum-1"></p> <h3 id="внутреннее-внимание-gpt-2-3-5-объединение-«голов»-внимания"><a href="#внутреннее-внимание-gpt-2-3-5-объединение-«голов»-внимания" class="header-anchor">#</a> Внутреннее внимание GPT-2: 3.5 – Объединение «голов» внимания</h3> <p>Обработка различных «голов» внимания заключается, прежде всего, в конкатенации их в один вектор:</p> <p><img src="https://habrastorage.org/r/w1560/webt/p9/jg/bg/p9jgbgr9-c8lzl-zjnqfdortvxe.png" alt="gpt2-self-attention-merge-heads-1"></p> <p>Но этот вектор еще нельзя отправлять на следующий подслой. Необходимо превратить этого франкенштейна скрытых состояний в однородное представление.</p> <h3 id="внутреннее-внимание-gpt-2-4-проецирование"><a href="#внутреннее-внимание-gpt-2-4-проецирование" class="header-anchor">#</a> Внутреннее внимание GPT-2: 4 – Проецирование</h3> <p>Мы позволим модели учиться, как лучше сопоставить конкатенированный результат внутреннего внимания с вектором, с которым может работать нейронная сеть прямого распространения. Для этого понадобится вторая большая матрица весов, которая проецирует результаты «голов» внимания в выходной вектор подслоя внутреннего внимания:</p> <p><img src="https://habrastorage.org/r/w1560/webt/mc/mz/qq/mcmzqqb80hq14cyooubulhh3hhu.png" alt="gpt2-self-attention-project-1"></p> <p>Проделав это, мы создаем вектор, который можно передать в следующий слой:</p> <p><img src="https://habrastorage.org/r/w1560/webt/af/tl/0o/aftl0oqxhho-m6uph1uqer2a4_c.png" alt="gpt2-self-attention-project-2"></p> <h3 id="полносвязная-неиронная-сеть-gpt-2-слои-1"><a href="#полносвязная-неиронная-сеть-gpt-2-слои-1" class="header-anchor">#</a> Полносвязная нейронная сеть GPT-2: Слой #1</h3> <p>Полносвязная нейронная сеть – это сеть, где блоки обрабатывают входной токен после того, как внутреннее внимание включило подходящий контекст в его представление. Она состоит из двух слоев. Первый слой в 4 раза больше размера модели (поскольку маленькая GPT-2 имеет размерность 768, эта нейронная сеть будет иметь 768*4 = 3072 нейронов). Почему именно в четыре? Просто это размер оригинального Трансформера (размерность модели была 512 и слоя #1 – 2048). Кажется, что это дает моделям Трансформера достаточную мощность представления для решения задач, которые ему до сих пор давались.</p> <p><img src="https://habrastorage.org/webt/gu/4d/ci/gu4dciafj9oa7wcbnt1pwtpfcu8.gif" alt="gpt2-mlp1"></p> <p><em>(Вектор смещения не отображен)</em></p> <h3 id="полносвязная-неиронная-сеть-gpt-2-проецирование-на-размерность-модели"><a href="#полносвязная-неиронная-сеть-gpt-2-проецирование-на-размерность-модели" class="header-anchor">#</a> Полносвязная нейронная сеть GPT-2: Проецирование на размерность модели</h3> <p>Второй слой проецирует результат первого на размерность модели (768 у маленькой GPT-2). Результатом этого перемножения будет выход блока Трансформера для данного токена.</p> <p><img src="https://habrastorage.org/webt/x-/eh/kj/x-ehkj3y5dyunh4nf3v7aykhp70.gif" alt="gpt2-mlp-2"></p> <p><em>(Вектор смещения не отображен)</em></p> <h2 id="вы-сделали-это"><a href="#вы-сделали-это" class="header-anchor">#</a> Вы сделали это!</h2> <p>Это наиболее детальное описание блока Трансформера, в которое мы когда-либо пускались. Вы теперь имеете достаточно обширную картину того, что происходит внутри языковой модели Трансформера. Подводя итоги, покажем, как наш храбрый входной вектор взаимодействует с матрицами весов:</p> <p><img src="https://habrastorage.org/r/w1560/webt/yz/n7/20/yzn720lcfsuwwky-r3kanjys3w0.png" alt="gpt2-transformer-block-weights-2"></p> <p>Каждый блок имеет свой собственный набор весов. С другой стороны, модель имеет только одну матрицу эмбеддинга токена и одну матрицу позиционного кодирования:</p> <p><img src="https://habrastorage.org/r/w1560/webt/xl/22/mc/xl22mctq_nzefihu84kxryqj5be.png" alt="gpt2-weights-2"></p> <p>Если вы хотите увидеть все параметры этой модели, то они перечислены ниже:</p> <p><img src="https://habrastorage.org/r/w1560/webt/vk/it/nh/vkitnhrnvo0djn0gn1_e0fpzhp0.png" alt="gpt2-117-parameters"></p> <p>По какой-то причине здесь используется 124М параметров вместо 117М. Не вполне понятно почему, но кажется, что именно такое количество публикуется в открытом коде (поправьте, если это не так).</p> <h1 id="часть-3-за-пределами-языкового-моделирования"><a href="#часть-3-за-пределами-языкового-моделирования" class="header-anchor">#</a> Часть 3: за пределами языкового моделирования</h1> <p>Декодирующие Трасформеры подают надежды и в задачах, отличных от языкового моделирования. Существует множество успешных применений этих моделей, которые можно визуализировать схожим образом. В завершение статьи посмотрим некоторые из этих применений.</p> <h2 id="машинныи-перевод"><a href="#машинныи-перевод" class="header-anchor">#</a> Машинный перевод</h2> <p>Энкодер не строго обязателен для осуществления перевода. Ту же задачу можно решить с помощью декодирующего Трансформера:</p> <p><img src="https://habrastorage.org/r/w1560/webt/ni/vt/bw/nivtbwcuuxla5cx5p2srhoohfgm.png" alt="decoder-only-transformer-translation"></p> <h2 id="суммаризация"><a href="#суммаризация" class="header-anchor">#</a> Суммаризация</h2> <p>Это та задача, для которой был обучен самый первый декодирующий Трасформер. А именно, он был обучен читать статьи Википедии (без вводной части, расположенной до содержания) и обобщать их. Реальные обобщающие части статей использовались в качестве тэгов в обучающем датасете:</p> <p><img src="https://habrastorage.org/r/w1560/webt/gd/3u/h5/gd3uh5vlhfzoarket8i2eeudj_4.png" alt="wikipedia-summarization"></p> <p>Обученная на статьях Википедии модель могла затем самостоятельно обобщать их.</p> <p><img src="https://habrastorage.org/r/w1560/webt/f2/-z/8v/f2-z8vum88usd2nyshvwwpesjq8.png" alt="decoder-only-summarization"></p> <h2 id="трансферное-обучение"><a href="#трансферное-обучение" class="header-anchor">#</a> Трансферное обучение</h2> <p>В статье <a href="https://arxiv.org/abs/1905.08836" target="_blank" rel="noopener noreferrer">Sample Efficient Text Summarization Using a Single Pre-Trained Transformer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> декодирующий Трасформер сначала был предобучен для языкового моделирования, а затем тонко настроен на суммаризацию. Оказалось, что благодаря такому подходу можно достичь лучших результатов, чем на предобученной модели энкодер-декодер на ограниченных объемах данных.</p> <p>В релизной статье GPT-2 также приведены результаты суммаризации после предобучения модели на задаче языкового моделирования.</p> <h2 id="генерация-музыки"><a href="#генерация-музыки" class="header-anchor">#</a> Генерация музыки</h2> <p><a href="https://magenta.tensorflow.org/music-transformer" target="_blank" rel="noopener noreferrer">Музыкальный Трансформер<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> использует архитектуру декодирующего Трасформера для генерации выразительной и динамичной музыки. «Музыкальное моделирование» очень похоже на языковое моделирование – просто позвольте модели обучаться музыке без учителя и свободно генерировать выходные последовательности (то, что мы называли выше «свободным плаванием»).</p> <p>Вы можете задаться вопросом, как в таком случае представляется музыка. Помните, что языковое моделирование может осуществляться с помощью векторных представлений букв (символов), слов или токенов (частей слов). Для представления музыки (исполненной, например, на фортепиано) мы можем взять ноты и их «скорость» – меру того, как сильно была нажата клавиша.</p> <p><img src="https://habrastorage.org/r/w1560/webt/en/x-/g2/enx-g2e1om4ctwjcuvnsspcjzcm.png" alt="music-transformer-performance-encoding-3"></p> <p>Произведение – это просто набор таких one-hot векторов. Файл формата midi может быть преобразован в такой формат. В статье есть следующий пример входной последовательности:</p> <p><img src="https://habrastorage.org/r/w1560/webt/q2/0s/vv/q20svvnlw_1ji4s_fjejnlnrckc.png" alt="music-representation-example"></p> <p>Представление one-hot вектора для этой входной последовательности будет выглядеть следующим образом:</p> <p><img src="https://habrastorage.org/r/w1560/webt/gh/av/o5/ghavo5srziiagcrg-zqzg0vbnjg.png" alt="music-transformer-input-representation-2"></p> <p>Также в статье есть прекрасная визуализация внутреннего внимания Музыкального Трансформера:</p> <p><img src="https://habrastorage.org/r/w1560/webt/gg/up/ou/ggupou0idkyeu2oc-dtgvxayxsa.png" alt="music-transformer-self-attention-2"></p> <p>Если подобное представление музыкальных нот еще не совсем понятно, см. <a href="https://www.youtube.com/watch?v=ipzR9bhei_o" target="_blank" rel="noopener noreferrer">видео<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h1 id="заключение"><a href="#заключение" class="header-anchor">#</a> Заключение</h1> <p>Пора подытожить наше путешествие в GPT-2 и ее родительскую модель – декодирующий Трансформер. Надеемся, что после прочтения этой статьи вы стали лучше понимать механизм внутреннего внимания и теперь, когда вы знаете, что происходит внутри трансформера, вы можете более комфортно использовать модели на его основе.</p> <h1 id="материалы"><a href="#материалы" class="header-anchor">#</a> Материалы</h1> <ul><li><a href="https://github.com/openai/gpt-2" target="_blank" rel="noopener noreferrer">Реализация GPT-2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> от OpenAI</li> <li>См. библиотеку <a href="https://github.com/huggingface/pytorch-transformers" target="_blank" rel="noopener noreferrer">pytorch-transformers2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> от <a href="https://huggingface.co/" target="_blank" rel="noopener noreferrer">Hugging Face<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, в которой помимо GPT-2, реализованы BERT, Transformer-XL, XLNet и другие передовые модели Трансформера.</li></ul> <h1 id="авторы"><a href="#авторы" class="header-anchor">#</a> Авторы</h1> <ul><li><strong>Автор оригинала</strong> – <a href="https://jalammar.github.io/illustrated-gpt2/" target="_blank" rel="noopener noreferrer">Jay Alammar<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><strong>Перевод</strong> – <a href="https://habr.com/ru/users/smekur/" target="_blank" rel="noopener noreferrer">Смирнова Екатерина<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><strong>Редактирование и вёрстка</strong> – <a href="https://habr.com/ru/users/kouki_rus/" target="_blank" rel="noopener noreferrer">Шкарин Сергей<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.dec9f71a.js" defer></script><script src="/assets/js/2.733019b2.js" defer></script><script src="/assets/js/32.566fa885.js" defer></script>
  </body>
</html>
